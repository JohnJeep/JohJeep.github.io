<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>03-C++Standard | Leaning Computer Science Journey</title><meta name="author" content="John Jeep"><meta name="copyright" content="John Jeep"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++ 新特性演化整体概览。  1. C++11 新特性1.1. Template of  Space在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。 12vector&lt;list&lt;int&gt; &gt; ;  &#x2F;&#x2F; C+11 之前版本，必须要">
<meta property="og:type" content="article">
<meta property="og:title" content="03-C++Standard">
<meta property="og:url" content="https://johnjeep.github.io/Cpp/Cpp/03-C++Standard/index.html">
<meta property="og:site_name" content="Leaning Computer Science Journey">
<meta property="og:description" content="C++ 新特性演化整体概览。  1. C++11 新特性1.1. Template of  Space在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。 12vector&lt;list&lt;int&gt; &gt; ;  &#x2F;&#x2F; C+11 之前版本，必须要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://johnjeep.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-04T12:24:00.000Z">
<meta property="article:modified_time" content="2025-04-04T12:24:27.265Z">
<meta property="article:author" content="John Jeep">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="03-C++Standard">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://johnjeep.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "03-C++Standard",
  "url": "https://johnjeep.github.io/Cpp/Cpp/03-C++Standard/",
  "image": "https://johnjeep.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-04T12:24:00.000Z",
  "dateModified": "2025-04-04T12:24:27.265Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Jeep",
      "url": "https://johnjeep.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://johnjeep.github.io/Cpp/Cpp/03-C++Standard/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Jeep","link":"链接: ","source":"来源: Leaning Computer Science Journey","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '03-C++Standard',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">03-C++Standard</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">03-C++Standard</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T12:24:27.265Z" title="更新于 2025-04-04 20:24:27">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!--
 * @Author: JohnJeep
 * @Date: 2021-01-10 18:21:43
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-04-04 19:25:31
 * @Description: C++ 语言不同标准新特性学习
 * Copyright (c) 2022 by JohnJeep, All Rights Reserved.
-->

<p>C++ 新特性演化整体概览。</p>
<p><img src="/figures/cpp_evolution.png"></p>
<h1 id="1-C-11-新特性"><a href="#1-C-11-新特性" class="headerlink" title="1. C++11 新特性"></a>1. C++11 新特性</h1><h2 id="1-1-Template-of-Space"><a href="#1-1-Template-of-Space" class="headerlink" title="1.1. Template of  Space"></a>1.1. Template of  Space</h2><p>在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt; &gt; ;  <span class="comment">// C+11 之前版本，必须要加一个空格，否则编译器会报错</span></span><br><span class="line">vector&lt;list&lt;<span class="type">int</span>&gt;&gt; ;   <span class="comment">// C++11 之后，不用加空格，语法得到了优化</span></span><br></pre></td></tr></table></figure>


<h2 id="1-2-Initializer-lists"><a href="#1-2-Initializer-lists" class="headerlink" title="1.2. Initializer lists"></a>1.2. Initializer lists</h2><p>C++11 引入了初值列 (initializer list) 和一致性初始化 (Uniform Initialization)。即采用 <code>&#123;&#125;</code> 去初始化需要初始化的参数，引入新特的同时也兼容原版本的 <code>()</code> 初始化操作。</p>
<img src="./figures/uniform-initialization.png">


<p><code>initializer list</code> 的底层是采用 <code>initializer_list&lt;T&gt;</code> 这个类模板实现的，其中这个类模板下层采用 <code>array&lt;T, n&gt;</code> 的方式去实现的。<br><img src="./figures/initialize-list.png"></p>
<p><code>初值列</code> 赋值是在对象创建成功之前完成的，而 <code>函数体内赋值</code> 是你的对象成员都已经创建好后再对成员进行赋值。<code>初值列</code> 是在带参构造函数的函数体外面，第一行进行初始化。</p>
<ul>
<li>初值列初始化语法<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  将成员变量设置为 m_re=re, m_im=im</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">Stu</span><span class="params">(<span class="type">int</span> re, <span class="type">int</span> im)</span></span></span><br><span class="line"><span class="function">  : m_re(re), m_im(im)</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">      ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_re;</span><br><span class="line">  <span class="type">int</span> m_im;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>这种初始化并不是必须的，但是在以下几种情况时是必须进行初始化的<ul>
<li>成员是 <code>const</code> 类型。</li>
<li>成员是 <code>引用类型</code>。</li>
<li>有一个成员是类型的对象（不是默认的构造函数）。<blockquote>
<p>初始化列表的顺序并不限定初始化的执行顺序，成员的初始化顺序是与类中定义的顺序保持一致。最好让构造函数初始值的顺序与成员声明的顺序保持一致。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-nullptr"><a href="#1-3-nullptr" class="headerlink" title="1.3. nullptr"></a>1.3. nullptr</h2><p>C++11 开始让你使用 <code>nullptr</code> 关键字去替代老版本中 <code>0 或 NULL</code> 的值。<code>nullptr</code> 不是整型也不是一个指针类型，你可以把它认为是 <strong>所有</strong>类型的指针。它表示一个指针指向的值是没有值的，这个特性可以避免当一个 <code>NULL</code> 指针被当做一个整型解释时，程序产生的错误。</p>
<p><code>nullptr</code> 的真正的类型是 <code>std::nullptr_t</code>，位于标准库的 <code>&lt;stddef.h&gt;</code> 头文件中。在源码中，<code>std::nullptr_t</code> 被重定义（define）为 <code>nullptr</code>。因此 <code>std::nullptr_t</code> 可以隐式转换为任意的原生指针（raw pointer）类型，这也是为什么 <code>nullptr</code> 表现得像所有类型的指针。</p>
<p>标准库中源码实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__cplusplus) &amp;&amp; __cplusplus &gt;= 201103L</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _GXX_NULLPTR_T</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> <span class="type">nullptr_t</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* C++11.  */</span></span></span><br></pre></td></tr></table></figure>

<p>推荐优先考虑 <code>nullptr</code> 而非 <code>0</code> 和 <code>NULL</code> 的原因</p>
<ul>
<li><p>如果 C++ 发现在当前上下文只能使用指针，它会很不情愿地把 <code>0</code> 解释为指针（pointer），但那是最后的办法。一般情况下，C++ 的解析策略是把 <code>0</code> 看做 <code>int</code> 而非指针类型，把 <code>NULL</code> 解析成 <code>integral(int 或 long 类型)</code>，而非指针类型。</p>
</li>
<li><p>避免函数重载（overload）解析产生的歧义。若使用 <code>nullptr</code> 替代 <code>0</code> 或 <code>NULL</code> 可以避免函数重载解析时一些意想不到的问题。<br>在 C++98 中，对指针类型和整型进行函数重载可能会导致意想不到的错误。比如下面的代码，函数重载中传递参数 <code>0</code> 或 <code>NULL</code>，调用时，前两种重载的函数会调用，但不会调用指针版本的重载函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个重载函数 f()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">bool</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="number">0</span>);               <span class="comment">// 调用 f(int) 重载函数而不是 f(void*)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">f</span>(<span class="literal">NULL</span>);            <span class="comment">// 可能不会被编译，一般来说调用 f(int)，</span></span><br><span class="line">                    <span class="comment">// 绝对不会调用 f(void*) 重载函数</span></span><br></pre></td></tr></table></figure>

<p><code>f(NULL)</code> 函数调用的不确定行为是因为参数 <code>NULL</code> 的实现不同造成的。若 <code>NULL</code> 被定义为 <code>0</code> ，其类型为 <code>long</code> 时，函数调用是有歧义的。因为从 <code>long</code> 转化为 <code>int</code>，<code>long</code> 转化为 <code>bool</code> 和 <code>0</code> 转化为 <code>void*</code> ，都要进行类型转化。代码中认为调用 <code>f(NULL)</code> 函数，传递的参数就是 <code>null</code> 指针，而实际上调用 <code>f(NULL)</code> 函数，传递的参数是 <code>integral</code>，并不是 <code>null</code> 指针。由于这种违反直觉的行为，导致以 C++98 风格编写代码的程序员，要避免函数重载时，传指针和整型的情形。</p>
<p>调用时，若函数传递的参数为 <code>nullptr</code>，将会调用 <code>void*</code> 版本的重载函数，因为 <code>nullptr</code> 不能被看做任何的整形。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="literal">nullptr</span>); <span class="comment">// calls f(void*) overload</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>特别是与 <code>auto</code> 声明的变量一起使用时，使代码表意更明确。<br>比如：你在代码库中遇到了这样的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">findRecord</span>(<span class="comment">/* arguments */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你不知道 <code>findRecord</code> 函数返回类型是什么，那么你也许不清楚 <code>result</code> 是一个指针类型还是一个整型。毕竟 <code>0</code> 也可以解析为 指针类型或整型，容易引发歧义。</p>
<p>若将 <code>0</code> 替换为 <code>nullptr</code> 后，函数返回的结果不会产生歧义（ambiguity），因为 <code>result</code> 的类型一定为指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = <span class="built_in">findRecord</span>(<span class="comment">/* arguments */</span>);</span><br><span class="line"><span class="keyword">if</span> (result == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>模板类型推导将 <code>0</code> 和 <code>NULL</code> 推导为一个错误的类型（即它们的实际类型，而不是作为空指针的隐含意义），这就导致在当你想要一个空指针时，它们的替代品 <code>nullptr</code> 很吸引人。</p>
<p>假如你有一些函数只能被合适的已上锁的 <code>mutex</code> 调用，且每个函数的形参都是指针类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能被以上锁合适的 mutex 调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f1</span><span class="params">(std::shared_ptr&lt;Widget&gt; spw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f2</span><span class="params">(std::unique_ptr&lt;Widget&gt; upw)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f3</span><span class="params">(Widget* pw)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用代码传递的是 <code>null</code> 指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">std::mutex f1m, f2m, f3m; <span class="comment">// mutexes for f1, f2, and f3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> MuxGuard = <span class="comment">// C++11 typedef; see Item 9</span></span><br><span class="line">std::lock_guard&lt;std::mutex&gt;;</span><br><span class="line">    …</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f1m)</span></span>;     <span class="comment">// lock mutex for f1</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f1</span>(<span class="number">0</span>); <span class="comment">// pass 0 as null ptr to f1</span></span><br><span class="line">&#125;                        <span class="comment">// unlock mutex</span></span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f2m)</span></span>;        <span class="comment">// lock mutex for f2</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f2</span>(<span class="literal">NULL</span>); <span class="comment">// pass NULL as null ptr to f2</span></span><br><span class="line">&#125;                           <span class="comment">// unlock mutex</span></span><br><span class="line"></span><br><span class="line">…</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(f3m)</span></span>;           <span class="comment">// lock mutex for f3</span></span><br><span class="line">    <span class="keyword">auto</span> result = <span class="built_in">f3</span>(<span class="literal">nullptr</span>); <span class="comment">// pass nullptr as null ptr to f3</span></span><br><span class="line">&#125;                              <span class="comment">// unlock mutex</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，前两个的调用没有使用 <code>nullptr</code>，但代码可以正常工作。但是代码中有重复的调用，会多次执行 <code>lock mutex, call function, unlock mutex</code> 这些步骤，让代码很臃肿。模板的使用会减少代码量，上面的代码很臃肿，因此可用模板来执行上面的流程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> FuncType,</span></span><br><span class="line"><span class="function">         <span class="keyword">typename</span> MuxType,</span></span><br><span class="line"><span class="function">         <span class="keyword">typename</span> PtrType&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">lockAndCall</span><span class="params">(FuncType func,</span></span></span><br><span class="line"><span class="params"><span class="function">                 MuxType&amp; mutex,</span></span></span><br><span class="line"><span class="params"><span class="function">                 PtrType ptr)</span> -&gt; <span class="title">decltype</span><span class="params">(func(ptr))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MuxGuard <span class="title">g</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">func</span>(ptr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>调用 <code>lockAndCall</code> 模板函数可用下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result1 = <span class="built_in">lockAndCall</span>(f1, f1m, <span class="number">0</span>);         <span class="comment">// error!</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> result2 = <span class="built_in">lockAndCall</span>(f2, f2m, <span class="literal">NULL</span>);      <span class="comment">// error!</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span> result3 = <span class="built_in">lockAndCall</span>(f3, f3m, <span class="literal">nullptr</span>);   <span class="comment">// fine</span></span><br></pre></td></tr></table></figure>

<p>代码中的前两个是不能通过编译的。第一个调用的问题是：当 <code>0</code> 被传递给 <code>lockAndCall</code> 模板函数时，模板类型推导会尝试去推导实参类型，将 <code>lockAndCall</code> 模板函数的 <code>ptr</code> 形参被推导为 <code>int</code> 类型。与 <code>f1</code> 函数期待的 <code>std::shared_ptr&lt;Widget&gt;</code> 类型不符。因为传递 <code>0</code> 给 <code>lockAndCall</code> 模板函数本来想表示空指针，但  <code>f1</code> 函数得到的却是 <code>int</code> 类型。把 <code>int</code> 类型看做 <code>std::shared_ptr&lt;Widget&gt;</code> 类型传递给 <code>f1</code> 函数，编译时会产生类型错误（type error）。</p>
<p>第二个调用的问题是：当 <code>NULL</code> 被传递给 <code>lockAndCall</code> 模板函数时，形参 <code>ptr</code> 被推导为整型（integral）。即当形参 <code>ptr</code> 的类型为 <code>int</code> 或者类似 <code>int</code> 的类型时，传递给  <code>f2</code> 函数的时候就会发生类型错误（type error），因为 <code>f2</code> 函数期待的是 <code>std::unique_ptr&lt;Widget&gt;</code> 类型。</p>
<p>第三个调用是没有问题的。当 <code>nullptr</code> 传给 <code>lockAndCall</code> 模板函数时，形参 <code>ptr</code> 被推导为 <code>std::nullptr_t</code> 类型。当 <code>ptr</code> 被传递给 <code>f3</code> 函数时，隐式的将 <code>std::nullptr_t</code> 转换为 <code>Widget</code> 类型，因为 <code>std::nullptr_t</code> 可以隐式转换为任何指针类型。</p>
</li>
</ul>
<p><strong>准则</strong></p>
<ul>
<li>优先考虑 <code>nullptr</code> 而非 <code>0</code> 和 <code>NULL</code></li>
<li>避免重载指针和整型</li>
</ul>
<h2 id="1-4-range-based-for-statement"><a href="#1-4-range-based-for-statement" class="headerlink" title="1.4. range based for statement"></a>1.4. range based for statement</h2><p>引入了一种崭新的 <code>for</code> 循环：逐一迭代给定的某个区间、数组、集合、表达式、初始值列表内的每一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;)   <span class="comment">// 注意: &#123;&#125; 表示是一个容器，初始值列表</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="./figures/range-base-for.png">


<h2 id="1-5-Lambda"><a href="#1-5-Lambda" class="headerlink" title="1.5. Lambda"></a>1.5. Lambda</h2><p>Lambda 表达式是现代 C++ 中最重要的特性之一，而 Lambda 表达式，实际上就是提供了一个类似匿名函数的特性， 而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。这样的场景其实有很多很多， 所以匿名函数几乎是现代编程语言的标配。</p>
<p>lambda 表达式是 C++11 新引进的一种新特性，允许内联函数的定义（inline functionality）作为 <code>parameter（参数）</code> 或者 <code>local object（局部对象）</code>，它改变了 C++ 标准库使用的方式。</p>
<p>lambda 是一份功能性的定义，定义在语句（statement）和表达式（expression）中，可以使用 lambda 作为内联函数。</p>
<p>基本语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[捕获列表](参数列表) <span class="built_in">mutable</span>(可选) 异常属性 -&gt; 返回类型 &#123;</span><br><span class="line"><span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt;img title&#x3D;””src&#x3D;”.&#x2F;figures&#x2F;1-lambda.png”alt&#x3D;”” width&#x3D;”704”&gt;</p>
<p>上面的语法规则除了 <code>[捕获列表]</code> 内的东西外，其他部分都很好理解，只是一般函数的函数名被略去， 返回值使用了一个 <code>-&gt;</code> 的形式进行。</p>
<p>所谓捕获列表，其实可以理解为参数的一种类型，lambda 表达式内部函数体在默认情况下是不能够使用函数体外部的变量的， 这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：</p>
<ul>
<li><p><code>[=]</code>: 以传值的方式捕获外部作用域之外的所有变量，若 lambda 中有被定义的内容时。不能修改外部作用域中的数据，只有 read 的权限。</p>
</li>
<li><p><code>[&amp;]</code>: 以传引用的方式捕获外部作用域之外的所有变量，若 lambda 中有被定义的内容时，可以修改外部作用域中的数据，具有 write 的权限。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> val = [x, &amp;y]()&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;x:&quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;y:&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    ++y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 当前 x，y 分别捕获的值是 100，200</span></span><br><span class="line">x = y = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前 x，y 分别捕获的值是 100，300，</span></span><br><span class="line"><span class="comment">// 当 x 为值传递，外部值的改变不会改变 lambda 中原先以捕获的值，其中 x 原来捕获的值为 x=100</span></span><br><span class="line"><span class="built_in">val</span>();</span><br><span class="line"><span class="built_in">val</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;final y:&quot;</span> &lt;&lt; y &lt;&lt; endl</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果为：</span></span><br><span class="line">x: <span class="number">100</span></span><br><span class="line">y: <span class="number">300</span></span><br><span class="line">x: <span class="number">100</span></span><br><span class="line">y: <span class="number">301</span></span><br><span class="line"><span class="keyword">final</span> y: <span class="number">302</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>[]：表示不捕获任何外部变量</p>
</li>
<li><p>[this]：捕获外部的 this 指针</p>
</li>
<li><p>[&#x3D;，&amp;a]：以传值的方式捕获外部的所有变量，但是 a 变量以传引用的方式捕获</p>
</li>
<li><p>[a，b]：以传值的方式捕获外部变量 a 和 b</p>
</li>
<li><p>[a, &amp;b]：a 以传值方式捕获，b 以传引用的方式捕获</p>
</li>
</ul>
<img src="./figures/2-lambda.png">

<p>当 lambda 说明中有 mutable 关键字修饰时，表明在 lambda 中可以改变捕获的值。上图中的第一个案例表明，开始时捕获的 id&#x3D;0, 当运行至 <code>id=42</code> 这一行时，由于是按照 值传递，且 lambda 还没有执行，因此，lambda 中的 id 捕获的还是为 0 ，当执行 lambda 后，id 值每次 ++，改变了 lambda 表达式中捕获的内容。</p>
<img src="./figures/3-lambda.png">


<p><font color=red> 注意：</font></p>
<ul>
<li>lambda 没有默认的构造和赋值操作函数（ <code>default constructor</code> 和 <code>assignment operator</code>）。</li>
<li>捕获变量中没有加 <code>=</code> 或 <code>&amp;</code> 时，编译器默认按照是值传递 <code>=</code>；在捕获变量时，一边建议使用 传引用，而非传值。</li>
</ul>
<p>优点</p>
<ul>
<li>C++ 编译器对 lambda 的优化效果高于普通的函数。</li>
</ul>
<p>缺点</p>
<ul>
<li>根据 C++ 语言规定，lambda 没有默认的构造函数，也没有 assignment 操作符。</li>
</ul>
<h2 id="1-6-decltype"><a href="#1-6-decltype" class="headerlink" title="1.6. decltype"></a>1.6. decltype</h2><p>decltype 是 C++11 增加的一个关键字，作为类型推导，操作过程是在编译时进行的。</p>
<p>decltype 通常有以下几种用法：</p>
<ul>
<li>常常与 <code>typdef/using</code> 关键字结合起来使用。</li>
<li>可以处理匿名的类型。比如：<code>union</code>, <code>struct </code> 结构中出现的匿名数据，可以使用这个来解决。</li>
<li><strong>最重要的一个作用：推导函数的返回类型 (used to declare return types)。</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 + T2)</span>-&gt;<span class="title">decltype</span><span class="params">(x + y)</span></span>;   <span class="comment">// 自动推导 x + y 结果的返回类型</span></span><br></pre></td></tr></table></figure></li>
<li>元编程中使用 (use it in metaprogramming)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">common_type</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">true</span> ? declval&lt;T1&gt;() : declval&lt;T2&gt;())</span> type</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>lambda 表达式作为类型参数传入 (use to pass the type of the a lambda)<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> cmp = [](<span class="type">const</span> Person1&amp;, <span class="type">const</span> Person2) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::set&lt;Person, <span class="title">decltype</span><span class="params">(cmp)</span>&gt; <span class="title">p</span><span class="params">(cmp)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-7-explicit"><a href="#1-7-explicit" class="headerlink" title="1.7. explicit"></a>1.7. explicit</h2><p>大部分情况下 <code>explicit</code> 关键字用在构造函数中，只有少部分用在模板中。注意：被 <code>explicit</code> 关键字修饰的构造函数，不能进行自动地进行隐式 (implicit) 类型转换，只能显式 (explicit) 地进行类型转换。</p>
<ul>
<li>当类的声明和定义分别在两个文件中时，<code>explicit</code> 只能写在在声明 (<code>declaration</code>) 中，不能写在定义 (<code>definition</code>) 中。</li>
<li>被声明为 <code>explicit</code> 的构造函数通常比它的兄弟 <code>non-explicit</code> 更受欢迎，因为它们禁止编译器执行非预期（往往也不被期望）的类型转换。除非我有一个好的理由允许构造函数被用于隐式类型转换，否则我会把它声明为 <code>explicit</code> 。我鼓励你遵循相同的政策。</li>
</ul>
<h2 id="1-8-auto"><a href="#1-8-auto" class="headerlink" title="1.8. auto"></a>1.8. auto</h2><p>C++11 中新增的一个关键字，让编译器通过初始值去分析所属类的类型。<code>auto</code> 关键字会完成类型自动推导 (Automatic Type Deduction with auto)：根据初始值自动推导变量的类型，因此，在使用这个关键字之前，必须需要将变量初始化。</p>
<ul>
<li><code>auto</code> 一般会忽略掉顶层的 const，但底层的 const 会保留下来。从变量声明的初始化表达式处获得变量的类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// ci 的推演类型是 int，f 是 const int</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-9-noexcept"><a href="#1-9-noexcept" class="headerlink" title="1.9. noexcept"></a>1.9. noexcept</h2><p>C++11 引入了该关键字 <code>noexcept</code>。该关键字告诉编译器，指定的某个函数不会抛出异常。通常有两种不同的方式来使用这个关键字。</p>
<ul>
<li>第一种方式，简单地将 <code>noexcept</code> 关键字放在函数声明的后面，这样该函数便会被标记为不会抛出异常。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span>)</span> <span class="keyword">noexcept</span></span>;   <span class="comment">// 表明 add() 函数不会抛出异常</span></span><br></pre></td></tr></table></figure></li>
<li>第二种方式：为 <code>noexcept</code> 关键字额外提供一个常量表达式作为其参数，若这个常量表达式的值为 “true”，那么函数就会被标记为不会抛出异常，反之亦然。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">bool</span> suppressExcept = <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">excpt_func</span><span class="params">()</span> <span class="title">noexcept</span> <span class="params">(suppressExcept)</span></span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<font color=red>
注意：
</font>

<ul>
<li>若当前函数抛出来的异常没有被立即处理，则一直通过 throw 关键往上抛，直到被标准库中的 <code>std::terminal()</code> 捕获，再去处理，其中 <code>std::terminal()</code> 内部默认调用的是 <code>std::abort()</code>。</li>
<li>C++ 中的异常处理是在程序运行时检测，而不是编译时检测的。为了实现运行时检测，编译器会创建额外的代码，然而这会妨碍程序优化。</li>
<li>函数指针的声明和定义中可以指定 <code>noexcept</code></li>
<li><code>typedef 或类型的别名 </code> 中不能使用 <code>noexcept</code></li>
<li>成员函数中，<code>noexcept</code> 需要跟在 <code>const 或引用 </code> 限定符之后，但是跟在 <code>final、override 或虚函数 = 0</code> 这些限定符之前。</li>
<li>移动构造函数 (move constructor)：在对象进行 <code>copy</code> 时，直接拷贝对象所保有的一些资源。比如，已经在原对象中分配的堆内存、文件描述符，以及 IO 流等。</li>
<li>移动分配函数 (move assignment)</li>
<li>析构函数 (destructor)。在新版本的编译器中，析构函数是默认加上关键字 <code>noexcept</code> 的。</li>
</ul>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.yhspy.com/2019/11/22/C-%E4%B8%AD%E7%9A%84%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E4%B8%8E-noexcept/">C++ 中的移动构造与 noexcept</a></li>
</ul>
<h2 id="1-10-constexpr"><a href="#1-10-constexpr" class="headerlink" title="1.10. constexpr"></a>1.10. constexpr</h2><p>常量表达式 (const expression)：表示值不会改变，并且在编译过程中就能得到计算的结果的表达式。</p>
<ul>
<li><p>为什么要使用 constexpr？</p>
<blockquote>
<p>提高程序的执行效率，允许一些计算发生在编译时，而不是在运行的时候，因而采用常量表达式。<code>constexpr</code> 关键字在 C++11 中引入，而在 C++14 中得到改善，使用更加灵活。<code>constexpr</code> 表示允许将变量声明为 <code>constexpr</code> 类型，让编译器来验证变量的值是否是一个常数表达式。</p>
</blockquote>
</li>
<li><p>const 与 constexpr 的区别：</p>
<ul>
<li>const 变量的初始化可以延迟到程序运行时</li>
<li>constexpr 变量的初始化必须在编译时进行，但不能作为函数的参数。</li>
<li>constexpr 指针：限定符 constexpr 仅对指针有效，与指针所指向的对象无关。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* p = nullpter;      <span class="comment">// p 是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* q = <span class="literal">nullptr</span>;   <span class="comment">// q 是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>利用 constexpr 可以修饰函数。修饰的函数可是：普通成员函数、构造函数、模板函数。</p>
<ul>
<li>修饰函数时，函数体必须要有返回值，且返回的表达式必须是常量表达式，非常量表达式就编译报错。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>整个函数的函数体中不能出现非常量表达式之外的语句，例如 <code>for</code> 循环。但 using 语句，typedef 语句，static_assert 断言以及 return 语句等这些语句除外。</li>
<li>constexpr 修饰构造函数时，类中的变量初始化必须放在初始值列表，且构造函数中必须是空的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">Animal</span>(<span class="type">int</span> id) : <span class="built_in">m_id</span>(id)</span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="type">int</span> m_id;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initializer list 中的一段源码</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> <span class="type">const</span> _Tp*</span></span><br><span class="line"><span class="function">  <span class="title">begin</span><span class="params">(initializer_list&lt;_Tp&gt; __ils)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> __ils.<span class="built_in">begin</span>(); &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>在编译时，被 <code>constexpr</code> 修饰的函数会隐式的被指定为内联函数。其中内联函数一般定义在头文件中。</p>
</blockquote>
<p>参考: <a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/constexpr/#2-1-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0">https://subingwen.cn/cpp/constexpr/#2-1-%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0</a></p>
<h2 id="1-11-override"><a href="#1-11-override" class="headerlink" title="1.11. override"></a>1.11. override</h2><p>override 是 C++11 引进的一个说明符，翻译为 <code>覆盖、重写</code> 的意思。C++11 中的 override 关键字，可以显式的在派生类（子类）中声明，看哪些成员函数需要被重写。</p>
<ul>
<li>override 有什么用?<ul>
<li>一般在继承中，涉及到虚函数时，需要在子类中重新改写函数的内容，去实现父类的方法，这时 <code>override</code> 关键字就派上用场了。</li>
</ul>
</li>
<li>注意事项<ul>
<li>在派生类的成员函数中使用 override 时，如果基类中无此函数或基类中的函数并不是虚函数，编译器会给出相关错误信息。<img src="./figures/override.png"></li>
</ul>
</li>
</ul>
<h2 id="1-12-final"><a href="#1-12-final" class="headerlink" title="1.12. final"></a>1.12. final</h2><p>final 是 C++11 引进的一个说明符，有两种使用方式。</p>
<ul>
<li>第一种：用在 <code>class</code> 类名之后，表示当前的类是一个类的最终继承者，不能再被额外的类继承了。若还有子类继承自用 <code>final</code> 关键字修饰的父类，编译器则会报错。</li>
<li>第二种：虚函数中用于修饰函数。若父类中有用 <code>final</code> 关键字修饰的虚函数，则表明该虚函数不能再被其子类重写了，即它是一个最终的虚函数；否则编译器会报错。<img src="./figures/final.png"></li>
</ul>
<h2 id="1-13-New-Function-Declaration-Syntax"><a href="#1-13-New-Function-Declaration-Syntax" class="headerlink" title="1.13. New Function Declaration Syntax"></a>1.13. New Function Declaration Syntax</h2><p>New Function Declaration Syntax 是新的函数声明语法。</p>
<h2 id="1-14-Scoped-Enumerations"><a href="#1-14-Scoped-Enumerations" class="headerlink" title="1.14. Scoped Enumerations"></a>1.14. Scoped Enumerations</h2><p>Scoped Enumerations 英文可翻译为带作用域的枚举。</p>
<h2 id="1-15-New-Template-Features"><a href="#1-15-New-Template-Features" class="headerlink" title="1.15. New Template Features"></a>1.15. New Template Features</h2><h3 id="1-15-1-variadic-templates"><a href="#1-15-1-variadic-templates" class="headerlink" title="1.15.1. variadic templates"></a>1.15.1. <strong>variadic templates</strong></h3><p>variadic templates(参数数量不定的模板) 是 C++ 新增的一个非常重要的特性。</p>
<img src="./figures/1-variadic-templates.png">

<ul>
<li>代码部分<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @description: 当包 ... 中 的个数等于 0 时就会执行下面这个空的函数</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125;</span></span><br><span class="line"><span class="comment"> * @return &#123;*&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Types&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">my_print</span><span class="params">(<span class="type">const</span> T&amp; firstAgs, <span class="type">const</span> Types&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; firstAgs &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">my_print</span>(args...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">my_print</span>(<span class="number">100</span>, <span class="string">&quot;hello&quot;</span>, <span class="built_in">bitset</span>&lt;<span class="number">16</span>&gt;(<span class="number">377</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="./figures/2-variadic-templates.png">

<img src="./figures/3-variadic-templates.png">

<p>使用这个的好处是帮助我们解决递归。递归的过程就是把不定参数的个数一一分解出来。</p>
<h3 id="1-15-2-Alias-Templates-Template-Typedef"><a href="#1-15-2-Alias-Templates-Template-Typedef" class="headerlink" title="1.15.2. Alias Templates (Template Typedef)"></a>1.15.2. Alias Templates (Template Typedef)</h3><p>Alias Templates 是一个别名模板。</p>
<ul>
<li><p>简单用法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// declaration</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> Vec = std::Vector&lt;T, MyAlloc&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call</span></span><br><span class="line">Vec&lt;<span class="type">int</span>&gt; coll;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上面的代码等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>, MyAlloc&lt;<span class="type">int</span>&gt;&gt; coll;</span><br></pre></td></tr></table></figure></li>
</ul>
<img src="./figures/0-alias-template.png">

<font color=red>
alias template 不可能用作 偏特化 或 全特化。

<p>从上面的代码看，<code>using</code> 使用的效果与 <code>#define</code> 或 <code>typedef</code> 的用法似乎是一样的，其实并不是一样的，反而使用 <code>#define</code> 或 <code>typedef</code> 不能实现 <code>alias template</code> 所达到的效果。<br></font></p>
<img src="./figures/1-alias-template.png">

<img src="./figures/2-alias-template.png">

<img src="./figures/3-alias-template.png">


<h3 id="1-15-3-Type-Alias"><a href="#1-15-3-Type-Alias" class="headerlink" title="1.15.3. Type Alias"></a>1.15.3. Type Alias</h3><p>Type Alias 是一个类型别名。</p>
<ul>
<li>第一种用法与 <code>typedef</code> 的用法是一样的。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*func)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 两者实现的用法是等同的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">example</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">func f = example;</span><br></pre></td></tr></table></figure></li>
<li>第二种用法：type alias 用在 <code>member typedef name(成员类型名字)</code>。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;  <span class="comment">// 等同于 typedef T value_type;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 泛型编程中使用</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Cntr&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f2</span><span class="params">(<span class="type">const</span> Cntr&amp; ct)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typename</span> Cntr::value_type n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-15-4-Function-template"><a href="#1-15-4-Function-template" class="headerlink" title="1.15.4. Function template"></a>1.15.4. Function template</h3><h2 id="1-16-using"><a href="#1-16-using" class="headerlink" title="1.16. using"></a>1.16. using</h2><p>哪些地方会用到 using 关键字？</p>
<ul>
<li>第一种： namespace 用在命令空间中： <code>using namespace std;</code></li>
<li>第二种：为类成员做声明 (using-declarations for class members)。可用于子类继承于父类的成员或函数。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vector 容器中的一段源码</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_allocate;</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_deallocate;</span><br><span class="line">  <span class="keyword">using</span> _Base::_M_impl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>有一篇博客写得很好可以值得参考：<a target="_blank" rel="noopener" href="https://subingwen.cn/cpp/construct/">委托构造和继承构造函数</a>，可以看我自己用代码实现的例子：<a href="./code/c11/using.cpp">using 用法</a></p>
</blockquote>
</li>
<li>第三中：C++11 起引入了 <code>type alias</code> 和 <code>alias template</code>，可使用 <code>using</code> 关键字作为类型或模板的别名。<br>类模板中使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Container</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型别名</span></span><br><span class="line">  <span class="keyword">using</span> value_type = T;  <span class="comment">// 等同于 typedef T value_type;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板别名</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">CharT</span>&gt; <span class="keyword">using</span> mystring = std::basic_string&lt;CharT, std::char_traits&lt;CharT&gt;&gt;;</span><br></pre></td></tr></table></figure>

普通类型中使用<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数指针中使用，给类型起个别名</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(func1*)</span><span class="params">(<span class="type">int</span>, string)</span></span>;  <span class="comment">// 法一：使用 typedef</span></span><br><span class="line"><span class="keyword">using</span> func2 = <span class="built_in">int</span>(*)(<span class="type">int</span>, string);  <span class="comment">// 法二：使用 using</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>using 关键字的代码实现可参考：<a href="./code/c11/using.cpp">using 用法</a></p>
</blockquote>
<h2 id="1-17-Move-Semantics-and-Rvalue-References"><a href="#1-17-Move-Semantics-and-Rvalue-References" class="headerlink" title="1.17. Move Semantics and Rvalue References"></a>1.17. Move Semantics and Rvalue References</h2><p>Rvalue 只能出现在左边。常见的右值：<code> 临时对象 (temp object)</code>。</p>
<p>STL 中更好的解决 <code>perfect forward</code> 问题的的源码部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @addtogroup utilities</span></span><br><span class="line"><span class="comment"> *  @&#123;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an lvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Forward an rvalue.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to the specified type.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  This function is used to implement &quot;perfect forwarding&quot;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(!std::is_lvalue_reference&lt;_Tp&gt;::value, <span class="string">&quot;template argument&quot;</span></span><br><span class="line">          <span class="string">&quot;substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  @brief  Convert a value to an rvalue.</span></span><br><span class="line"><span class="comment"> *  @param  __t  A thing of arbitrary type.</span></span><br><span class="line"><span class="comment"> *  @return The parameter cast to an rvalue-reference to allow moving it.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-18-delete-default"><a href="#1-18-delete-default" class="headerlink" title="1.18. &#x3D;delete &amp;&amp; &#x3D;default"></a>1.18. &#x3D;delete &amp;&amp; &#x3D;default</h2><p>构造函数后面加上 <code>=default</code> 关键字，告诉编译器要显式的将哪个作为默认构造函数，而不去调用空类型参数的构造函数。比如：下面的类中，将拷贝赋值函数作为默认的构造函数，而不是 <code>Pro()</code> 这个构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pro</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Pro</span>();                                  <span class="comment">// constructor</span></span><br><span class="line">  <span class="built_in">Pro</span>(<span class="type">const</span> pro&amp;) = <span class="keyword">delete</span>;               <span class="comment">// copy constructor</span></span><br><span class="line">  <span class="built_in">Pro</span>(Pro&amp;&amp;) = <span class="keyword">default</span>;                   <span class="comment">// move constructor</span></span><br><span class="line">  Pro&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Pro&amp;) = <span class="keyword">default</span>;  <span class="comment">// copy assignment</span></span><br><span class="line">  Pro&amp; <span class="keyword">operator</span>= (<span class="type">const</span> Pro&amp;&amp;) = <span class="keyword">delete</span>;  <span class="comment">// move assignment</span></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Pro</span>();                         <span class="comment">// deconstructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类中有拷贝构造函数或拷贝赋值函数后，不能再在拷贝构造函数或拷贝赋值函数后面加 <code>=default</code> 或 <code>=delete</code> 关键字修饰了。</p>
<img src="./figures/delete-default-diff.png">

<img src="./figures/delete-default.png">


<h2 id="1-19-Chrono"><a href="#1-19-Chrono" class="headerlink" title="1.19. Chrono"></a>1.19. Chrono</h2><p>通用术语</p>
<ul>
<li><code>duration</code> 时间段：指的是在某时间单位时间上的一个明确的 tick（片刻数）。</li>
<li><code>timepoint</code>（时间点）：表示某个特定的时间点，是一个 duration 和 epoch 的组合。关联至某个 clock 的某个正值或负值 duration。</li>
<li><code>epoch</code>（时间段的起点）。1970 年 1 月 1 日是 UNIX 和 POSIX 系统时钟（system clock）的起点。</li>
</ul>
<h3 id="1-19-1-duration"><a href="#1-19-1-duration" class="headerlink" title="1.19.1. duration"></a>1.19.1. duration</h3><p>class duration 类 API 接口</p>
<ul>
<li><code>d.count()</code> 返回 duration d 的 tick 数量，即打印 tick 数。</li>
<li><code>duration::zero()</code> 获得一个长度为 0 的时间段（duration）。</li>
<li><code>duration::min()</code> 和 <code>duration::max()</code> 则分别获得一个 duration 所拥有的最小和最大值。</li>
<li><code>duration::rep</code> 获得 ticks 的类型。</li>
<li><code>duration::period</code> 获得 unit type 的类型。</li>
</ul>
<h3 id="1-19-2-timepoint-and-clock"><a href="#1-19-2-timepoint-and-clock" class="headerlink" title="1.19.2. timepoint and clock"></a>1.19.2. timepoint and clock</h3><h1 id="2-C-14-新特性"><a href="#2-C-14-新特性" class="headerlink" title="2. C++14 新特性"></a>2. C++14 新特性</h1><p>C++14 引入了一些新特性，以下是其中一些：</p>
<ol>
<li><p>泛型 lambda 表达式：允许 lambda 表达式具有自动类型推导和通用的参数列表。</p>
</li>
<li><p><code>constexpr</code> 函数的扩展：C++11 中，<code>constexpr</code> 函数只允许包含单个 return 语句。C++14 中允许 <code>constexpr</code> 函数中有多个 return 语句，也可以包含局部变量。</p>
</li>
<li><p>返回类型推导：C++14 允许使用 auto 来推导函数的返回类型，如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>字符串字面量的改进：C++14 支持 R”delim(…)delim” 的原始字符串字面量，其中 delim 可以是任何字符序列。这种类型的字符串字面量可以包含换行符和反斜杠字符。</p>
</li>
<li><p>二进制字面量：C++14 允许使用 0b 或 0B 前缀来表示二进制数字。</p>
</li>
<li><p>数组初始化的简化：C++14 允许在花括号中使用 “等号” 来表示“全部初始化为指定值”，如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 所有元素初始化为 0</span></span><br></pre></td></tr></table></figure></li>
<li><p>sizeof() 的变量模板：C++14 允许使用变量模板来获取对象的大小，如下所示：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">constexpr</span> std::<span class="type">size_t</span> size = <span class="built_in">sizeof</span>(T);</span><br></pre></td></tr></table></figure></li>
<li><p>常量表达式 if 语句：C++14 允许在常量表达式中使用 if 语句。</p>
</li>
<li><p>容器的 <code>emplace_back()</code> 函数的改进：C++14 允许使用可变参数模板来调用 <code>emplace_back()</code> 函数。</p>
</li>
<li><p>引入了 <code>std::make_unique</code> 创建 <code>unique_ptr </code> 对象，可以使用 <code>std::make_unique()</code> 函数来创建。</p>
</li>
</ol>
<h1 id="3-C-17-新特性"><a href="#3-C-17-新特性" class="headerlink" title="3. C++17 新特性"></a>3. C++17 新特性</h1><ol>
<li><p>结构化绑定（Structured Binding）：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot;&quot;</span> &lt;&lt; y &lt;&lt;<span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>if 语句中的初始化（if with initializer）：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="type">int</span> x = <span class="number">42</span>; x&gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure>
</li>
<li><p>折叠表达式（Fold Expressions）：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Args... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (args + ...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>
</li>
<li><p>constexpr if：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(is_same_v&lt;T, <span class="type">int</span>&gt;)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;int:&quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (is_same_v&lt;T, <span class="type">double</span>&gt;) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;double:&quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;unknown type&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">42</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">3.14</span>);</span><br><span class="line">    <span class="built_in">foo</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int: 42</span><br><span class="line">double: 3.14</span><br><span class="line">unknown <span class="built_in">type</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>结构化绑定与 tuple 的整合使用：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Point p&#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> [x, y] = <span class="built_in">tie</span>(p.x, p.y);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2</span><br></pre></td></tr></table></figure>
</li>
<li><p>[[nodiscard]] 属性：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">[[nodiscard]] <span class="function"><span class="type">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 编译时会提示：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">warning: ignoring return value of function declared with &#x27;nodiscard&#x27; attribute</span><br></pre></td></tr></table></figure>
</li>
<li><p>constexpr lambda：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> f = [] (<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * <span class="number">2</span>; &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> x = <span class="built_in">f</span>(<span class="number">3</span>);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>
</li>
<li><p>嵌套命名空间：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ns1 &#123;</span><br><span class="line">    <span class="keyword">namespace</span> ns2 &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; ns1::ns2::x &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出：</p>
 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">42</span><br></pre></td></tr></table></figure>
</li>
<li><p>if constexpr 中的变量声明：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="type">bool</span> b)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-C-20-新特性"><a href="#4-C-20-新特性" class="headerlink" title="4. C++20 新特性"></a>4. C++20 新特性</h1><h2 id="4-1-Coroutines"><a href="#4-1-Coroutines" class="headerlink" title="4.1. Coroutines"></a>4.1. Coroutines</h2><p>协程（Coroutines）是 C++20 引进的一种新技术。</p>
<h2 id="4-2-Concepts"><a href="#4-2-Concepts" class="headerlink" title="4.2. Concepts"></a>4.2. Concepts</h2><h2 id="4-3-Modules"><a href="#4-3-Modules" class="headerlink" title="4.3. Modules"></a>4.3. Modules</h2><h2 id="4-4-Ranges"><a href="#4-4-Ranges" class="headerlink" title="4.4. Ranges"></a>4.4. Ranges</h2><h1 id="5-References"><a href="#5-References" class="headerlink" title="5. References"></a>5. References</h1><ul>
<li>C++ standard: <a target="_blank" rel="noopener" href="https://isocpp.org/std/the-standard">https://isocpp.org/std/the-standard</a> <br><br>标准委员会官方站点，近期的会议、行程、活动、计划等等都会发布在这里。这里也会推荐一些比较好的文章、教程、书籍等等内容，供C++程序员阅读。</li>
<li>modern C++ 讲解：<a target="_blank" rel="noopener" href="http://www.modernescpp.com/index.php">http://www.modernescpp.com/index.php</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io">John Jeep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io/Cpp/Cpp/03-C++Standard/">https://johnjeep.github.io/Cpp/Cpp/03-C++Standard/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://johnjeep.github.io" target="_blank">Leaning Computer Science Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/03-C-Standard/">03-C++Standard</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Cpp/Cpp/02-C++Advanced/" title="02-C++Advanced"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">02-C++Advanced</div></div><div class="info-2"><div class="info-item-1">  1. Object Oriented Programming(面向对象编程)Object Oriented Programming(OOP)叫面向对象编程。  class without pointer members：类中的成员不带有指针。 class with pointer members：类中的成员带有指针。  1.1. Encapsulation(封装)封装这个术语用来描述在过程接口后面隐藏实现细节的概念。 C++ 中对类的设计时，封装了属性和方法。若直接访问类的数据成员就违反了封装原则。设计原则应保持数据成员的私有性。 访问限定符  public  修饰类的成员变量和函数，既能在 类的内部 使用又能在 类的外部 使用 private 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用 protect 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用，可以在 继承的子类 中使用。  C++ 中类与类之间的关系主要归为三大类：复合、委托、继承。 1.2....</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/04-STL/" title="04-STL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">04-STL</div></div><div class="info-2"><div class="info-item-1">  1. Thinking(思考) 使用它是一件很愉快的事。 使用一个东西，却不明白它的道理，不高明！—林语堂 源码之前了无秘密。 天下大事，必作于细。 高屋建瓴，细致入微。 所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。  STL学习境界：会用，明理，能扩展。  会用：熟练使用 STL 的各种 API 接口。 明理：明白 STL 设计的思想，各种 API 的底层实现原理。 能扩展：对 STL 添加自己实现的各种接口，扩充 STL 的功能。   目标 Level 0: 使用C++标准库 Level 1: 深入认识C++标准库(胸中自有丘壑) Level 2: 良好使用C++标准库 Level 3: 扩充C++标准库  源码版本：GNU 2.91, GNU 4.9  2. History(历史)C++创始人：比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup） STL创始人：Alexander Stepanov(亚历山大·斯蒂芬诺夫) GPL(General Public licence):...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Cpp/Cpp/01-C++Novice/" title="01-C++Novice"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">01-C++Novice</div></div><div class="info-2"><div class="info-item-1">  1. concept(概念)c++ 是一种倾向于系统编程的通用编程语言，在 C 语言的基础上发展起来的，支持的特性。  supports data abstraction supports object-oriented programming supports generic programming   Compile-Time (constexpr and template metaprogramming)  2. c++ basics(C++基础) C 语言中，表达式的返回值是一个数值。C++ 中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。  endl 与 \n 区别  endl：换行和清除缓冲区到输出屏幕上 \n：仅仅只是换行   float：有效数字是 6~7 位  double：有效数字是 15 位  char：8 个 bit，占一个字节（byte）空间  取模场景  取一个数的个位数 多少天是一个月的第几天   &lt;&lt; 左移运算符：右侧空位补 0  &gt;&gt; 右移运算符：左侧空位补符号位，符号位正数部...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/02-C++Advanced/" title="02-C++Advanced"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">02-C++Advanced</div></div><div class="info-2"><div class="info-item-1">  1. Object Oriented Programming(面向对象编程)Object Oriented Programming(OOP)叫面向对象编程。  class without pointer members：类中的成员不带有指针。 class with pointer members：类中的成员带有指针。  1.1. Encapsulation(封装)封装这个术语用来描述在过程接口后面隐藏实现细节的概念。 C++ 中对类的设计时，封装了属性和方法。若直接访问类的数据成员就违反了封装原则。设计原则应保持数据成员的私有性。 访问限定符  public  修饰类的成员变量和函数，既能在 类的内部 使用又能在 类的外部 使用 private 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用 protect 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用，可以在 继承的子类 中使用。  C++ 中类与类之间的关系主要归为三大类：复合、委托、继承。 1.2....</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/04-STL/" title="04-STL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">04-STL</div></div><div class="info-2"><div class="info-item-1">  1. Thinking(思考) 使用它是一件很愉快的事。 使用一个东西，却不明白它的道理，不高明！—林语堂 源码之前了无秘密。 天下大事，必作于细。 高屋建瓴，细致入微。 所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。  STL学习境界：会用，明理，能扩展。  会用：熟练使用 STL 的各种 API 接口。 明理：明白 STL 设计的思想，各种 API 的底层实现原理。 能扩展：对 STL 添加自己实现的各种接口，扩充 STL 的功能。   目标 Level 0: 使用C++标准库 Level 1: 深入认识C++标准库(胸中自有丘壑) Level 2: 良好使用C++标准库 Level 3: 扩充C++标准库  源码版本：GNU 2.91, GNU 4.9  2. History(历史)C++创始人：比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup） STL创始人：Alexander Stepanov(亚历山大·斯蒂芬诺夫) GPL(General Public licence):...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++MemoryManagement/" title="C++MemoryManagement"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++MemoryManagement</div></div><div class="info-2"><div class="info-item-1">  History(历史)Doug Lea自1986年开始研究malloc算法，他的作品被称为 DL Malloc，目前linux中的glibc的malloc算法就是直接来自Doug Lea，其它平台的malloc的实现或多或少受到DL的影响。 内存管理层级 OS（操作系统），Windows 系统的的 HeapAlloc 和 VirtualAlloc； GUNC++&#x2F;CRT 编译器的 malloc() C++ 标准库的 Allocator C++ 应用程序层面的内存 API 函数。  内存库作品 tcmalloc：稳定，占用内存更低。 jemalloc性能更高，占用内存更高  Bibliography(书目) STL源码剖析(侯捷) Small Memory Software(James Noble &amp; Charles Weir) Modern C++ Design General Programming and Design Patterns Applied(Andrei Alexandrescu)  Reference(参考) Doug Lea’s...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++Optimization/" title="C++Optimization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++Optimization</div></div><div class="info-2"><div class="info-item-1"> 开销来自哪里 函数之间的调用。用模板和内联函数去解决。  编写高效的 C++ 程序让编写的程序提高运行效率的方式：  高效的算法。 避免不必要计算和步骤。 选择恰当的优化设计策略。  References Software optimization resources 《Optimized C++》Kurt Guntheroth 大师编写的 C++ 优化书籍。 《Effective STL》 《Effective C++》 《Effective Modern C++》  </div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++SoftDesign/" title="C++SoftDesign"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++SoftDesign</div></div><div class="info-2"><div class="info-item-1">  1. C++ 软件设计1.1. 简单就是最好的 —&gt; 大道至简。API 是软件组件的接口，隐藏了实现这个接口所需的内部细节。 API 必须拥有良好的设计、文档、回归测试、并且保证发布之间的稳定性。 1.2. 重用哲学设计自己和其它程序员可以重复使用的代码。重用设计的准则：  编写一次，经常使用。 尽量避免代码重复。 不要重复写在自己写过的代码（Don’t repeat yourself）。  为什么要重用设计代码？  重用设计可以节约金钱和时间。 缺乏重用性会导致代码重复。  1.3. 如何设计可重用代码对于设计可重用代码而言，最重要的策略是抽象。设计代码时，需要考虑将    接口和实现进行分离，使代码更容易使用，程序员使用时不需要理解其内部实现细节。 ​ 抽象将代码分为接口和实现，因此设计可重用代码会关注这两个领域。代码实现时思考：如何做到恰到好处的设计代码结构？考虑使用什么样的类层次结构？需要使用模板吗？如何将代码切分割为子系统？设计接口时思考：设计分接口是库还是代码的“入口“，程序员使用这个接口时，应该给提供什么样的功能。 1.4....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Jeep</div><div class="author-info-description">lifestyle is lazy, faster, thinking</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JohnJeep/Learning-CS-Journey"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xxxxx@gmail.com" target="_blank" title="Gmail"><i class="fa-solid fa-bell" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-C-11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">1. C++11 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Template-of-Space"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Template of  Space</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Initializer-lists"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. Initializer lists</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-nullptr"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. nullptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-range-based-for-statement"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. range based for statement</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Lambda"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. Lambda</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-decltype"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. decltype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-explicit"><span class="toc-number">1.7.</span> <span class="toc-text">1.7. explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-auto"><span class="toc-number">1.8.</span> <span class="toc-text">1.8. auto</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-noexcept"><span class="toc-number">1.9.</span> <span class="toc-text">1.9. noexcept</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-constexpr"><span class="toc-number">1.10.</span> <span class="toc-text">1.10. constexpr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-override"><span class="toc-number">1.11.</span> <span class="toc-text">1.11. override</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-final"><span class="toc-number">1.12.</span> <span class="toc-text">1.12. final</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-New-Function-Declaration-Syntax"><span class="toc-number">1.13.</span> <span class="toc-text">1.13. New Function Declaration Syntax</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-Scoped-Enumerations"><span class="toc-number">1.14.</span> <span class="toc-text">1.14. Scoped Enumerations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-New-Template-Features"><span class="toc-number">1.15.</span> <span class="toc-text">1.15. New Template Features</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-1-variadic-templates"><span class="toc-number">1.15.1.</span> <span class="toc-text">1.15.1. variadic templates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-2-Alias-Templates-Template-Typedef"><span class="toc-number">1.15.2.</span> <span class="toc-text">1.15.2. Alias Templates (Template Typedef)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-3-Type-Alias"><span class="toc-number">1.15.3.</span> <span class="toc-text">1.15.3. Type Alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-4-Function-template"><span class="toc-number">1.15.4.</span> <span class="toc-text">1.15.4. Function template</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-using"><span class="toc-number">1.16.</span> <span class="toc-text">1.16. using</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-17-Move-Semantics-and-Rvalue-References"><span class="toc-number">1.17.</span> <span class="toc-text">1.17. Move Semantics and Rvalue References</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-18-delete-default"><span class="toc-number">1.18.</span> <span class="toc-text">1.18. &#x3D;delete &amp;&amp; &#x3D;default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-19-Chrono"><span class="toc-number">1.19.</span> <span class="toc-text">1.19. Chrono</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-1-duration"><span class="toc-number">1.19.1.</span> <span class="toc-text">1.19.1. duration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-19-2-timepoint-and-clock"><span class="toc-number">1.19.2.</span> <span class="toc-text">1.19.2. timepoint and clock</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-C-14-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">2. C++14 新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-C-17-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">3. C++17 新特性</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-C-20-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.</span> <span class="toc-text">4. C++20 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Coroutines"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. Coroutines</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Concepts"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. Concepts</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Modules"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. Modules</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Ranges"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. Ranges</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-References"><span class="toc-number">5.</span> <span class="toc-text">5. References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/CONVENTION/" title="CONVENTION">CONVENTION</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/README/" title="README">README</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/STARCHARTS/" title="STARCHARTS">STARCHARTS</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/AIGC/" title="AIGC">AIGC</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/ollama/" title="ollama">ollama</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Jeep</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>