<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>04-STL | Leaning Computer Science Journey</title><meta name="author" content="John Jeep"><meta name="copyright" content="John Jeep"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Thinking(思考) 使用它是一件很愉快的事。 使用一个东西，却不明白它的道理，不高明！—林语堂 源码之前了无秘密。 天下大事，必作于细。 高屋建瓴，细致入微。 所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。  STL学习境界：会用，明理，能扩展。  会用：熟练使用 STL 的各种 API 接口。 明理：明白 STL 设计的思想，各种 API 的底层实">
<meta property="og:type" content="article">
<meta property="og:title" content="04-STL">
<meta property="og:url" content="https://johnjeep.github.io/Cpp/Cpp/04-STL/index.html">
<meta property="og:site_name" content="Leaning Computer Science Journey">
<meta property="og:description" content="1. Thinking(思考) 使用它是一件很愉快的事。 使用一个东西，却不明白它的道理，不高明！—林语堂 源码之前了无秘密。 天下大事，必作于细。 高屋建瓴，细致入微。 所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。  STL学习境界：会用，明理，能扩展。  会用：熟练使用 STL 的各种 API 接口。 明理：明白 STL 设计的思想，各种 API 的底层实">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://johnjeep.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-04T12:24:00.000Z">
<meta property="article:modified_time" content="2025-04-04T12:24:27.265Z">
<meta property="article:author" content="John Jeep">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="04-STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://johnjeep.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "04-STL",
  "url": "https://johnjeep.github.io/Cpp/Cpp/04-STL/",
  "image": "https://johnjeep.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-04T12:24:00.000Z",
  "dateModified": "2025-04-04T12:24:27.265Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Jeep",
      "url": "https://johnjeep.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://johnjeep.github.io/Cpp/Cpp/04-STL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Jeep","link":"链接: ","source":"来源: Leaning Computer Science Journey","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '04-STL',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">04-STL</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">04-STL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T12:24:27.265Z" title="更新于 2025-04-04 20:24:27">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!--
 * @Author: JohnJeep
 * @Date: 2021-01-10 18:25:09
 * @LastEditTime: 2025-04-04 19:25:09
 * @Description: 剖析C++标准库
-->

<h1 id="1-Thinking-思考"><a href="#1-Thinking-思考" class="headerlink" title="1. Thinking(思考)"></a>1. Thinking(思考)</h1><hr>
<p>使用它是一件很愉快的事。</p>
<p>使用一个东西，却不明白它的道理，不高明！—林语堂</p>
<p>源码之前了无秘密。</p>
<p>天下大事，必作于细。</p>
<p>高屋建瓴，细致入微。</p>
<p>所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。</p>
<hr>
<p>STL学习境界：会用，明理，能扩展。</p>
<ul>
<li>会用：熟练使用 STL 的各种 API 接口。</li>
<li>明理：明白 STL 设计的思想，各种 API 的底层实现原理。</li>
<li>能扩展：对 STL 添加自己实现的各种接口，扩充 STL 的功能。</li>
</ul>
<hr>
<p>目标</p>
<p>Level 0: 使用C++标准库</p>
<p>Level 1: 深入认识C++标准库(胸中自有丘壑)</p>
<p>Level 2: 良好使用C++标准库</p>
<p>Level 3: 扩充C++标准库</p>
<hr>
<p>源码版本：GNU 2.91, GNU 4.9</p>
<hr>
<h1 id="2-History-历史"><a href="#2-History-历史" class="headerlink" title="2. History(历史)"></a>2. History(历史)</h1><p>C++创始人：比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup）</p>
<p>STL创始人：Alexander Stepanov(亚历山大·斯蒂芬诺夫)</p>
<p>GPL(General Public licence): 广泛开放授权。使用者可以自由阅读与修改GPL软件的源代码，但如果使用者要传播借助GPL软件而完成的软件，他们必须也同意GPL规范。这种精神主要是强迫人们分享并回馈他们对GPL软件的改善。得之于人，舍于人。</p>
<h1 id="3-STL-Standard-Template-Library-标准模板库"><a href="#3-STL-Standard-Template-Library-标准模板库" class="headerlink" title="3. STL(Standard Template Library)标准模板库"></a>3. STL(Standard Template Library)标准模板库</h1><p>Generic Programming(泛型编程): 操作(operations)使用相同的接口，但是其类型(type)不相同，即使用模板(template)将泛型操作公式化。其中STL是泛型编程(GP)最成功的一个作品。</p>
<ul>
<li><p>STL所实现的是依据泛型思维架设起来的概念结构。STL的核心思想：算法和数据结构的实现是分离的。</p>
</li>
<li><p>STL六大部件</p>
<ul>
<li>算法 (Algorithm)</li>
<li>容器 (Container）</li>
<li>迭代器 (Iterator)</li>
<li>仿函数 (Functor)</li>
<li>适配器 (Adaptor)</li>
<li>分配器 (Alloctor)</li>
</ul>
</li>
</ul>
<p>从语言实现的层面分析，Algorithm 采用 function template 实现的，而 Container、Iterator、Functor、Adaptor、Alloctor 都是采用 class template 实现的。</p>
<ul>
<li><p><strong>六大部件之间的关系</strong></p>
<ul>
<li><p>Container 通过 Allocator 取得数据存储的空间；</p>
</li>
<li><p>Algorithm 通过 Iterator 访问 Container 中的内容，Container 与 Algorithm 之间不能直接访问，需要借助 iterator，可以把 Iterator 看做是算法与容器之间沟通的桥梁；</p>
</li>
<li><p>Functor 协助 Algorithm 完成不同的策略变化；</p>
</li>
<li><p>Adaptor 修饰或套接 Functor；</p>
<img src="./figures/stl-component.png"></li>
</ul>
</li>
</ul>
<p>使用六大部件的例子</p>
<img src="./figures/stl-component-example.png">

<p>常用的容器</p>
<ul>
<li>Vector(向量)</li>
<li>Deque(双队列)</li>
<li>List(链表)</li>
<li>Map&#x2F;Multimap(映射&#x2F;多重映射)</li>
<li>Set&#x2F;Multiset(集合&#x2F;多重集合)</li>
</ul>
<img src="./figures/container-library.png">

<h1 id="4-Container-容器"><a href="#4-Container-容器" class="headerlink" title="4. Container(容器)"></a>4. Container(容器)</h1><p>容器是一个一个的类模板 (class template)，里面放的是元素。</p>
<p>STL标准库中 <strong>容器</strong>** 内存储的元素都必须能够拷贝，而 C++ 编译器默认提供的是浅拷贝，程序在执行时，则会出现问题。因此需要 <strong>重写构造函数</strong> 和重载 <strong>&#x3D;</strong> 操作运算符，执行深拷贝。</p>
<h2 id="4-1-Sequence-containers-有序容器"><a href="#4-1-Sequence-containers-有序容器" class="headerlink" title="4.1. Sequence containers(有序容器)"></a>4.1. Sequence containers(有序容器)</h2><h3 id="4-1-1-Array-数组"><a href="#4-1-1-Array-数组" class="headerlink" title="4.1.1. Array(数组)"></a>4.1.1. Array(数组)</h3><p>Array 是 C++11 标准之后新增的一个容器，表示固定数量的元素(fixed number of elements)。为了模拟数组的相关特性。</p>
<p>其内部结构如下图所示</p>
<img src="./figures/container-arrays.png">

<p>Array会把元素复制到其内部的 static C-style array中。这些元素总是拥有一个明确次序。因此 array 是一种有序(ordered)集合。Array允许随机访问，也就是你可以在常量时间内直接访问任何元素，前提是你知道元素位置。Array的迭代器属于随机访问（random-access)迭代器，所以你可以对它运用任何 STL 算法。</p>
<p>如果你需要一个有固定元素量的序列，<code>classarray&lt;&gt;</code> 将带来最效能，因为内存被分配下stack中（如果可能的话），绝不会被重分配(reallocation)，而且你拥有随机访问能力。</p>
<p><strong>注意点：</strong>STL 源码中实现，没有构造和析构函数。</p>
<h4 id="4-1-1-1-优点"><a href="#4-1-1-1-优点" class="headerlink" title="4.1.1.1. 优点"></a>4.1.1.1. 优点</h4><p>支持 <code>[]</code> 和 <code>at()</code> 操作。<code>at()</code> 函数带范围检查，超出范围，就会抛出 <code>range-error</code>异常；而 <code>[]</code> 操作是不做范围检查的。 </p>
<h4 id="4-1-1-2-缺点"><a href="#4-1-1-2-缺点" class="headerlink" title="4.1.1.2. 缺点"></a>4.1.1.2. 缺点</h4><ul>
<li>不能扩容。</li>
<li>Array 不允许你指定分配器(Allocator)。</li>
</ul>
<h4 id="4-1-1-3-源码分析"><a href="#4-1-1-3-源码分析" class="headerlink" title="4.1.1.3. 源码分析"></a>4.1.1.3. 源码分析</h4><img src="./figures/array.png">

<h3 id="4-1-2-vector-单端的动态数组"><a href="#4-1-2-vector-单端的动态数组" class="headerlink" title="4.1.2. vector(单端的动态数组)"></a>4.1.2. vector(单端的动态数组)</h3><p>vector 是 C++ 标准模板库中的部分内容，它是一个多功能的，能够操作多种数据结构和算法的模板类和函数库。vector 之所以被认为是一个容器，是因为它能够像容器一样存放各种类型的对象，简单地说 vector 是一个能够存放任意类型的动态数组，能够增加和压缩数据。</p>
<p>动态数组实现机制：</p>
<blockquote>
<p>先为数组开辟较小的空间，然后往数组里面添加数据，当数组中元素的数量超过数组的容量时，重新分配一块更大的空间（STL 中 <code>vector</code> 每次扩容时，新的容量都是前一次的两倍），再把之前的数据复制到新的数组中，再把之前的内存释放。</p>
</blockquote>
<p>发生内存的重分配（realloc）操作通常有 4 个步骤</p>
<ol>
<li>分配一个新的内存块，它是容器当前容量的一些倍数，常常为 2 倍。</li>
<li>将容器旧内存中的所有元素复制到新内存中。</li>
<li>销毁旧内存中的对象（object）。</li>
<li>销毁（Deallocate）旧内存。</li>
</ol>
<p><font color=red> 注意：</font></p>
<ul>
<li>使用动态数组时，尽量减少改变数组容量大小的次数，可以减少时间性能的消耗。 一般每次扩容为原来的  2 倍。</li>
<li>当 vector 扩容时，会调用 <code>move constructor</code> 和 <code>move destructor</code>，并且移动构造和移动析构函数在执行期间不会抛出异常，是用 <code>noexcept</code> 关键字修饰。因为它不能确保异常发生后，移动构造和移动析构函数还能满足标准库的要求，所以是禁止抛异常的。</li>
<li><font color=red> 标准库中成长型的容器（需要发生 memory reallocation）有：<code>vector</code> 、<code>deque</code>、<code>string</code>。</font></li>
</ul>
<p>内部结构图</p>
<img src="./figures/container-vectors.png">



<h4 id="4-1-2-1-API接口"><a href="#4-1-2-1-API接口" class="headerlink" title="4.1.2.1. API接口"></a>4.1.2.1. API接口</h4><ul>
<li><code>size()</code>: 返回容器中元素的个数</li>
<li><code>get(r)</code>: 获取索引为 r 的元素</li>
<li><code>put(r, e)</code>: 用 e 替换索引为 r 元素的数值</li>
<li><code>insert(r, e)</code>: 向索引为 r 的元素处插入数值 e，后面元素依次后移</li>
<li><code>remove(r)</code>: 移除索引为 r 的元素，返回全元素中原存放的对象</li>
<li><code>disordered()</code>: 判断所有元素是否已按升序序排列</li>
<li><code>sort()</code>: 调整各元素癿位置，使按照升序序排列</li>
<li><code>deduplicate()</code>: 删除重复元素   —向量</li>
<li><code>uniquify()</code>: 删除重复元素 —有序向量</li>
<li><code>traverse()</code>: 遍历向量幵统一处理所有元素，处理斱法由函数对象指定</li>
<li><code>empty()</code>: 判断容器是否为空</li>
<li><code>at(index)</code>: 返回索引为 index 的元素</li>
<li><code>erase(p)</code>: 删除指针p指向位置的数据，返回下指向下一个数据位置的指针（迭代器）</li>
<li><code>erase(beg, end)</code>:删除区间<code>[beg, end)</code>的数据</li>
<li><code>pop_back()</code>: 删除最后一个元素</li>
<li><code>push_back()</code>: 在容器末尾插入一个元素</li>
<li><code>back()</code>: 获取尾部元素</li>
<li><code>front()</code>: 获取首部元素</li>
<li><code>begin(), end()</code>: 返回容器首尾元素的迭代器</li>
<li><code>clear()</code>: 移除容器中所有的元素</li>
<li><code>swap()</code>: 交换两个容器的内容，交换两个 vector 的内容后，两者的容量也交换了，<strong>这是一个间接缩短 vector的小窍门。</strong></li>
<li><code>shrink_to_fit()</code>: 缩短 vector 的大小到合适的空间，为实现特定的优化保留了回旋的余地。</li>
<li><code>resize(size_t n)</code>: 强制容器将其容纳的元素数更改为 n。<ul>
<li>若 n 小于当前容器的 size，原容器里超过 n 后面的值被销毁。</li>
<li>若 n 大于当前容器的 size，容器里超过 size 后面的内容，编译器将默认构造函数中的数据写入到容器里面。</li>
<li>若 n 大于当前容器的 capacity ，向容器中增加元素之前会发生 <code>reallocation</code>。</li>
</ul>
</li>
<li><code>reserve(size_t n)</code>: 强制将容器的容量重新设置为 n。<ul>
<li>若 n 大于当前容器的 capacity，发生 <code>reallocation</code>。</li>
<li>若 n 小于当前容器的 capacity，<code>vector</code> 忽略调用，什么也不会做；string 会将其容量减少到 <code>size ()</code>和 n 的最大值，但 string 的大小（size）肯定保持不变。</li>
</ul>
</li>
</ul>
<h4 id="4-1-2-2-优点"><a href="#4-1-2-2-优点" class="headerlink" title="4.1.2.2. 优点"></a>4.1.2.2. 优点</h4><ul>
<li>不指定一块内存大小的数组的连续存储，即可以像数组一样操作，但可以对此数组进行动态操作，运行阶段执行。</li>
<li>随机访问快，支持随机迭代访问器。即支持 <code>[]</code> 操作符和 <code>at()</code>操作。</li>
<li>节省空间。</li>
</ul>
<h4 id="4-1-2-3-缺点"><a href="#4-1-2-3-缺点" class="headerlink" title="4.1.2.3. 缺点"></a>4.1.2.3. 缺点</h4><ul>
<li>向容器中插入元素时，内部的元素必须能够执行 <code>拷贝（必须提供拷贝构造）</code> 操作。</li>
<li>在内部进行插入删除操作效率低。</li>
<li>只能在vector的最后进行push和pop，不能在vector的头进行push和pop。</li>
<li>当动态添加的数据超过vector默认分配的大小时要进行整体的重新分配、拷贝与释放。</li>
</ul>
<h4 id="4-1-2-4-源码分析"><a href="#4-1-2-4-源码分析" class="headerlink" title="4.1.2.4. 源码分析"></a>4.1.2.4. 源码分析</h4><p>GNU 2.9版源码UML图</p>
<img src="./figures/vector-2.9.png">

<p>GNU 4.9版源码UML图</p>
<img src="./figures/vector-4.9.png">

<p><strong>Vector类与其基类之间的关系</strong></p>
<img src="./figures/UMLClassDiagram-_Vector_base.png">

<p><strong>Vector_base内部类与其它类之间的关系</strong></p>
<img src="./figures/UMLClassDiagram-_Vector_impl.png">

<p><strong>迭代器之间的关系</strong></p>
<img src="./figures/UMLClassDiagram-reverse_iterator.png">

<h3 id="4-1-3-deque-双端数组"><a href="#4-1-3-deque-双端数组" class="headerlink" title="4.1.3. deque(双端数组)"></a>4.1.3. deque(双端数组)</h3><p>deque 是在功能上合并了 vector 和 list。与 <code>vector</code> 容器类似，但是可以在 <code>Deque</code> 的两端进行操作。</p>
<p>deque 的内部结构图如下</p>
<img src="./figures/container-deques.png">

<img src="./figures/container-deques-internal-structure.png">

<img src="./figures/deque.png">

<h4 id="4-1-3-1-API接口"><a href="#4-1-3-1-API接口" class="headerlink" title="4.1.3.1. API接口"></a>4.1.3.1. API接口</h4><ul>
<li><code>push_back()</code>: 在容器末尾插入一个元素</li>
<li><code>push_front()</code> 容器头部插入一个元素</li>
<li><code>pop_front()</code>: 容器头部删除一个元素</li>
<li><code>pop_back()</code>: 删除最后一个元素</li>
</ul>
<h4 id="4-1-3-2-优点"><a href="#4-1-3-2-优点" class="headerlink" title="4.1.3.2. 优点"></a>4.1.3.2. 优点</h4><ul>
<li>支持随机访问，即支持 <code>[]</code>操作符和 <code>at()</code>。</li>
<li>在内部方便的进行插入和删除操作。</li>
<li>可在两端进行 push、pop。</li>
</ul>
<h4 id="4-1-3-3-缺点"><a href="#4-1-3-3-缺点" class="headerlink" title="4.1.3.3. 缺点"></a>4.1.3.3. 缺点</h4><ul>
<li>每次扩容的大小为一个 buffer。</li>
<li>占用内存多，采用多个内存区块来存储元素。</li>
</ul>
<h3 id="4-1-4-list-双向链表"><a href="#4-1-4-list-双向链表" class="headerlink" title="4.1.4. list(双向链表)"></a>4.1.4. list(双向链表)</h3><p>list是一个双向链表的容器，可以高效的进行 <strong>插入</strong> 和 <strong>删除</strong> 元素。每一个结点都包括一个信息快 Info、一个前驱指针 Pre、一个后驱指针 Post。可以不分配固定的内存大小，方便的进行添加和删除操作，使用的是非连续的内存空间进行存储。</p>
<h4 id="4-1-4-1-list-insert"><a href="#4-1-4-1-list-insert" class="headerlink" title="4.1.4.1. list insert"></a>4.1.4.1. list insert</h4><p>链表的插入操作：在 pos 位置插入新的节点，新插入的数据存放在 pos 位置之前。</p>
<h4 id="4-1-4-2-list-delete"><a href="#4-1-4-2-list-delete" class="headerlink" title="4.1.4.2. list delete"></a>4.1.4.2. list delete</h4><ul>
<li><code>clear()</code> 移除容器中所有的数据</li>
<li><code>erase(begin, end)</code> 删除区间 <code>[begin, end)</code> 的数据，返回下一个元素的位置。</li>
<li><code>erase(pos)</code> 删除指定 pos 位置的数据，返回下一个元素的位置。</li>
<li><code>remove(element)</code> 删除容器中所有与 element 值匹配的数据。</li>
</ul>
<h4 id="4-1-4-3-内部结构图"><a href="#4-1-4-3-内部结构图" class="headerlink" title="4.1.4.3. 内部结构图"></a>4.1.4.3. 内部结构图</h4><img src="./figures/container-lists.png">

<img src= "./figures/container-lists-internal-structure.png">

<h4 id="4-1-4-4-优点"><a href="#4-1-4-4-优点" class="headerlink" title="4.1.4.4. 优点"></a>4.1.4.4. 优点</h4><ul>
<li>不使用连续内存完成动态操作。</li>
<li>在内部方便的进行插入和删除操作</li>
<li>可在两端进行push、pop</li>
</ul>
<h4 id="4-1-4-5-缺点"><a href="#4-1-4-5-缺点" class="headerlink" title="4.1.4.5. 缺点"></a>4.1.4.5. 缺点</h4><ul>
<li>每次只能扩充一个结点，效率低，但空间浪费是最小的。</li>
<li>不能进行内部的随机访问，即不支持 <code>at.(pos)</code> 函数和 <code>[]</code> 操作符。</li>
<li>相对于verctor占用内存多。</li>
</ul>
<h4 id="4-1-4-6-API接口"><a href="#4-1-4-6-API接口" class="headerlink" title="4.1.4.6. API接口"></a>4.1.4.6. API接口</h4><h4 id="4-1-4-7-源码分析"><a href="#4-1-4-7-源码分析" class="headerlink" title="4.1.4.7. 源码分析"></a>4.1.4.7. 源码分析</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    _Self&amp;</span><br><span class="line">    <span class="keyword">operator</span>++() _GLIBCXX_NOEXCEPT      <span class="comment">// 前置++</span></span><br><span class="line">    &#123;</span><br><span class="line">_M_node = _M_node-&gt;_M_next;             <span class="comment">// 移动结点</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _Self</span><br><span class="line">    <span class="keyword">operator</span>++(<span class="type">int</span>) _GLIBCXX_NOEXCEPT   <span class="comment">// 后置++</span></span><br><span class="line">    &#123;</span><br><span class="line">_Self __tmp = *<span class="keyword">this</span>;                    <span class="comment">// 记录原值</span></span><br><span class="line">_M_node = _M_node-&gt;_M_next;             <span class="comment">// 执行操作</span></span><br><span class="line"><span class="keyword">return</span> __tmp;                           <span class="comment">// 返回原值，执行的是拷贝构造</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>通过两者传入的参数值不同来区分是前置++还是后置++。</p>
<p><strong><code>_M_node = _M_node-&gt;_M_next;</code> 这一行为++操作的具体实现过程：</strong></p>
<blockquote>
<p>移动结点。过程：将当前结点next域的值取出来赋给_M_node，而_M_node本身指向当前的结点，_M_node-&gt;_M_next 指到下一个结点的prev域。此时_M_node 与_M_node-&gt;_M_next指向的内容是一样的，所以把_M_node移动到 _M_node-&gt;_M_next 指向的位置，这一过程就是结点的++操作。</p>
</blockquote>
<img src="./figures/node++.png">

<p><strong>思考：为什么前置++与后置++两者的返回值是不一样的？</strong></p>
<blockquote>
<p>为了与整数的 ++ 操作保持一致，操作运算符重载持有的操作应该向整数的操作看起，拥有类似的功，保证不能进行两次的 ++ 运算操作。</p>
</blockquote>
<img src="./figures/self.png">

<p>源码中list的UML图分析</p>
<img src="./figures/UMLClassDiagram-_List_base.png">

<img src="./figures/UMLClassDiagram-_List_node_base.png">

<h3 id="4-1-5-forword-list-单向链表"><a href="#4-1-5-forword-list-单向链表" class="headerlink" title="4.1.5. forword list(单向链表)"></a>4.1.5. forword list(单向链表)</h3><p><code>forword list</code> 链表是 C++11 新加的功能，比 <code>list</code> 的效率要快，是单向的链表。</p>
<p>使用 <code>forword_list</code>，必须添加头文件 <code>#include &lt;forword_list&gt;</code>。头文件中 forward list 是命名空间 std 内的 <code>class template</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,</span><br><span class="line">              <span class="keyword">typename</span> Allocator = allocator&lt;T&gt; &gt;</span><br><span class="line">    <span class="keyword">class</span> forward_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-5-1-内部结构图"><a href="#4-1-5-1-内部结构图" class="headerlink" title="4.1.5.1. 内部结构图"></a>4.1.5.1. 内部结构图</h4><img src="./figures/container-forward-lists.png">

<h4 id="4-1-5-2-API-接口"><a href="#4-1-5-2-API-接口" class="headerlink" title="4.1.5.2. API 接口"></a>4.1.5.2. API 接口</h4><ul>
<li><code>insert()</code></li>
<li><code>front()</code> 返回容器中的第一个元素，但并不检查是否存在第一元素。</li>
</ul>
<h4 id="4-1-5-3-优缺点"><a href="#4-1-5-3-优缺点" class="headerlink" title="4.1.5.3. 优缺点"></a>4.1.5.3. 优缺点</h4><ol>
<li>优点<ul>
<li>内存占用量比 list 少，运行速度（runtime）略快。</li>
</ul>
</li>
<li>缺点<ul>
<li>扩容是时，只能扩充一个结点。</li>
</ul>
</li>
</ol>
<h4 id="4-1-5-4-注意点"><a href="#4-1-5-4-注意点" class="headerlink" title="4.1.5.4. 注意点"></a>4.1.5.4. 注意点</h4><p>forword list 不提供 <code>size()</code>操作。原因是不可能在固定的时间内存储或计算当前元素的数量。同时也反应出 <code>size()</code> 是一个费时间的操作。若必须要计算元素的个数，可用 <code>distance()</code> 函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$include &lt;iostream&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::forward_list&lt;<span class="type">int</span>&gt; l;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;l.size(): &quot;</span> &lt;&lt; std::<span class="built_in">distance</span>(l.<span class="built_in">begin</span>(),l.<span class="built_in">end</span>())</span><br><span class="line">    &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="4-1-5-5-源码分析"><a href="#4-1-5-5-源码分析" class="headerlink" title="4.1.5.5. 源码分析"></a>4.1.5.5. 源码分析</h4><img src="./figures/forward-list.png">

<h2 id="4-2-Associative-containers-关联性容器"><a href="#4-2-Associative-containers-关联性容器" class="headerlink" title="4.2. Associative containers(关联性容器)"></a>4.2. Associative containers(关联性容器)</h2><p>关联式容器并不提供元素的直接访问，需要依靠迭代器访问。map 是个例外，提供了subscript(下标)操作符，支持元素的直接访问。</p>
<h3 id="4-2-1-set"><a href="#4-2-1-set" class="headerlink" title="4.2.1. set"></a>4.2.1. set</h3><p>set 是一个 <code>集合</code> 容器，包含的元素是唯一的，集合中的元素按照一定的顺序排列，不能随意指定位置插入元素。</p>
<h4 id="4-2-1-1-内部结构图"><a href="#4-2-1-1-内部结构图" class="headerlink" title="4.2.1.1. 内部结构图"></a>4.2.1.1. 内部结构图</h4><img src="figures/set-multiset.png">

<img src="figures/set-multiset-internal-structure.png">

<h4 id="4-2-1-2-API-接口"><a href="#4-2-1-2-API-接口" class="headerlink" title="4.2.1.2. API 接口"></a>4.2.1.2. API 接口</h4><ul>
<li><p><code>insert()</code> 函数的返回值类型为 <code>pair&lt;iterator, bool&gt;</code>，结果是一对数据类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; 存放两个不同类型的数值</span><br></pre></td></tr></table></figure>
</li>
<li><p>set 查找接口</p>
<ul>
<li><code>find()</code> 返回查找元素的迭代器，查找的元素默认是区分大小写的。</li>
<li><code>count()</code> 返回容器中查找元素的个数</li>
<li><code>upper_bound</code> 返回容器中大于查找元素的迭代器位置</li>
<li><code>lower_bound</code> 返回容器中小于查找元素的迭代器位置</li>
<li><code>equal_range(ele)</code>返回容器中等于查找元素的两个上下限的迭代器位置（第一个：大于等于ele元素的位置，第二个：大于 ele元素的位置）</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-3-优点"><a href="#4-2-1-3-优点" class="headerlink" title="4.2.1.3. 优点"></a>4.2.1.3. 优点</h4><h4 id="4-2-1-4-缺点"><a href="#4-2-1-4-缺点" class="headerlink" title="4.2.1.4. 缺点"></a>4.2.1.4. 缺点</h4><h3 id="4-2-2-multiset"><a href="#4-2-2-multiset" class="headerlink" title="4.2.2. multiset"></a>4.2.2. multiset</h3><p>multiset 也是一个容器集合，但它支持容器中的 key 可以重复。</p>
<h3 id="4-2-3-set-与-multiset-对比"><a href="#4-2-3-set-与-multiset-对比" class="headerlink" title="4.2.3. set 与 multiset 对比"></a>4.2.3. set 与 multiset 对比</h3><ul>
<li>set 与 multiset 底层都是采用红黑树的数据结构实现的。</li>
<li>set 支持唯一的键值，容器里面的元素值只能出现一次，而 <code>multiset</code> 集合容器中同一个元素值可以出现多次。</li>
<li>不可以直接修改 set 和 multiset 集合容器中元素的值，因为集合容器是自动排序的。修改集合容器中元素的值，必须先删除原先元素的值，再插入新元素的值。</li>
</ul>
<h3 id="4-2-4-map"><a href="#4-2-4-map" class="headerlink" title="4.2.4. map"></a>4.2.4. map</h3><p>map 是关联式容器，一个 map 就是一个键值对。map 中的 <code>key</code> 值唯一，容器中的元素按照一定的顺序排列，不能在任意指定的位置插入元素。</p>
<h4 id="4-2-4-1-map与multimap内部结构图"><a href="#4-2-4-1-map与multimap内部结构图" class="headerlink" title="4.2.4.1. map与multimap内部结构图"></a>4.2.4.1. map与multimap内部结构图</h4><img src="./figures/map-multimap.png">

<img src="./figures/map-multimap-internal-structure.png">

<h4 id="4-2-4-2-map-insert"><a href="#4-2-4-2-map-insert" class="headerlink" title="4.2.4.2. map insert"></a>4.2.4.2. map insert</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 四种map容器的插入方法</span></span><br><span class="line">map&lt;<span class="type">int</span>, string&gt; mp;</span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">101</span>, <span class="string">&quot;赵云&quot;</span>));                   <span class="comment">// 法一</span></span><br><span class="line">mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">102</span>, <span class="string">&quot;关羽&quot;</span>));              <span class="comment">// 法二</span></span><br><span class="line">mp.<span class="built_in">insert</span>(map&lt;<span class="type">int</span>, string&gt;::<span class="built_in">value_type</span>(<span class="number">103</span>, <span class="string">&quot;曹操&quot;</span>));        <span class="comment">// 法三</span></span><br><span class="line">mp[<span class="number">104</span>] = <span class="string">&quot;张飞&quot;</span>;                                            <span class="comment">// 法四</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法一到方法三向容器中插入相同的键值时，不会插入成功。</span></span><br><span class="line"><span class="comment">// 采用法四向容器中插入相同的键值时，会覆盖原先相同键值的数据。</span></span><br></pre></td></tr></table></figure>

<p><font color=red>注意:</font> </p>
<ul>
<li>map的查找操作需要做异常判断处理</li>
<li>key 与 value 两个值必须是可拷贝的(copyable)和可移动的(movable)。</li>
<li>指定的排序准则下，key 必须是可比较的(comparable)。</li>
</ul>
<h4 id="4-2-4-3-at"><a href="#4-2-4-3-at" class="headerlink" title="4.2.4.3. at() &amp;&amp; []"></a>4.2.4.3. at() &amp;&amp; []</h4><ul>
<li><code>at()</code> 函数会根据它收到的 <code>key</code> 得到元素的 <code>value</code>，如果不存在这样的元素，则抛出 <code>out_of_range</code> 异常。</li>
<li><code>operator []</code><ul>
<li><code>operator []</code> 的索引就是 <code>key</code>，其类型可能属于任何的类型，不一定是整数。</li>
<li>如果你选择某 <code>key</code> 作为索引，容器内没有相应的元素，那么 map 会自动安插一个新元素，其 value 将被其类型的 default 构造函数初始化。因此你不可以指定一个 <code>不具 default 构造函数的 value 类型</code>。一般基础类型都有一个 <code>default 构造函数</code>，设初值为 <code>0</code>。</li>
</ul>
</li>
</ul>
<h4 id="4-2-4-4-优点"><a href="#4-2-4-4-优点" class="headerlink" title="4.2.4.4. 优点"></a>4.2.4.4. 优点</h4><p>插入键值的元素不允许重复，只对元素的键值进行比较，元素的各项数据可以通过 key 值进行检索。 </p>
<h4 id="4-2-4-5-缺点"><a href="#4-2-4-5-缺点" class="headerlink" title="4.2.4.5. 缺点"></a>4.2.4.5. 缺点</h4><h3 id="4-2-5-mutimap"><a href="#4-2-5-mutimap" class="headerlink" title="4.2.5. mutimap"></a>4.2.5. mutimap</h3><p>multimap (collection of key-value pairs, sorted by keys.)</p>
<h3 id="4-2-6-map-与-multimap-对比"><a href="#4-2-6-map-与-multimap-对比" class="headerlink" title="4.2.6. map 与 multimap 对比"></a>4.2.6. map 与 multimap 对比</h3><ul>
<li>map 的底层原理是按照平衡二叉树的数据结构来实现的，在插入和删除的操作上比 <code>vector</code> 容器快。</li>
<li>map 支持唯一的键值，每个 <code>key</code> 只能出现一次，支持 <code>[]</code> 操作，形如：<code>map[key] = value</code>。 <code>multimap</code> 不支持唯一的键值，容器中的每个 <code>key</code> 可以出现相同的多次，不支持 <code>[]</code> 操作。</li>
<li>map 和 multimap 会根据元素的 <code>key</code> 自动对元素排序。这么一来，根据已知的 <code>key</code> 查找某个元素时就能够有很好的效率，而根据己知 <code>value</code> 查找元素时，效率就很糟糕。“自动排序”这一性质使得 map 和 multimap 本身有了一条重要限制：你不可以直接改变元素的 <code>key</code>。因为这样做会损坏正确的次序。想要修改元素的 <code>key</code> ，必须先移除拥有该 <code>key</code> 的元素，然后插人拥有新 <code>key/value</code> 的元素。从迭代器的视角看，元素的 <code>key</code> 是常量。然而直接修改元素的 <code>value</code> 是可能的，提供的值的类型不能是 <code>constant</code>。</li>
</ul>
<h3 id="4-2-7-与其它容器对比"><a href="#4-2-7-与其它容器对比" class="headerlink" title="4.2.7. 与其它容器对比"></a>4.2.7. 与其它容器对比</h3><p>set 和 map 中的 key 不能重复，而 multiset 和 multimap 中的 key 却能重复的原因：set 和 map 底层调用的是红黑树的 <code>insert_unique()</code>，而 multiset 和 multimap 底层调用的是红黑树中的 <code>insert_equal()</code> 去进行 <code>insert</code> 操作的。</p>
<h2 id="4-3-Unordered-associative-containers-无序关联容器"><a href="#4-3-Unordered-associative-containers-无序关联容器" class="headerlink" title="4.3. Unordered associative containers(无序关联容器)"></a>4.3. Unordered associative containers(无序关联容器)</h2><h3 id="4-3-1-unordered-set"><a href="#4-3-1-unordered-set" class="headerlink" title="4.3.1. unordered_set"></a>4.3.1. unordered_set</h3><p><code>unordered_set</code> 是一种无序的容器集合。底层采用哈希表实现的。</p>
<p>STL无序容器存储状态，hash 表存储结构图</p>
<img src="./figures/unordered-containers.png">

<img src="./figures/unordered-sets-multisets-internal-structure.png">

<p><code>unordered_set</code> 模板类中的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Value,                        <span class="comment">// 容器中存储元素的类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Hash = hash&lt;_Value&gt;,           <span class="comment">// 确定元素存储位置的哈希函数</span></span><br><span class="line">        <span class="keyword">typename</span> _Pred = std::equal_to&lt;_Value&gt;,  <span class="comment">// 判断各个元素是否相等</span></span><br><span class="line">        <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Value&gt;, <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">        <span class="keyword">typename</span> _Tr = __uset_traits&lt;__cache_default&lt;_Value, _Hash&gt;::value&gt;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意：此容器模板类中没有重载 <code>[]</code> 运算符，也没有提供 <code>at()</code> 成员方法，<code>unordered_set</code> 容器内部存储的元素值不能被修改，可以使用迭代器遍历容器中的数，但不能修改容器中元素的值。</li>
</ul>
<h3 id="4-3-2-unordered-multiset"><a href="#4-3-2-unordered-multiset" class="headerlink" title="4.3.2. unordered_multiset"></a>4.3.2. unordered_multiset</h3><h3 id="4-3-3-unordered-map"><a href="#4-3-3-unordered-map" class="headerlink" title="4.3.3. unordered_map"></a>4.3.3. unordered_map</h3><p>内部结构图</p>
<img src="./figures/unordered-maps-multimsps-internal-structure.png">

<h3 id="4-3-4-API-接口"><a href="#4-3-4-API-接口" class="headerlink" title="4.3.4. API 接口"></a>4.3.4. API 接口</h3><ul>
<li><code>count(key)</code> : 对 multimap 而言，返回 key 在 multimap 中出现的次数；对 map 而言，返回结果为：当前key在map中，返回结果为 1，没在返回结果就为 0；</li>
</ul>
<h3 id="4-3-5-unordered-multimap"><a href="#4-3-5-unordered-multimap" class="headerlink" title="4.3.5. unordered_multimap"></a>4.3.5. unordered_multimap</h3><h3 id="4-3-6-hashtable"><a href="#4-3-6-hashtable" class="headerlink" title="4.3.6. hashtable"></a>4.3.6. hashtable</h3><h4 id="4-3-6-1-什么是hashtable？"><a href="#4-3-6-1-什么是hashtable？" class="headerlink" title="4.3.6.1. 什么是hashtable？"></a>4.3.6.1. 什么是hashtable？</h4><p>哈希表（hashtable）又叫散列表，是一种根据设定的映射函数f(key)将一组关键字映射到一个有限且连续的地址区间上，通过哈希函数把key转成哈希值来定位数据存储位置的一种数据结构。这个映射过程称为哈希造表或者散列，这个映射函数f(key)即为哈希函数也叫散列函数，通过哈希函数得到的存储位置称为哈希地址或散列地址</p>
<p>简单来说哈希表就是通过一个映射函数f(key)将一组数据散列存储在数组中的一种数据结构。</p>
<p>哈希集合（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）中的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。 简单来说就是，hashset是不能存储重复元素的数据结构（集合），而哈希表（hashtable）是存储键-值对（key-value），其中键key不能重复。</p>
<p>用一张图来说明hashtble的数据结构</p>
<img src="./figures/hashtable.png">

<p>用一张图来说明hashset的数据数据</p>
<img src="./figures/hashset.png">

<p>在哈希表中，每一个元素的key和key所对应的value值都存在一个映射函数f(key)与它们一一相对应，通过这个映射函数f(key)，我们可以快速的查找到这个元素在表中所对应的位置。</p>
<img src="./figures/hashfunc.png">

<h4 id="4-3-6-2-为什么要用-hashtable"><a href="#4-3-6-2-为什么要用-hashtable" class="headerlink" title="4.3.6.2. 为什么要用 hashtable?"></a>4.3.6.2. 为什么要用 hashtable?</h4><p>如何在一个无序的线性表中查找一个数据元素？</p>
<p>注意，这是一个无序的线性表，也就是说要查找的这个元素在线性表中的位置是随机的。</p>
<p>对于这样的情况，想要找到这个元素就必须对这个线性表进行遍历，然后与要查找的这个元素进行比较。 这就意味着查找这个元素的时间复杂度为o(n)。</p>
<p>对于o(n)的时间复杂度，在查找海量数据的时候也是一个非常消耗性能的操作。那么有没有一种数据结构，这个数据结构中的元素与它所在的位置存在一个对应关系，这样的话我们就可以通过这个元素直接找到它所在的位置，而此时查找这个元素的时间复杂度就变成了o(1),可以大大节省程序的查找效率。</p>
<img src="./figures/hashtable-array.png">

<p><strong>hash table有什么用？</strong><br><strong>利用哈希表可以快速判断一个元素是否出现集合里。</strong></p>
<h4 id="4-3-6-3-什么是哈希冲突？"><a href="#4-3-6-3-什么是哈希冲突？" class="headerlink" title="4.3.6.3. 什么是哈希冲突？"></a>4.3.6.3. 什么是哈希冲突？</h4><p>对于不同的key，可能得到同一个哈希地址，即key1≠key2,而 f(key1)&#x3D;f(key2)，对于这种现象我们称之为哈希冲突，也叫哈希碰撞。</p>
<p>一般情况下，哈希冲突只能尽可能的减少，但不可能完全避免。</p>
<p>因为哈希函数是从key集合到地址value集合的映射，通常来说key集合比较大，它的元素理论上包括所有可能的key，而地址value集合的元素仅为哈希表中的地址值。</p>
<p>这就导致了哈希冲突的必然性。</p>
<h4 id="4-3-6-4-如何解决哈希冲突？"><a href="#4-3-6-4-如何解决哈希冲突？" class="headerlink" title="4.3.6.4. 如何解决哈希冲突？"></a>4.3.6.4. 如何解决哈希冲突？</h4><p>常用的构造哈希函数的方法有以下几种：</p>
<p>（1）除留取余法</p>
<p>这个方法我们在上边已经有接触过了。取关键字被某个不大于哈希表长m的数p除后所得余数为哈希地址。即：f(key)&#x3D;key % p, p≤m;</p>
<p>（2）直接定址法</p>
<p>直接定址法是指取关键字或关键字的某个线性函数值为哈希地址。即：f(key)&#x3D;key 或者 f(key)&#x3D;a*key+b、</p>
<p>（3）数字分析法</p>
<p>假设关键字是以为基的数（如以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可以选取关键字的若干位数组成哈希表。</p>
<p>虽然我们可以通过选取好的哈希函数来减少哈希冲突，但是哈希冲突终究是避免不了的。那么，碰到哈希冲突应该怎么处理呢？接下来我们来介绍几种处理哈希冲突的方法。</p>
<h5 id="4-3-6-4-1-链地址法"><a href="#4-3-6-4-1-链地址法" class="headerlink" title="4.3.6.4.1. 链地址法"></a>4.3.6.4.1. 链地址法</h5><p>hash table 为了解决冲突采用 <code>separate chaining</code> 的方式。</p>
<p>链地址法是指在碰到哈希冲突的时候，将冲突的元素以链表的形式进行存储。也就是凡是哈希地址为i的元素都插入到同一个链表中，元素插入的位置可以是表头（头插法），也可以是表尾（尾插法）。</p>
<p>是一中比较常用的方法。比如Java中的HashMap就是基于链地址法的哈希表结构。虽然链地址法是一种很好的处理哈希冲突的方法，但是在一些极端情况下链地址法也会出现问题。</p>
<h5 id="4-3-6-4-2-开发定址法"><a href="#4-3-6-4-2-开发定址法" class="headerlink" title="4.3.6.4.2. 开发定址法"></a>4.3.6.4.2. 开发定址法</h5><p>开放定址法是指当发生地址冲突时，按照某种方法继续探测哈希表中的其他存储单元，直到找到空位置为止。</p>
<h5 id="4-3-6-4-3-再哈希法"><a href="#4-3-6-4-3-再哈希法" class="headerlink" title="4.3.6.4.3. 再哈希法"></a>4.3.6.4.3. 再哈希法</h5><p>再哈希法即选取若干个不同的哈希函数，在产生哈希冲突的时候计算另一个哈希函数，直到不再发生冲突为止。</p>
<img src="./figures/rehash-2.png">

<h5 id="4-3-6-4-4-建立公共溢出区"><a href="#4-3-6-4-4-建立公共溢出区" class="headerlink" title="4.3.6.4.4. 建立公共溢出区"></a>4.3.6.4.4. 建立公共溢出区</h5><p>专门维护一个溢出表，当发生哈希冲突时，将值填入溢出表。</p>
<h4 id="4-3-6-5-优点"><a href="#4-3-6-5-优点" class="headerlink" title="4.3.6.5. 优点"></a>4.3.6.5. 优点</h4><ul>
<li>无论数据有多少，处理起来都特别的快</li>
<li>能够快速地进行 插入修改元素 、删除元素 、查找元素 等操作</li>
<li>代码简单，只需要把哈希函数写好，之后的代码就很简单了。</li>
</ul>
<h4 id="4-3-6-6-缺点"><a href="#4-3-6-6-缺点" class="headerlink" title="4.3.6.6. 缺点"></a>4.3.6.6. 缺点</h4><ul>
<li>哈希表中的数据是没有顺序的</li>
<li>数据不允许重复</li>
</ul>
<h4 id="4-3-6-7-复杂度"><a href="#4-3-6-7-复杂度" class="headerlink" title="4.3.6.7. 复杂度"></a>4.3.6.7. 复杂度</h4><p>时间复杂度：最好情况下是 $\Omicron(1)$，最坏情况下是 $\Omicron(n)$，n 是 hash table 的长度。</p>
<p>Hashtable 其实是综合了数组和链表的优点，当 Hashtable 对数值进行搜索的时候，首先用该数值与Hashtable的长度做了取模的操作，得到的数字直接作为hashtable中entry 数组的 index,因为 hashtable 是由 entry 数组组成的，因此，可以直接定位到指定的位置，不需要搜索，当然，这里还有个问题，每个entry其实是链表，如果entry有很多值的话，还是需要挨个遍历的，因此可以这样讲Hashtable的时间复杂度最好是O(1)但是最差是 O(n) 最差的时候也就是hashtable中所有的值的hash值都一样，都分配在一个entry里面。</p>
<h2 id="4-4-Containers-Difference-容器之间的差异性"><a href="#4-4-Containers-Difference-容器之间的差异性" class="headerlink" title="4.4. Containers Difference(容器之间的差异性)"></a>4.4. Containers Difference(容器之间的差异性)</h2><p>和其他所有关联式容器一样，<code>map/multimap</code> 底层是以平衡二叉树完成的。C++ standard 并未明定这一点，但是从 <code>map</code> 和 <code>multimap</code> 各项操作的复杂度自然可以得出这一结念。</p>
<p>通常 <code>set</code>、<code>multiset</code>、<code>map</code> 和 <code>multimp</code> 都使用相同的内部结构，因此，你可以把 <code>set</code> 和 <code>multiset</code> 视为特殊的 <code>map</code> 和 <code>multimp</code>，只不过 <code>set</code> 元素的 <strong>value 和 key 是同一对象</strong>。因此，<code>map</code> 和 <code>multimap</code> 拥有 <code>set</code> 和 <code>multiset</code> 的所有能力和所有操作。当然，某些细微差异还是有的：首先，它们的元素是 key&#x2F;value pair，其次，<code>map</code> 可作为关联式数组(associative array)来使用。</p>
<p>容器如何选择？</p>
<ul>
<li>Array 和 vector 的区别在于容器的长度是否固定。若要随机访问，且容器的长度固定，则用 <code>array</code>，反之用 <code>vector</code>。</li>
<li><code>List</code> 和 <code>vector</code> 最主要的区别在于 <code>vector</code> 是使用连续内存存储的，它支持 <code>[]</code> 运算符，而 <code>list</code> 底层用链表数据结构实现的，不支持 <code>[]</code> 。</li>
<li><code>Vector</code> 内部结构简单，对元素随机访问的速度很快，但是在头部插入元素速度很慢，在尾部插入速度很快。所以数据的访问十分灵活方便，数据的处理也很快。</li>
<li><code>List</code> 对于随机访问速度慢得多，因为需要遍历整个链表才能做到，但是对元素的插入就快的多了，不需要拷贝和移动数据，只需要改变指针的指向就可以了。</li>
<li><code>Map</code>、<code>Set</code> 属于关联性容器，底层是采用红黑树实现的，它的插入、删除效率比其他序列容器高，因为它不需要做内存拷贝和内存移动，而是改变指向节点的指针。</li>
<li><code>Set</code> 和 <code>Vector</code> 的区别在于 <code>Set</code> 容器不包含重复的数据。Set 和 Map 的区别在于 Set 只含有 Key，而 Map有一个 Key 和 Key 所对应的 Value 两个元素。</li>
<li><code>Map</code> 和 <code>HashMap</code> 的区别是 <code>HashMap</code> 使用了 Hash 算法来加快查找过程，但是需要更多的内存来存放这些 Hash 桶元素，因此可以算得上是采用空间来换取时间策略。</li>
</ul>
<p>简单选择容器的准则</p>
<ol>
<li>若需要高效的随机存取，而不在乎插入和删除的效率，使用 <code>vector</code>。 </li>
<li>经常需要元素大量的插入、删除和移动，而不关心随机存取，则应使用 <code>list</code>。</li>
<li>若需要随机存取，而且经常在两端对数据进行插入和删除，则应使用 <code>deque</code>；若希望元素从容器中被移除时，容器能自动缩减内部的内存用量，那么也用 <code>deque</code>。</li>
<li>若需要字典结构或者处理 key&#x2F;value 这样的键值对时，应采用 <code>unordered map(multimap)</code>；若元素的顺序很重要，则用 <code>map(multimap)</code>。</li>
<li>经常根据某个准则去查找元素，则应根据该准则进行 hash 的 <code>unordered_set</code> 或 <code>unordered_multiset</code>；若元素的顺序很重要，则用 <code>set</code> 或 <code>multiset</code>。</li>
</ol>
<h2 id="4-5-Container-adaptors-容器适配器"><a href="#4-5-Container-adaptors-容器适配器" class="headerlink" title="4.5. Container adaptors(容器适配器)"></a>4.5. Container adaptors(容器适配器)</h2><p>容器适配器为有序的容器提供了不同的接口。queue 和 stack 底层完全借助 deque 实现的。</p>
<h3 id="4-5-1-stack"><a href="#4-5-1-stack" class="headerlink" title="4.5.1. stack"></a>4.5.1. stack</h3><h4 id="4-5-1-1-内部结构图"><a href="#4-5-1-1-内部结构图" class="headerlink" title="4.5.1.1. 内部结构图"></a>4.5.1.1. 内部结构图</h4><img src="./figures/stack.png">

<h4 id="4-5-1-2-API-接口"><a href="#4-5-1-2-API-接口" class="headerlink" title="4.5.1.2. API 接口"></a>4.5.1.2. API 接口</h4><ul>
<li><code>push()</code> 入栈</li>
<li><code>pop()</code> 出栈</li>
<li><code>top()</code> 获取栈顶元素</li>
<li><code>size()</code> 获取栈大小</li>
<li><code>empty()</code> 栈为空</li>
</ul>
<h3 id="4-5-2-queue"><a href="#4-5-2-queue" class="headerlink" title="4.5.2. queue"></a>4.5.2. queue</h3><h4 id="4-5-2-1-内部结构图"><a href="#4-5-2-1-内部结构图" class="headerlink" title="4.5.2.1. 内部结构图"></a>4.5.2.1. 内部结构图</h4><img src="./figures/queue.png">

<h4 id="4-5-2-2-API-接口"><a href="#4-5-2-2-API-接口" class="headerlink" title="4.5.2.2. API 接口"></a>4.5.2.2. API 接口</h4><ul>
<li><code>push()</code> 入队列</li>
<li><code>pop()</code> 出队列</li>
<li><code>empty()</code> 对列为空</li>
<li><code>front()</code> 队列头部元素</li>
</ul>
<h3 id="4-5-3-priority-queue-优先级队列"><a href="#4-5-3-priority-queue-优先级队列" class="headerlink" title="4.5.3. priority_queue(优先级队列)"></a>4.5.3. priority_queue(优先级队列)</h3><h4 id="4-5-3-1-什么是优先级队列"><a href="#4-5-3-1-什么是优先级队列" class="headerlink" title="4.5.3.1. 什么是优先级队列"></a>4.5.3.1. 什么是优先级队列</h4><h4 id="4-5-3-2-标准库接口"><a href="#4-5-3-2-标准库接口" class="headerlink" title="4.5.3.2. 标准库接口"></a>4.5.3.2. 标准库接口</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大或最小优先级队列变量的声明 </span></span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; g_priq;                            <span class="comment">// 默认为最大值优先队列</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; l_priq; <span class="comment">// 最小值优先队列</span></span><br></pre></td></tr></table></figure>

<h1 id="5-String"><a href="#5-String" class="headerlink" title="5. String"></a>5. String</h1><p>String 类是 C++ 标准库接对 <code>char*</code> 字符串一系列操作的封装，位于头文件 <code>#include &lt;string&gt;</code> 中。</p>
<h2 id="5-1-string-与-char-转换"><a href="#5-1-string-与-char-转换" class="headerlink" title="5.1. string 与 char* 转换"></a>5.1. string 与 char* 转换</h2><p>1、const char* 与 string 之间的转换。</p>
<p><code>char*</code> 是 C 语言形式的字符串，<code>string</code> 类是 C++ 的字符串，C++ 为了要兼容 C 语言的字符串，两者之间需要进行转换。<code>string</code> 转 <code>const char*</code>，直接调用 string 类的 <code>c_str()</code> 接口。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str = “abc”;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* c_str = str.<span class="built_in">c_str</span>();</span><br></pre></td></tr></table></figure>

<p>2、<code>const char*</code> 转 <code>string</code>，直接赋值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* c_str = “abc”;</span><br><span class="line"><span class="function">string <span class="title">str</span><span class="params">(c_str)</span></span>;</span><br></pre></td></tr></table></figure>

<p>3、<code>string</code> 转 <code>char*</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* c = “abc”;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = s.<span class="built_in">length</span>();</span><br><span class="line">c = <span class="keyword">new</span> <span class="type">char</span>[len<span class="number">+1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(c,s.<span class="built_in">c_str</span>());</span><br></pre></td></tr></table></figure>

<p>4、char* 转 string，直接赋值即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* c = “abc”;</span><br><span class="line"><span class="function">string <span class="title">s</span><span class="params">(c)</span></span>;</span><br></pre></td></tr></table></figure>

<p>5、 <code>const char*</code> 转 <code>char*</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = “abc”;</span><br><span class="line"><span class="type">char</span>* pc = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(cpc)<span class="number">+1</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(pc,cpc);</span><br></pre></td></tr></table></figure>

<p>6、<code>char*</code> 转 <code>const char*</code>，直接赋值即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* pc = “abc”;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* cpc = pc;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-API-接口"><a href="#5-2-API-接口" class="headerlink" title="5.2. API 接口"></a>5.2. API 接口</h2><p>string 是一个随机存储容器。</p>
<ul>
<li><code>constructors</code>: 构造函数。Create or copy a string</li>
<li><code>destructor</code>: 析构函数。Destroys a string</li>
<li><code>=</code> : 对 string 赋一个新值，新值可以是 string，C-string 形式的字符或单一字符。</li>
<li><code>assign()</code>: 给 string 赋单个或多个值。</li>
<li><code>swap()</code>: 交换两个 string 内容。</li>
<li><code>+=</code>, <code>append()</code>, <code>push_back()</code>: 追加字符。</li>
<li><code>insert()</code>：插入字符。</li>
<li><code>erase()</code>, <code>pop_back()</code>: 删除字符。<code>pop_back()</code> 自 C++ 开始。</li>
<li><code>clear()</code>: 移除所有字符。</li>
<li><code>resize()</code>: 改变字符数量，在尾部删除或添加字符。</li>
<li><code>replace()</code>: 替换字符</li>
<li><code>data()</code>, <code>c_str()</code>: 将 string 字符串中内容作为字符数组（C-string形式）返回 。C++11 之前，<code>data()</code> 不是一个有效的 C-string，返回的结果中不包含 <code>\0</code>，C++11 之后，两者的方式是相同的。</li>
<li><code>size()</code>, <code>length()</code>: 返回 string 中当前的字符数量。</li>
<li><code>empty()</code>: 检查 string 中的字符数量是否为 0。检查 string 是否为空时，C++ STL 中建议用 <code>empty()</code> 替代 <code>size()</code>、<code>length()</code>，因为 <code>empty()</code> 比较快。</li>
<li><code>max_size()</code>: 返回一个 string 中包含的最大字符数量。若操作 string 时，它的长度 <code>length</code> 大于 <code>max_szie</code>，后，STL 会抛出 <code>length_error</code>异常。</li>
<li><code>capacity</code>() : 未重新分配 string 内部内存之前，返回 string 包含的最大字符数量。</li>
<li>重新分配后，所有字符串字符指向的 reference、pointer、Iterator 均无效了。</li>
<li>重新分配是很耗费时间的。</li>
<li><code>reverse():</code> 避免重新分配，保留一定容量，确保该容量用尽之前，reference 一直有效。</li>
<li><code>getline()</code>: 逐行读取所有字符，包括开头的空白字符，直到遇到指定的分行符或 <code>end of file</code> 结束，默认情况下分行符为 换行符。</li>
</ul>
<h2 id="5-3-底层实现"><a href="#5-3-底层实现" class="headerlink" title="5.3. 底层实现"></a>5.3. 底层实现</h2><p>Scott Meyers 在《Effective STL》第 15 条中提到 <code>std::string</code> 底层实现有多种方式，归纳起来有 3 类。</p>
<ul>
<li>eager copy（无特殊处理）。采用类似 <code>std::vector</code> 的数据结构，现在很少采用这种形式。</li>
<li>Copy-on-Write（COW，写时复制）。</li>
<li>Small String Optimization（SSO，短字符串优化）。利用 string 对象的本身空间来存储短字符串。</li>
</ul>
<p>C++ GCC <code>std::string</code> 在 C++11 之前与之后实现是完全不同的。c++11 之前实现的是 <strong>COW</strong> string。C++11之后实现的就是<strong>实时拷贝</strong>，因为 <strong>C++11 标准规定：不允许 [] 导致之前的迭代器失效</strong>，这就使得 COW 的string 不再符合C++规范了。</p>
<p><strong>重要区别</strong>：COW 的 <code>basic_string</code> 有一个 <code>RefCnt</code> 变量，用于引用计数；而自 C++11开始，采用引用计数（reference counted）实现的 <code>basic_string</code>  不在被允许。因为让 string 的内部缓冲区共享被共享（ share internal buffers），在多线程环境中是行不通的。</p>
<h3 id="空-string-大小"><a href="#空-string-大小" class="headerlink" title="空 string 大小"></a>空 string 大小</h3><p>源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 及其以上</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> size_type	npos = <span class="built_in">static_cast</span>&lt;size_type&gt;(<span class="number">-1</span>);</span><br><span class="line">size_type		_M_string_length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123; _S_local_capacity = <span class="number">15</span> / <span class="built_in">sizeof</span>(_CharT) &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line">&#123;</span><br><span class="line">    _CharT           _M_local_buf[_S_local_capacity + <span class="number">1</span>];</span><br><span class="line">    size_type        _M_allocated_capacity;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>size_type</code> 由机器决定。</p>
<h3 id="5-3-1-数据类型-Type-Definitions-and-Static-Values"><a href="#5-3-1-数据类型-Type-Definitions-and-Static-Values" class="headerlink" title="5.3.1. 数据类型( Type Definitions and Static Values)"></a>5.3.1. 数据类型( Type Definitions and Static Values)</h3><ol>
<li><code>string::traits_type</code></li>
<li><code>string::value_type</code></li>
<li><code>string::size_type</code></li>
<li><code>string::difference_type</code></li>
<li><code>string::reference</code></li>
<li><code>string::const_reference</code></li>
<li><code>string::pointer</code></li>
<li><code>string::const_pointer</code></li>
<li><code>string::iterator</code></li>
<li><code>string::const_iterator</code></li>
<li><code>string::reverse_iterator</code></li>
<li><code>string::const_reverse_iterator</code></li>
<li><code>static const size_type string::npos</code></li>
<li><code>string::allocator_type</code></li>
</ol>
<h1 id="6-Functor-仿函数"><a href="#6-Functor-仿函数" class="headerlink" title="6. Functor(仿函数)"></a>6. Functor(仿函数)</h1><h2 id="6-1-什么是仿函数？"><a href="#6-1-什么是仿函数？" class="headerlink" title="6.1. 什么是仿函数？"></a>6.1. 什么是仿函数？</h2><p>仿函数(Functor)也叫函数对象(Function object)或者叫伪函数。它是在 <code>struct</code> 结构体中定义一种新的函数，它只为算法 (Algorithms) 服务。从实现的角度看，仿函数是一种重载了 <code>operator()</code> 的 <code>class</code> 或 <code>class template</code>，让对象也具有像函数一样的功能。一般函数指针可视为狭义的仿函数。 </p>
<img src="./figures/functors.png">

<h2 id="6-2-分类"><a href="#6-2-分类" class="headerlink" title="6.2. 分类"></a>6.2. 分类</h2><p>按操作数个数划分</p>
<ul>
<li>一元运算 (unary_function)</li>
<li>二元运算 (binary_function)</li>
</ul>
<p>按功能划分</p>
<ul>
<li><p>算术运算 (Arithmetic)</p>
<ul>
<li><p>加：plus<T></p>
</li>
<li><p>减: minus<T></p>
</li>
<li><p>乘: multiplies<T></p>
</li>
<li><p>除: divides<T></p>
</li>
<li><p>取模: modulus<T>  </p>
</li>
<li><p>否定: negate<T> </p>
<blockquote>
<p>negate 属于一元运算，其余的都属于二元运算。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>关系运算 (Ratioanl)</p>
<ul>
<li><p>等于: equal_to<T> </p>
</li>
<li><p>不等于: not_equal_to<T></p>
</li>
<li><p>大于: greater<T></p>
</li>
<li><p>大于等于: greater_equal<T></p>
</li>
<li><p>小于: less<T></p>
</li>
<li><p>小于等于: less_equal<T></p>
<blockquote>
<p>六种都属于二元运算。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>逻辑运算 (Logical)</p>
<ul>
<li><p>逻辑 And: logical_and<T> </p>
</li>
<li><p>逻辑 Or: logical_or<T></p>
</li>
<li><p>逻辑 Not: logical_not<T></p>
<blockquote>
<p>And, Or 属于二元运算，Not 属于一元运算。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-可调用对象"><a href="#6-3-可调用对象" class="headerlink" title="6.3. 可调用对象"></a>6.3. 可调用对象</h2><p>哪些可以是可调用对象？</p>
<ul>
<li>函数指针 (function pointer)</li>
<li>带有成员函数 <code>operator()</code> 创建的 object。</li>
<li>带有转换函数，可将自己转换为函数指针的 类 所创建的 object。</li>
<li>lambda 表达式。</li>
</ul>
<h2 id="6-4-函数对象调用"><a href="#6-4-函数对象调用" class="headerlink" title="6.4. 函数对象调用"></a>6.4. 函数对象调用</h2><ul>
<li><p>函数对象可以做函数参数。 </p>
</li>
<li><p>函数对象可以做返回值。 </p>
</li>
<li><p>函数对象的调用与 <code>回调函数</code> 的调用类似。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Stu&amp; T)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-5-可调用对象包装器"><a href="#6-5-可调用对象包装器" class="headerlink" title="6.5. 可调用对象包装器"></a>6.5. 可调用对象包装器</h2><p>包含头文件：<code>#include &lt;functional&gt;</code></p>
<p>语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::function&lt;返回值类型(参数列表)&gt; obj_name = 可调用对象</span><br></pre></td></tr></table></figure>

<p>包装器可包装哪些东西？</p>
<ul>
<li>包装类的普通成员函数</li>
<li>包装类的静态函数</li>
<li>包装仿函数</li>
<li>包装转化为函数指针的函数对象</li>
</ul>
<p>类的成员函数不能直接使用可调用对象包装器，还需要结合绑定器一起使用。</p>
<h2 id="6-6-可调用对象绑定器"><a href="#6-6-可调用对象绑定器" class="headerlink" title="6.6. 可调用对象绑定器"></a>6.6. 可调用对象绑定器</h2><p>std::bind()</p>
<p>绑定器作用</p>
<ul>
<li>将可调用对象与其参数一起绑定成为仿函数。</li>
<li>将多元可调用转化为一元可调用对象</li>
</ul>
<p>两种方式</p>
<ul>
<li>绑定非类的成员变量。</li>
<li>绑定类的成员变量或成员函数。</li>
</ul>
<h2 id="6-7-Predefined-Function-Objects-预定义函数对象"><a href="#6-7-Predefined-Function-Objects-预定义函数对象" class="headerlink" title="6.7. Predefined Function Objects (预定义函数对象)"></a>6.7. Predefined Function Objects (预定义函数对象)</h2><p>标准STL模板库中提前预定义了很多的函数对象。任何应用程序想要使用 STL 内建的仿函数，都必须包含标准库预定义函数对象的头文件 <code>&lt;functional&gt;</code>。</p>
<p>仿函数的主要作用就是为了搭配 STL 算法，在算法中进行使用。</p>
<h2 id="6-8-其它"><a href="#6-8-其它" class="headerlink" title="6.8. 其它"></a>6.8. 其它</h2><ul>
<li><p>证同函数(identity_function): 任何数值通过此函数后，不会有任何改变。标准库 <code>stl_function.h</code> 中用 <code>identity</code> 来指定 RB-tree 所需的 KeyOfValue。</p>
</li>
<li><p>选择函数(selection_function)，标准库 <code>stl_function.h</code> 中用 <code>select1st</code> 和 <code>select2nd</code> 来指定 RB-tree 所需的 KeyOfValue。</p>
<ul>
<li>select1st: 接受一个pair，传回它的第一个元素。</li>
<li>select2nd: 接受一个pair，传回它的第二个元素。</li>
</ul>
</li>
<li><p>投射函数</p>
<ul>
<li>project1st: 传回第一参数，忽略第二参数。</li>
<li>project2nd: 传回第二参数，忽略第1参数。</li>
</ul>
</li>
</ul>
<h1 id="7-Algorithm"><a href="#7-Algorithm" class="headerlink" title="7. Algorithm"></a>7. Algorithm</h1><p>从实现的角度来看，STL算法是一种 <code>function template</code>。<strong>而所有的 Algorithms 内部最本质的操作无非就是比大小。</strong></p>
<p>标准库中大约封装了有 80 多种算法。</p>
<p>STL算法的核心思想</p>
<ul>
<li>STL通过类模板技术，实现了数据类型与容器模型的分离。</li>
<li>通过函数对象实现了自定义数据类型与底层算法的分离。</li>
<li>通过迭代器的方式统一的去遍历容器，向容器中读数据和写数据。</li>
</ul>
<h2 id="7-1-Heap-堆"><a href="#7-1-Heap-堆" class="headerlink" title="7.1. Heap(堆)"></a>7.1. Heap(堆)</h2><p>heap（堆）的 STL 库中函数</p>
<ul>
<li><code>make_heap(first, last, comp);</code> 建立一个空堆；</li>
<li><code>push_heap(first, last, comp);</code> 向堆中插入一个新元素；</li>
<li><code>top_heap(first, last, comp); </code> 获取当前堆顶元素的值；</li>
<li><code>sort_heap(first, last, comp);</code> 对当前堆进行排序；</li>
</ul>
<h2 id="7-2-API-接口"><a href="#7-2-API-接口" class="headerlink" title="7.2. API 接口"></a>7.2. API 接口</h2><ul>
<li><p><code>std::for_each()</code> 遍历容器中的所有元素。</p>
</li>
<li><p><code>std::transform()</code> 将容器中的数据进行某种转换的运算。</p>
<blockquote>
<p>两个算法的区别</p>
<ul>
<li><code>std::for_each()</code> 使用的函数对象可以没有 <code>返回值</code>，参数一般传 <code>reference</code>，因此速度较快，不是很灵活。</li>
<li><code>std::transform()</code> 使用的函数对象必须要有 <code>返回值</code>，参数一般传 <code>value</code>，因此速度较慢，但是很灵活。</li>
</ul>
</blockquote>
</li>
<li><p><code>std::adjacent()</code> 查找一对相邻位置重复的元素，找到则返回指向这对元素的第一个元素的迭代器值。</p>
</li>
<li><p><code>std::distance()</code> 返回两个迭代器之间的距离，两个迭代器必须指向同一个容器。</p>
</li>
<li><p><code>std::binary_search()</code> 采用二分法在有序序列中查找 value，找到则返回 true。在无序的序列中不能使用。</p>
</li>
<li><p><code>std::count()</code> 计数容器中指定元素的个数。</p>
</li>
<li><p><code>std::count_if()</code> 使用 <code>谓词</code> 计数容器中指定条件元素的个数。</p>
</li>
<li><p><code>std::find()</code> </p>
</li>
<li><p><code>std::find_if()</code> </p>
</li>
<li><p><code>std::merge()</code>  合并两个有序的序列，并存放到另一个序列中。</p>
</li>
<li><p><code>std::sort()</code> 默认按照升序的方式重新排列指定范围内元素的元素。</p>
</li>
<li><p><code>std::random_shuffle()</code> 对指定范围内的元素随机进行排序。</p>
</li>
<li><p><code>std::reverse()</code> 对指定范围内的元素进行倒叙排序。</p>
</li>
<li><p><code>std::copy()</code> 将一个容器中的元素值拷贝到另一个容器中</p>
</li>
<li><p><code>std::replace()</code> 将指定范围内的 <code>oldValue</code> 替换为 <code>newValue</code></p>
</li>
<li><p><code>std::replace_if()</code> 将指定范围内的 <code>oldValue</code> 替换为 <code>newValue</code>，需要指定 <code>函数对象</code>（是自定义的函数对象或STL预定义的函数对象）。</p>
</li>
<li><p><code>std::swap()</code>  交换两个容器</p>
</li>
<li><p><code>std::accumulate()</code> 累加遍历容器中指定范围内的元素，并在结果上加一个指定的值。</p>
</li>
<li><p><code>std::stable_partition()</code></p>
</li>
<li><p><code>std::upper_bound()</code> </p>
</li>
<li><p><code>std::lower_bound()</code> </p>
</li>
<li><p><code>std::floor()</code> 和 <code>std::ceil()</code>都是对变量进行四舍五入，只不过四舍五入的方向不同。 </p>
<ul>
<li><code>std::floor()</code> –&gt;向下取整数。<code>5.88   std::floor(5.88) = 5;</code></li>
<li><code>std::ceil()</code> –&gt;向上取整数。<code>std::ceil(5.88)   = 6;</code></li>
</ul>
</li>
<li><p><code>std::rotate()</code></p>
</li>
<li><p><code>std::max()</code></p>
</li>
<li><p><code>std::min()</code></p>
</li>
<li><p><code>std::sample</code></p>
</li>
</ul>
<h1 id="8-Adaptor-适配器"><a href="#8-Adaptor-适配器" class="headerlink" title="8. Adaptor(适配器)"></a>8. Adaptor(适配器)</h1><h2 id="8-1-什么是适配器"><a href="#8-1-什么是适配器" class="headerlink" title="8.1. 什么是适配器"></a>8.1. 什么是适配器</h2><p>适配器是一种用来修饰容器(containers)或仿函数(functor)或迭代器(iterators)接口的东西。改变 <code>functor</code> 接口者，称为 <code>function adaptor</code>；改变 <code>container</code> 接口者，称为 <code>container adaptor</code>；改变 <code>iterator</code> 接口者，称为 <code>iterator adaptor</code>。</p>
<h2 id="8-2-分类"><a href="#8-2-分类" class="headerlink" title="8.2. 分类"></a>8.2. 分类</h2><h3 id="8-2-1-function-adaptor-函数适配器"><a href="#8-2-1-function-adaptor-函数适配器" class="headerlink" title="8.2.1. function adaptor(函数适配器)"></a>8.2.1. function adaptor(函数适配器)</h3><h3 id="8-2-2-bind-adaptor-绑定适配器"><a href="#8-2-2-bind-adaptor-绑定适配器" class="headerlink" title="8.2.2. bind adaptor(绑定适配器)"></a>8.2.2. bind adaptor(绑定适配器)</h3><h3 id="8-2-3-composite-adaptor-组合适配器"><a href="#8-2-3-composite-adaptor-组合适配器" class="headerlink" title="8.2.3. composite adaptor(组合适配器)"></a>8.2.3. composite adaptor(组合适配器)</h3><h3 id="8-2-4-pointer-adaptor-指针适配器"><a href="#8-2-4-pointer-adaptor-指针适配器" class="headerlink" title="8.2.4. pointer adaptor(指针适配器)"></a>8.2.4. pointer adaptor(指针适配器)</h3><h3 id="8-2-5-member-function-adaptor-成员函数适配器"><a href="#8-2-5-member-function-adaptor-成员函数适配器" class="headerlink" title="8.2.5. member function adaptor(成员函数适配器)"></a>8.2.5. member function adaptor(成员函数适配器)</h3><p>predicate: 判断这个条件是真还是假</p>
<h1 id="9-Traits-萃取机"><a href="#9-Traits-萃取机" class="headerlink" title="9. Traits(萃取机)"></a>9. Traits(萃取机)</h1><p>trait 中文译为：特点、特征、特性。</p>
<p><code>Traits</code> 有很多的类型。</p>
<h2 id="9-1-iterator-traits"><a href="#9-1-iterator-traits" class="headerlink" title="9.1. iterator_traits"></a>9.1. iterator_traits</h2><p> <code>iterator_traits</code> 即为迭代器的特征。这个有点不好理解，可以把它理解成一个 <code>萃取机</code>，用来区分传入迭代器中的类型是 <strong>class iterators</strong> 还是 <strong>non class iterators，即 native pointer</strong>。可以利用<strong>类模板中的 partial specialization</strong>可以得到目标。</p>
<img src="./figures/iterator-traits.png">

<p>根据经验，最常用到的迭代器相应型别有五种：<code>value type</code>，<code>difference type</code>，<code>pointer</code>，<code>reference</code>，<code>iterator_category</code>。如果你希望你所开发的容器能与 STL 水乳交融，一定要为你的容器中的迭代器定义这五种相应类型。“特性萃取机” traits 会很忠实地将原汁原味榨取出来：</p>
<img src="./figures/traits.png">

<p>其中，<code>iterator_traits</code> 位于 <code>../C++/bits/stl_iterators.h&gt;</code> 头文件里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Iterator					                iterator_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __traits_type::iterator_category iterator_category;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __traits_type::value_type  	    value_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __traits_type::difference_type 	difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __traits_type::reference 	    reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __traits_type::pointer   	    pointer;</span><br></pre></td></tr></table></figure>

<ul>
<li>value_type: 迭代器所指对象的类型。</li>
<li>difference_type: 两个迭代器之间的距离。也可以用来表示一个容器的最大容量，因为对于连续空间的容器而言，最大容量就是头尾之间的距离。</li>
<li>reference: 迭代器所指向的内容是否允许改变。</li>
<li>pointer: 迭代器指向的内容为指针。</li>
<li>iterator_category: 迭代器的类别。查看 <em>迭代器章节的分类部分</em>。</li>
</ul>
<h2 id="9-2-type-traits"><a href="#9-2-type-traits" class="headerlink" title="9.2. type traits"></a>9.2. type traits</h2><p>位于 <code>../C++/type_traits.h&gt;</code> 头文件中。</p>
<h2 id="9-3-char-traits"><a href="#9-3-char-traits" class="headerlink" title="9.3. char traits"></a>9.3. char traits</h2><p>位于 <code>../C++/bits/char_traits.h&gt;</code> 头文件中。</p>
<h2 id="9-4-allocator-traits"><a href="#9-4-allocator-traits" class="headerlink" title="9.4. allocator traits"></a>9.4. allocator traits</h2><p>位于 <code>../C++/bits/alloc_traits.h&gt;</code> 头文件中。</p>
<h2 id="9-5-pointer-traits"><a href="#9-5-pointer-traits" class="headerlink" title="9.5. pointer traits"></a>9.5. pointer traits</h2><p>位于 <code>../C++/bits/ptr_traits.h&gt;</code> 头文件中。</p>
<h2 id="9-6-array-traits"><a href="#9-6-array-traits" class="headerlink" title="9.6. array traits"></a>9.6. array traits</h2><p>位于 <code>../C++/array&gt;</code> 头文件中。</p>
<h1 id="10-Iterators-迭代器"><a href="#10-Iterators-迭代器" class="headerlink" title="10. Iterators(迭代器)"></a>10. Iterators(迭代器)</h1><h2 id="10-1-什么是迭代器"><a href="#10-1-什么是迭代器" class="headerlink" title="10.1. 什么是迭代器"></a>10.1. 什么是迭代器</h2><p>表示元素在容器中的位置，这种对象的概念就称为迭代器。（STL标准库中的解释：we need a concept of an object that represents positions of elements in a container. This concept exists. Objects that fulfill this concept are called iterators.）</p>
<p>迭代器就是一种泛化的指针，是一个可遍历 STL 容器中全部或部分元素的对象。从实现的角度看，迭代器是一种将 <code>operator*</code>, <code>operator-&gt;</code>, <code>operator++</code>, <code>operator--</code> 等指针操作给予重载的 <code>class template</code>。</p>
<h2 id="10-2-迭代器设计思维"><a href="#10-2-迭代器设计思维" class="headerlink" title="10.2. 迭代器设计思维"></a>10.2. 迭代器设计思维</h2><p>不论是泛型思维或 STL 的实际运用，迭代器（iterators）都扮演着重要的角色。STL 的中心思想在于：将数据容器（containers）和算法（algorithms）分开，彼此独立设计，最后再以一帖胶着剂将它们撮合在一起。容器和算法的泛型化，从技术角度来看并不困难，C++ 的 class templates 和 function templates 可分别达成目标。如何设计出两者之间的良好胶着剂，才是大难题。</p>
<h2 id="10-3-基本操作"><a href="#10-3-基本操作" class="headerlink" title="10.3. 基本操作"></a>10.3. 基本操作</h2><ul>
<li><code>operator *</code>: 返回当前位置上元素的值。</li>
<li><code>operator ++ 或 operator --</code>: 让迭代器指向下一个或上一个元素。</li>
<li><code>operator == 或 operator !=</code>: 判断两个迭代器是否指向同一个位置。</li>
<li><code>operator =</code>: 赋值给迭代器</li>
</ul>
<p>不同的迭代器也许是 <code>smart pointers</code>，具有遍历复杂数据结构的能力，其内部运作机制取决于所遍历的数据结构。每一种容器都必须提供自己的迭代器。事实上每一种容器的确都将其迭代器以嵌套方式定义与 class 内部，因此各种迭代器的接口（interface）虽然相同，但类型（type）却是各不相同。</p>
<h2 id="10-4-迭代运算"><a href="#10-4-迭代运算" class="headerlink" title="10.4. 迭代运算"></a>10.4. 迭代运算</h2><p>迭代器的区间是一个前闭后开区间（half-open range）。</p>
<ul>
<li>begin: 返回一个迭代器，指向容器中第一个元素的位置。</li>
<li>end: 返回一个迭代器，指向容器的终点，终点位于最后一个元素的下一个位置。</li>
</ul>
<img src="./figures/begin-end.png">

<p>采用半开区间的优点？</p>
<ul>
<li>给遍历元素时，循环（loop）结束的时候，提供一个简单的判断依据。只要尚未达 <code>end()</code>，loop就继续执行。</li>
<li>避免对空区间（empty ranges）采取特殊的处理。对于 <code>empty ranges</code> 而言，<code>begin()</code> 就等于 <code>end()</code>。</li>
</ul>
<h2 id="10-5-iterator遵循的原则"><a href="#10-5-iterator遵循的原则" class="headerlink" title="10.5. iterator遵循的原则"></a>10.5. iterator遵循的原则</h2><p>iterator 是算法（Algorithms）与容器 （containers）之间的桥梁。</p>
<img src="./figures/iterator-types.png">

<h2 id="10-6-Iterator-分类"><a href="#10-6-Iterator-分类" class="headerlink" title="10.6. Iterator 分类"></a>10.6. Iterator 分类</h2><p>根据移动特性和施行特性，迭代器分为五类：</p>
<ul>
<li>input iterator: 这种迭代器所指的对象，不允许外界去改变，属于只读的。</li>
<li>output iterator: 属于只能写的迭代器。</li>
<li>forward iterator: 允许”写入型“算法（例如：<code>replace()</code>）在此迭代器所形成的区间上进行读写操作。l</li>
<li>bidirectional iterator: 双向移动迭代器。</li>
<li>random access iterator: 随机访问迭代器，涵盖所有指针运算的能力。</li>
</ul>
<img src="./figures/iterator-category.png">

<p>源码位于标准库的 <code>stl_iterator_base_types.h</code> 文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stl_iterator_base_types.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  @defgroup iterator_tags Iterator Tags</span></span><br><span class="line"><span class="comment">   *  These are empty types, used to distinguish different iterators.  The</span></span><br><span class="line"><span class="comment">   *  distinction is not made by what they contain, but simply by what they</span></span><br><span class="line"><span class="comment">   *  are.  Different underlying algorithms can then be used based on the</span></span><br><span class="line"><span class="comment">   *  different operations supported by different iterator types.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">///  Marking input iterators.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">input_iterator_tag</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">///  Marking output iterators.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">output_iterator_tag</span> &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Forward iterators support a superset of input iterator operations.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">forward_iterator_tag</span> : <span class="keyword">public</span> input_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Bidirectional iterators support a superset of forward iterator</span></span><br><span class="line"><span class="comment">/// operations.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bidirectional_iterator_tag</span> : <span class="keyword">public</span> forward_iterator_tag &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Random-access iterators support a superset of bidirectional</span></span><br><span class="line"><span class="comment">/// iterator operations.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">random_access_iterator_tag</span> : <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;;</span><br></pre></td></tr></table></figure>

<p><code>istream_iterator</code> 的 iterator_category<br><img src="./figures/istream-iterator.png"></p>
<p><code>ostream_iterator</code> 的 iterator_category<br><img src="./figures/ostream-iterator.png"></p>
<p>父类中没有data 和 function，子类继承于父类的 typedef。</p>
<p><strong>Iterator分类对算法的影响</strong></p>
<img src="./figures/iterator-category-copy.png">

<img src="./figures/iterator-category-destory.png">

<img src="./figures/iterator-category-destory-2.png">



<h2 id="10-7-迭代器失效"><a href="#10-7-迭代器失效" class="headerlink" title="10.7. 迭代器失效"></a>10.7. 迭代器失效</h2><ul>
<li><p>为什么迭代器会失效？</p>
<p>STL 容器中元素整体“迁移”导致存放原容器元素的空间不再有效，使原本指向某元素的迭代器不再指向希望指向的元素，从而使得指向原空间的迭代器失效。 </p>
</li>
<li><p>对于序列式容器，比如vector，删除当前的iterator会使后面所有元素的iterator都失效。因为序列式容器中内存是连续分配的（分配一个数组作为内存），删除一个元素导致后面所有的元素会向前移动一个位置。删除了一个元素，该元素后面的所有元素都要挪位置，所以，删除一个数据后，其他数据的地址发生了变化，之前获取的迭代器根据原有的信息就访问不到正确的数据。</p>
</li>
<li><p>数组型数据结构的元素是分配在连续的内存中，<code>insert</code> 和 <code>erase</code> 操作，会使删除点和插入点之后的元素挪位置。所以，插入点和删除掉之后的迭代器全部失效，也就是说 <code>insert(*iter)(或erase(*iter))</code>，然后再 <code>iter++</code>，是没有意义的。</p>
<ul>
<li>解决方法：<code>erase(*iter)</code>的返回值是下一个有效迭代器的值 <code>iter =cont.erase(iter);</code></li>
</ul>
</li>
<li><p>list型的数据结构，使用了不连续分配的内存，删除运算使指向删除位置的迭代器失效，但是不会失效其他迭代器。</p>
<ul>
<li>解决办法两种，<code>erase(*iter)</code> 会返回下一个有效迭代器的值，或者<code>erase(iter++)</code>。</li>
</ul>
</li>
<li><p>红黑树存储的数据，插入操作不会使任何迭代器失效；删除操作使指向删除位置的迭代器失效，但不会失效其他迭代器。<code>erase</code> 迭代器只是被删元素的迭代器失效，但是返回值为 <code>void</code>，所以要采用 <code>erase(iter++)</code>的方式删除迭代器。</p>
</li>
</ul>
<p><font color=red>注意：</font>  经过 <code>erase(iter)</code> 之后的迭代器完全失效，该迭代器 <code>iter</code> 不能参与任何运算，包括 <code>iter++和*ite</code>。</p>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/lujiandong1/article/details/49872763">迭代器失效的几种情况总结</a> </li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/stpeace/article/details/46507451?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&dist_request_id=2cff67d7-d841-4421-bbca-7f85ba6e0330&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">聊聊map和vector的迭代器失效问题</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qiaoconglovelife/p/5370396.html">C++ STL 迭代器失效问题</a></li>
</ul>
<h1 id="11-Allocators-分配器"><a href="#11-Allocators-分配器" class="headerlink" title="11. Allocators(分配器)"></a>11. Allocators(分配器)</h1><h2 id="11-1-什么是分配器"><a href="#11-1-什么是分配器" class="headerlink" title="11.1. 什么是分配器"></a>11.1. 什么是分配器</h2><p>分配器（Allocator）负责内存空间的分配与管理。分配器是一个实现了动态空间配置、空间管理、空间释放的 <code>class template</code>。分配器我们一般不直接使用它，它是给容器使用的。容器的内存分配是通过分配器来管理的。</p>
<p>C++ 标准库在许多地方使用特殊的对象（objects）处理内存的分配（allocation）和归还（deallocation），像这样的对象（objects）就称为分配器<code>allocators</code>。</p>
<p><strong>Allocator 代表的是一种特殊内存模型（memorymodel），并提供一种抽象的概念，将需要使用的内存（need to use memory）转变为对内存的直接调用（raw call for memory）。</strong> 如果在相同的时间使用不同的分配器（allocato）对象，允许你在程序中使用不同的内存模型（memory models）。</p>
<p>最初，allocator 只是作为 STL 的一部分而引人的，用来处理像 PC 上不同类型的指针（例如near、far、huge指针）这一类乱七八艚的问题；现在则是作为“运用某种内存模型”技术方案的基础，使得像共享内存（shared memory）、垃圾回收（garbagecollection）、面向对象数据库（object-oriented database）等解决方案能保特一致接。</p>
<h2 id="11-2-默认分配器"><a href="#11-2-默认分配器" class="headerlink" title="11.2. 默认分配器"></a>11.2. 默认分配器</h2><p>C++标准定了一个 default allocator 如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">  <span class="keyword">template</span> &lt; <span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">allocator</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个默认分配器（default allocator）可在 <strong>allocator 得以被当作实参</strong>使用的任何地方允许当默认值，它会执行内存分配和回收。也是说，它会调用 new 和 delete 操作符。但 C++ 并没有对<strong>在什么时候以什么方式调用这些操作符</strong>给予明确规定。因此，default allocator 甚至可能在内部对分配内存采用缓存（cache）的手法。</p>
<p>绝人多数程序都使用 default allocator，但有时其它程序库也可能提供些 allocator 满足特定需求。这种情况下只需简单地将它们当做实参即可。只有少数情况下才需要自行写一个 allocator，现实中最常使用的还是 default allocator。</p>
<p>allocator 底层的操作都是采用 <code>malloc()</code> 和 <code>free()</code>来分配和释放内存。<code>malloc</code> 分配内存时，会有额外的外开销（overhead），使程序变慢。若要提高内存分配的效率，需要减少 <code>cookie（用以记录内存的大小）</code> 的开销</p>
<h2 id="11-3-Allocator-标准接口"><a href="#11-3-Allocator-标准接口" class="headerlink" title="11.3. Allocator 标准接口"></a>11.3. Allocator 标准接口</h2><ol>
<li><code>allocator::value_type</code> <ul>
<li>The type of the elements. </li>
<li>It is usually equivalent to T for an <code>allocator&lt;T&gt;</code>，传递一个模板参数类型。</li>
</ul>
</li>
<li><code>allocator::size_type</code></li>
<li><code>allocator::difference_type</code><ul>
<li>有符号整数值的类型，它可以表示分配模型中任意两个指针之间的差异。</li>
</ul>
</li>
<li><code>allocator::pointer</code></li>
<li><code>allocator::const_pointer</code></li>
<li><code>allocator::void_pointer</code></li>
<li><code>allocator::const_void_pointer</code></li>
<li><code>allocator::reference</code></li>
<li><code>allocator::const_reference</code></li>
<li><code>allocator::rebind</code></li>
<li><code>allocator::propagate_on_container_copy_assignment</code></li>
<li><code>allocator::propagate_on_container_move_assignment</code></li>
<li><code>allocator::propagate_on_container_swap</code></li>
<li><code>allocator::allocator ()</code></li>
<li><code>allocator::allocator (const allocator&amp; a)</code></li>
<li><code>allocator::allocator (allocator&amp;&amp; a)</code></li>
<li><code>allocator::˜allocator ()</code></li>
<li><code>pointer allocator::address (reference value)</code> </li>
<li><code>const_pointer allocator::address (const_reference value)</code></li>
<li><code>size_type allocator::max_size ()</code></li>
<li><code>pointer allocator::allocate (size_type num)</code> </li>
<li><code>pointer allocator::allocate (size_type num, allocator::const_pointer hint)</code></li>
<li><code>void allocator::deallocate (pointer p, size_type num)</code></li>
<li><code>void allocator::construct (U* p, Args&amp;&amp;... args)</code></li>
<li><code>void allocator::destroy (U* p)</code></li>
<li><code>bool operator == (const allocator&amp; a1, const allocator&amp; a2)</code></li>
<li><code>bool operator != (const allocator&amp; a1, const allocator&amp; a2)</code></li>
<li><code>allocator select_on_container_copy_construction ()</code></li>
</ol>
<h1 id="12-Reference"><a href="#12-Reference" class="headerlink" title="12. Reference"></a>12. Reference</h1><ul>
<li><a target="_blank" rel="noopener" href="https://www.sohu.com/a/434917653_611601">面试官：哈希表都不知道，你是怎么看懂HashMap的？ </a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1052125">c++ list, vector, map, set 区别与用法比较</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io">John Jeep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io/Cpp/Cpp/04-STL/">https://johnjeep.github.io/Cpp/Cpp/04-STL/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://johnjeep.github.io" target="_blank">Leaning Computer Science Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/04-STL/">04-STL</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Cpp/Cpp/03-C++Standard/" title="03-C++Standard"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">03-C++Standard</div></div><div class="info-2"><div class="info-item-1">  C++ 新特性演化整体概览。  1. C++11 新特性1.1. Template of  Space在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。 12vector&lt;list&lt;int&gt; &gt; ;  // C+11 之前版本，必须要加一个空格，否则编译器会报错vector&lt;list&lt;int&gt;&gt; ;   // C++11 之后，不用加空格，语法得到了优化   1.2. Initializer listsC++11 引入了初值列 (initializer list) 和一致性初始化 (Uniform Initialization)。即采用 &#123;&#125; 去初始化需要初始化的参数，引入新特的同时也兼容原版本的 () 初始化操作。    initializer list 的底层是采用 initializer_list&lt;T&gt; 这个类模板实现的，其中这个类模板下层采用...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++MemoryManagement/" title="C++MemoryManagement"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++MemoryManagement</div></div><div class="info-2"><div class="info-item-1">  History(历史)Doug Lea自1986年开始研究malloc算法，他的作品被称为 DL Malloc，目前linux中的glibc的malloc算法就是直接来自Doug Lea，其它平台的malloc的实现或多或少受到DL的影响。 内存管理层级 OS（操作系统），Windows 系统的的 HeapAlloc 和 VirtualAlloc； GUNC++&#x2F;CRT 编译器的 malloc() C++ 标准库的 Allocator C++ 应用程序层面的内存 API 函数。  内存库作品 tcmalloc：稳定，占用内存更低。 jemalloc性能更高，占用内存更高  Bibliography(书目) STL源码剖析(侯捷) Small Memory Software(James Noble &amp; Charles Weir) Modern C++ Design General Programming and Design Patterns Applied(Andrei Alexandrescu)  Reference(参考) Doug Lea’s...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Cpp/Cpp/01-C++Novice/" title="01-C++Novice"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">01-C++Novice</div></div><div class="info-2"><div class="info-item-1">  1. concept(概念)c++ 是一种倾向于系统编程的通用编程语言，在 C 语言的基础上发展起来的，支持的特性。  supports data abstraction supports object-oriented programming supports generic programming   Compile-Time (constexpr and template metaprogramming)  2. c++ basics(C++基础) C 语言中，表达式的返回值是一个数值。C++ 中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。  endl 与 \n 区别  endl：换行和清除缓冲区到输出屏幕上 \n：仅仅只是换行   float：有效数字是 6~7 位  double：有效数字是 15 位  char：8 个 bit，占一个字节（byte）空间  取模场景  取一个数的个位数 多少天是一个月的第几天   &lt;&lt; 左移运算符：右侧空位补 0  &gt;&gt; 右移运算符：左侧空位补符号位，符号位正数部...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/02-C++Advanced/" title="02-C++Advanced"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">02-C++Advanced</div></div><div class="info-2"><div class="info-item-1">  1. Object Oriented Programming(面向对象编程)Object Oriented Programming(OOP)叫面向对象编程。  class without pointer members：类中的成员不带有指针。 class with pointer members：类中的成员带有指针。  1.1. Encapsulation(封装)封装这个术语用来描述在过程接口后面隐藏实现细节的概念。 C++ 中对类的设计时，封装了属性和方法。若直接访问类的数据成员就违反了封装原则。设计原则应保持数据成员的私有性。 访问限定符  public  修饰类的成员变量和函数，既能在 类的内部 使用又能在 类的外部 使用 private 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用 protect 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用，可以在 继承的子类 中使用。  C++ 中类与类之间的关系主要归为三大类：复合、委托、继承。 1.2....</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/03-C++Standard/" title="03-C++Standard"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">03-C++Standard</div></div><div class="info-2"><div class="info-item-1">  C++ 新特性演化整体概览。  1. C++11 新特性1.1. Template of  Space在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。 12vector&lt;list&lt;int&gt; &gt; ;  // C+11 之前版本，必须要加一个空格，否则编译器会报错vector&lt;list&lt;int&gt;&gt; ;   // C++11 之后，不用加空格，语法得到了优化   1.2. Initializer listsC++11 引入了初值列 (initializer list) 和一致性初始化 (Uniform Initialization)。即采用 &#123;&#125; 去初始化需要初始化的参数，引入新特的同时也兼容原版本的 () 初始化操作。    initializer list 的底层是采用 initializer_list&lt;T&gt; 这个类模板实现的，其中这个类模板下层采用...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++MemoryManagement/" title="C++MemoryManagement"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++MemoryManagement</div></div><div class="info-2"><div class="info-item-1">  History(历史)Doug Lea自1986年开始研究malloc算法，他的作品被称为 DL Malloc，目前linux中的glibc的malloc算法就是直接来自Doug Lea，其它平台的malloc的实现或多或少受到DL的影响。 内存管理层级 OS（操作系统），Windows 系统的的 HeapAlloc 和 VirtualAlloc； GUNC++&#x2F;CRT 编译器的 malloc() C++ 标准库的 Allocator C++ 应用程序层面的内存 API 函数。  内存库作品 tcmalloc：稳定，占用内存更低。 jemalloc性能更高，占用内存更高  Bibliography(书目) STL源码剖析(侯捷) Small Memory Software(James Noble &amp; Charles Weir) Modern C++ Design General Programming and Design Patterns Applied(Andrei Alexandrescu)  Reference(参考) Doug Lea’s...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++Optimization/" title="C++Optimization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++Optimization</div></div><div class="info-2"><div class="info-item-1"> 开销来自哪里 函数之间的调用。用模板和内联函数去解决。  编写高效的 C++ 程序让编写的程序提高运行效率的方式：  高效的算法。 避免不必要计算和步骤。 选择恰当的优化设计策略。  References Software optimization resources 《Optimized C++》Kurt Guntheroth 大师编写的 C++ 优化书籍。 《Effective STL》 《Effective C++》 《Effective Modern C++》  </div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++SoftDesign/" title="C++SoftDesign"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++SoftDesign</div></div><div class="info-2"><div class="info-item-1">  1. C++ 软件设计1.1. 简单就是最好的 —&gt; 大道至简。API 是软件组件的接口，隐藏了实现这个接口所需的内部细节。 API 必须拥有良好的设计、文档、回归测试、并且保证发布之间的稳定性。 1.2. 重用哲学设计自己和其它程序员可以重复使用的代码。重用设计的准则：  编写一次，经常使用。 尽量避免代码重复。 不要重复写在自己写过的代码（Don’t repeat yourself）。  为什么要重用设计代码？  重用设计可以节约金钱和时间。 缺乏重用性会导致代码重复。  1.3. 如何设计可重用代码对于设计可重用代码而言，最重要的策略是抽象。设计代码时，需要考虑将    接口和实现进行分离，使代码更容易使用，程序员使用时不需要理解其内部实现细节。 ​ 抽象将代码分为接口和实现，因此设计可重用代码会关注这两个领域。代码实现时思考：如何做到恰到好处的设计代码结构？考虑使用什么样的类层次结构？需要使用模板吗？如何将代码切分割为子系统？设计接口时思考：设计分接口是库还是代码的“入口“，程序员使用这个接口时，应该给提供什么样的功能。 1.4....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Jeep</div><div class="author-info-description">lifestyle is lazy, faster, thinking</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JohnJeep/Learning-CS-Journey"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xxxxx@gmail.com" target="_blank" title="Gmail"><i class="fa-solid fa-bell" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Thinking-%E6%80%9D%E8%80%83"><span class="toc-number">1.</span> <span class="toc-text">1. Thinking(思考)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-History-%E5%8E%86%E5%8F%B2"><span class="toc-number">2.</span> <span class="toc-text">2. History(历史)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-STL-Standard-Template-Library-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93"><span class="toc-number">3.</span> <span class="toc-text">3. STL(Standard Template Library)标准模板库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Container-%E5%AE%B9%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">4. Container(容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Sequence-containers-%E6%9C%89%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="toc-number">4.1.</span> <span class="toc-text">4.1. Sequence containers(有序容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-Array-%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.1.</span> <span class="toc-text">4.1.1. Array(数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-1-%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">4.1.1.1. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-2-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">4.1.1.2. 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">4.1.1.3. 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-vector-%E5%8D%95%E7%AB%AF%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.1.2. vector(单端的动态数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-1-API%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">4.1.2.1. API接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-2-%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">4.1.2.2. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">4.1.2.3. 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-2-4-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">4.1.2.4. 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-deque-%E5%8F%8C%E7%AB%AF%E6%95%B0%E7%BB%84"><span class="toc-number">4.1.3.</span> <span class="toc-text">4.1.3. deque(双端数组)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-1-API%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">4.1.3.1. API接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-2-%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.3.2.</span> <span class="toc-text">4.1.3.2. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-3-3-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.3.3.</span> <span class="toc-text">4.1.3.3. 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-list-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.4.</span> <span class="toc-text">4.1.4. list(双向链表)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-1-list-insert"><span class="toc-number">4.1.4.1.</span> <span class="toc-text">4.1.4.1. list insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-2-list-delete"><span class="toc-number">4.1.4.2.</span> <span class="toc-text">4.1.4.2. list delete</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-3-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.1.4.3.</span> <span class="toc-text">4.1.4.3. 内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-4-%E4%BC%98%E7%82%B9"><span class="toc-number">4.1.4.4.</span> <span class="toc-text">4.1.4.4. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-5-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.4.5.</span> <span class="toc-text">4.1.4.5. 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-6-API%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.4.6.</span> <span class="toc-text">4.1.4.6. API接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-4-7-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.4.7.</span> <span class="toc-text">4.1.4.7. 源码分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-forword-list-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.1.5.</span> <span class="toc-text">4.1.5. forword list(单向链表)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.1.5.1.</span> <span class="toc-text">4.1.5.1. 内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.1.5.2.</span> <span class="toc-text">4.1.5.2. API 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-3-%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">4.1.5.3.</span> <span class="toc-text">4.1.5.3. 优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-4-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">4.1.5.4.</span> <span class="toc-text">4.1.5.4. 注意点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-5-5-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.5.5.</span> <span class="toc-text">4.1.5.5. 源码分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Associative-containers-%E5%85%B3%E8%81%94%E6%80%A7%E5%AE%B9%E5%99%A8"><span class="toc-number">4.2.</span> <span class="toc-text">4.2. Associative containers(关联性容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-set"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1. set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">4.2.1.1. 内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">4.2.1.2. API 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-3-%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.1.3.</span> <span class="toc-text">4.2.1.3. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-4-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.1.4.</span> <span class="toc-text">4.2.1.4. 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-multiset"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2. multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-set-%E4%B8%8E-multiset-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3. set 与 multiset 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-map"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4. map</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-1-map%E4%B8%8Emultimap%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">4.2.4.1. map与multimap内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-2-map-insert"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">4.2.4.2. map insert</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-3-at"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">4.2.4.3. at() &amp;&amp; []</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-4-%E4%BC%98%E7%82%B9"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">4.2.4.4. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-5-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.2.4.5.</span> <span class="toc-text">4.2.4.5. 缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-5-mutimap"><span class="toc-number">4.2.5.</span> <span class="toc-text">4.2.5. mutimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-6-map-%E4%B8%8E-multimap-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.6.</span> <span class="toc-text">4.2.6. map 与 multimap 对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-7-%E4%B8%8E%E5%85%B6%E5%AE%83%E5%AE%B9%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.7.</span> <span class="toc-text">4.2.7. 与其它容器对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Unordered-associative-containers-%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3. Unordered associative containers(无序关联容器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-unordered-set"><span class="toc-number">4.3.1.</span> <span class="toc-text">4.3.1. unordered_set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-unordered-multiset"><span class="toc-number">4.3.2.</span> <span class="toc-text">4.3.2. unordered_multiset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-unordered-map"><span class="toc-number">4.3.3.</span> <span class="toc-text">4.3.3. unordered_map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.4.</span> <span class="toc-text">4.3.4. API 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-unordered-multimap"><span class="toc-number">4.3.5.</span> <span class="toc-text">4.3.5. unordered_multimap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-hashtable"><span class="toc-number">4.3.6.</span> <span class="toc-text">4.3.6. hashtable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-1-%E4%BB%80%E4%B9%88%E6%98%AFhashtable%EF%BC%9F"><span class="toc-number">4.3.6.1.</span> <span class="toc-text">4.3.6.1. 什么是hashtable？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-hashtable"><span class="toc-number">4.3.6.2.</span> <span class="toc-text">4.3.6.2. 为什么要用 hashtable?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-3-%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">4.3.6.3.</span> <span class="toc-text">4.3.6.3. 什么是哈希冲突？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-4-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%EF%BC%9F"><span class="toc-number">4.3.6.4.</span> <span class="toc-text">4.3.6.4. 如何解决哈希冲突？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-4-1-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95"><span class="toc-number">4.3.6.4.1.</span> <span class="toc-text">4.3.6.4.1. 链地址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-4-2-%E5%BC%80%E5%8F%91%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">4.3.6.4.2.</span> <span class="toc-text">4.3.6.4.2. 开发定址法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-4-3-%E5%86%8D%E5%93%88%E5%B8%8C%E6%B3%95"><span class="toc-number">4.3.6.4.3.</span> <span class="toc-text">4.3.6.4.3. 再哈希法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-3-6-4-4-%E5%BB%BA%E7%AB%8B%E5%85%AC%E5%85%B1%E6%BA%A2%E5%87%BA%E5%8C%BA"><span class="toc-number">4.3.6.4.4.</span> <span class="toc-text">4.3.6.4.4. 建立公共溢出区</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-5-%E4%BC%98%E7%82%B9"><span class="toc-number">4.3.6.5.</span> <span class="toc-text">4.3.6.5. 优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-6-%E7%BC%BA%E7%82%B9"><span class="toc-number">4.3.6.6.</span> <span class="toc-text">4.3.6.6. 缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-6-7-%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">4.3.6.7.</span> <span class="toc-text">4.3.6.7. 复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Containers-Difference-%E5%AE%B9%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">4.4. Containers Difference(容器之间的差异性)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Container-adaptors-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">4.5. Container adaptors(容器适配器)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-stack"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.5.1. stack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">4.5.1.1. 内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-1-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">4.5.1.2. API 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-queue"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.5.2. queue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%E5%9B%BE"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">4.5.2.1. 内部结构图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">4.5.2.2. API 接口</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-priority-queue-%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">4.5.3.</span> <span class="toc-text">4.5.3. priority_queue(优先级队列)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">4.5.3.1.</span> <span class="toc-text">4.5.3.1. 什么是优先级队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-3-2-%E6%A0%87%E5%87%86%E5%BA%93%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.5.3.2.</span> <span class="toc-text">4.5.3.2. 标准库接口</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-String"><span class="toc-number">5.</span> <span class="toc-text">5. String</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-string-%E4%B8%8E-char-%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. string 与 char* 转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. API 接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. 底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA-string-%E5%A4%A7%E5%B0%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">空 string 大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-Type-Definitions-and-Static-Values"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.1. 数据类型( Type Definitions and Static Values)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Functor-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">6. Functor(仿函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BB%BF%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 什么是仿函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%88%86%E7%B1%BB"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. 可调用对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. 函数对象调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. 可调用对象包装器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E5%8F%AF%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%BB%91%E5%AE%9A%E5%99%A8"><span class="toc-number">6.6.</span> <span class="toc-text">6.6. 可调用对象绑定器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-Predefined-Function-Objects-%E9%A2%84%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="toc-number">6.7.</span> <span class="toc-text">6.7. Predefined Function Objects (预定义函数对象)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-8-%E5%85%B6%E5%AE%83"><span class="toc-number">6.8.</span> <span class="toc-text">6.8. 其它</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Algorithm"><span class="toc-number">7.</span> <span class="toc-text">7. Algorithm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Heap-%E5%A0%86"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. Heap(堆)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-API-%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. API 接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Adaptor-%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.</span> <span class="toc-text">8. Adaptor(适配器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. 什么是适配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%88%86%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">8.2. 分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-1-function-adaptor-%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1. function adaptor(函数适配器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-2-bind-adaptor-%E7%BB%91%E5%AE%9A%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2. bind adaptor(绑定适配器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-3-composite-adaptor-%E7%BB%84%E5%90%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.3.</span> <span class="toc-text">8.2.3. composite adaptor(组合适配器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-4-pointer-adaptor-%E6%8C%87%E9%92%88%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.4.</span> <span class="toc-text">8.2.4. pointer adaptor(指针适配器)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-5-member-function-adaptor-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%80%82%E9%85%8D%E5%99%A8"><span class="toc-number">8.2.5.</span> <span class="toc-text">8.2.5. member function adaptor(成员函数适配器)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Traits-%E8%90%83%E5%8F%96%E6%9C%BA"><span class="toc-number">9.</span> <span class="toc-text">9. Traits(萃取机)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-iterator-traits"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. iterator_traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-type-traits"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. type traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-char-traits"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. char traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-allocator-traits"><span class="toc-number">9.4.</span> <span class="toc-text">9.4. allocator traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-pointer-traits"><span class="toc-number">9.5.</span> <span class="toc-text">9.5. pointer traits</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-array-traits"><span class="toc-number">9.6.</span> <span class="toc-text">9.6. array traits</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Iterators-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.</span> <span class="toc-text">10. Iterators(迭代器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">10.1.</span> <span class="toc-text">10.1. 什么是迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-2-%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4"><span class="toc-number">10.2.</span> <span class="toc-text">10.2. 迭代器设计思维</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-3-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">10.3.</span> <span class="toc-text">10.3. 基本操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-4-%E8%BF%AD%E4%BB%A3%E8%BF%90%E7%AE%97"><span class="toc-number">10.4.</span> <span class="toc-text">10.4. 迭代运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-5-iterator%E9%81%B5%E5%BE%AA%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">10.5.</span> <span class="toc-text">10.5. iterator遵循的原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-6-Iterator-%E5%88%86%E7%B1%BB"><span class="toc-number">10.6.</span> <span class="toc-text">10.6. Iterator 分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-7-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">10.7.</span> <span class="toc-text">10.7. 迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Allocators-%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">11.</span> <span class="toc-text">11. Allocators(分配器)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. 什么是分配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-%E9%BB%98%E8%AE%A4%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. 默认分配器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-3-Allocator-%E6%A0%87%E5%87%86%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.3.</span> <span class="toc-text">11.3. Allocator 标准接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Reference"><span class="toc-number">12.</span> <span class="toc-text">12. Reference</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/CONVENTION/" title="CONVENTION">CONVENTION</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/README/" title="README">README</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/STARCHARTS/" title="STARCHARTS">STARCHARTS</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/AIGC/" title="AIGC">AIGC</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/ollama/" title="ollama">ollama</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Jeep</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>