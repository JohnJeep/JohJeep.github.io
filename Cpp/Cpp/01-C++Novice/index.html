<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>01-C++Novice | Leaning Computer Science Journey</title><meta name="author" content="John Jeep"><meta name="copyright" content="John Jeep"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. concept(概念)c++ 是一种倾向于系统编程的通用编程语言，在 C 语言的基础上发展起来的，支持的特性。  supports data abstraction supports object-oriented programming supports generic programming   Compile-Time (constexpr and template metapro">
<meta property="og:type" content="article">
<meta property="og:title" content="01-C++Novice">
<meta property="og:url" content="https://johnjeep.github.io/Cpp/Cpp/01-C++Novice/index.html">
<meta property="og:site_name" content="Leaning Computer Science Journey">
<meta property="og:description" content="1. concept(概念)c++ 是一种倾向于系统编程的通用编程语言，在 C 语言的基础上发展起来的，支持的特性。  supports data abstraction supports object-oriented programming supports generic programming   Compile-Time (constexpr and template metapro">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://johnjeep.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-04T12:24:00.000Z">
<meta property="article:modified_time" content="2025-04-04T12:24:27.265Z">
<meta property="article:author" content="John Jeep">
<meta property="article:tag" content="cpp">
<meta property="article:tag" content="01-C++Novice">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://johnjeep.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "01-C++Novice",
  "url": "https://johnjeep.github.io/Cpp/Cpp/01-C++Novice/",
  "image": "https://johnjeep.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-04T12:24:00.000Z",
  "dateModified": "2025-04-04T12:24:27.265Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Jeep",
      "url": "https://johnjeep.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://johnjeep.github.io/Cpp/Cpp/01-C++Novice/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Jeep","link":"链接: ","source":"来源: Leaning Computer Science Journey","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '01-C++Novice',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">01-C++Novice</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">01-C++Novice</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T12:24:27.265Z" title="更新于 2025-04-04 20:24:27">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Cpp/">Cpp</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!--
 * @Author: JohnJeep
 * @Date: 2020-05-27 10:12:26
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-04-04 19:26:08
 * @Description: C++ 基础
 * Copyright (c) 2022 by johnjeep, All Rights Reserved. 
-->

<h1 id="1-concept-概念"><a href="#1-concept-概念" class="headerlink" title="1. concept(概念)"></a>1. concept(概念)</h1><p>c++ 是一种倾向于系统编程的通用编程语言，在 C 语言的基础上发展起来的，支持的特性。</p>
<ul>
<li>supports data abstraction</li>
<li>supports object-oriented programming</li>
<li>supports generic programming  </li>
<li>Compile-Time (constexpr and template metaprogramming)</li>
</ul>
<h1 id="2-c-basics-C-基础"><a href="#2-c-basics-C-基础" class="headerlink" title="2. c++ basics(C++基础)"></a>2. c++ basics(C++基础)</h1><ul>
<li><p>C 语言中，表达式的返回值是一个数值。C++ 中，表达式的返回值是变量的本身，可以作为左值，作为左值需要开辟一个内存空间。</p>
</li>
<li><p><code>endl</code> 与 <code>\n</code> 区别</p>
<ul>
<li><code>endl</code>：换行和清除缓冲区到输出屏幕上</li>
<li><code>\n</code>：仅仅只是换行</li>
</ul>
</li>
<li><p><code>float</code>：有效数字是 6~7 位</p>
</li>
<li><p><code>double</code>：有效数字是 15 位</p>
</li>
<li><p><code>char</code>：8 个 bit，占一个字节（byte）空间</p>
</li>
<li><p>取模场景</p>
<ul>
<li>取一个数的个位数</li>
<li>多少天是一个月的第几天</li>
</ul>
</li>
<li><p><code>&lt;&lt;</code> 左移运算符：右侧空位补 0</p>
</li>
<li><p><code>&gt;&gt;</code> 右移运算符：左侧空位补符号位，符号位正数部 0，符号位为负数补 1。</p>
</li>
<li><p><code>switch</code> 语句后的表达式只能为整型或字符类型。<code>break</code> 语句：执行循环体后，调出循环。可用于 <code>switch</code> 结构或者循环结构。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (expression)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="comment">/* constant-expression */</span>:</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p>continue：只能用于循环结构，调出循环。</p>
</li>
<li><p>计算数组大小：对基本类型（不包括 <code>String</code> 类型）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sizeof</span>(array_var) / <span class="built_in">sizeof</span>(array_type)</span><br><span class="line"></span><br><span class="line"><span class="built_in">sizeof</span>(nums) / <span class="built_in">sizeof</span>(<span class="type">int</span>) </span><br></pre></td></tr></table></figure>
</li>
<li><p>指针</p>
<ul>
<li>所有的指针都要初始化</li>
<li><code>int *ptr</code>  整型指针，结果是一个值</li>
<li><code>int *ptr  int*</code>：指向整型的指针，结果是一个地址</li>
<li><code>void* </code> 指针存放的是一个内存地址，地址的内容是什么类型不能确定</li>
</ul>
</li>
</ul>
<h1 id="3-namespace-命名空间"><a href="#3-namespace-命名空间" class="headerlink" title="3. namespace(命名空间)"></a>3. namespace(命名空间)</h1><p>C 中的命名空间</p>
<ul>
<li>只有一个全局的作用域，所有的全局标识符共用一个作用域。同名的标识符之间会发生冲突。</li>
</ul>
<p>C++的命名空间</p>
<ul>
<li>将全局的作用域分成不同的部分，不同命名空间的标识符可以同名而不会发生冲突。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用标准库中封装的内容。标准库中定义的所有名字都在命名空间 std 中</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std</span><br><span class="line">&#123;</span><br><span class="line">  .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>全局作用域也叫默认命名空间。</li>
<li>命名空间之间可以相互嵌套。</li>
<li><code>::</code> 叫作用域运算符。<br><br><code>std::out</code> 从标准库中输出读取的内容，即编译器从操作符左侧名字的作用域中去寻找右侧的名字。</li>
<li>一般有三种方式去实现命名空间<ul>
<li>全部打开标准库中的内容。<code>using namespace std;</code></li>
<li>只打开标准库的部分内容。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  cout &lt;&lt; ...;</span><br><span class="line">  std::cin &gt;&gt; ...;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在使用的时候根据需要打开<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; ...;</span><br><span class="line">  std::cin  &gt;&gt; ...;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用 <code>using</code> 定义别名与 <code>typedef</code> 的用法一样。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> uint64 = <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>C++编译器不支持使用 <code>typedef</code> 关键词为<strong>模板类</strong>设置别名，但是使用 <code>using</code> 的方式声明一个关键词却是允许的，只是这个是 C++11 标准才有的，如果在编译时不加上 <code>--std=c++11</code> 使用新的标准的话，编译器一样会报错。</p>
<ul>
<li>优美的命名空间名积累<ul>
<li>internal</li>
<li>metal</li>
</ul>
</li>
</ul>
<h1 id="4-header-file-头文件"><a href="#4-header-file-头文件" class="headerlink" title="4. header file(头文件)"></a>4. header file(头文件)</h1><p>头文件采用防御式声明 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __TEST_H</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>头文件名包含在尖括号 <code>&lt;&gt;</code> 中，则 C++ 编译器将在存储标准头文件的主机系统的文件系统中查找；但如果文件名包含在双引号 <code>&quot;&quot;</code> 中，则编译器将首先查找当前的工作目录或源代码目录（或其他目录，这取决于编译器）。</p>
<p>类的声明和实现时分开的。通常 <code>.h</code> 文件只作类的声明，<code>.cpp</code> 文件进行类的实现。</p>
<h1 id="5-reference-引用"><a href="#5-reference-引用" class="headerlink" title="5. reference(引用)"></a>5. reference(引用)</h1><h2 id="5-1-ordinary-reference-普通引用"><a href="#5-1-ordinary-reference-普通引用" class="headerlink" title="5.1. ordinary reference(普通引用)"></a>5.1. ordinary reference(普通引用)</h2><p>在 C++ 中采用 <code>&amp;</code> 符号表示引用，只是给对象起了一个别名。引用的功能主要是传递函数的参数和返回值。从使用者的角度，引用类似是一个别名，没有自己的内存空间，这是因为 C++为了实用性，隐藏了相关细节。实质上引用有自己的内存空间。</p>
<p>引用初始化</p>
<ul>
<li>引用被创建的同时必须被初始化，而指针则可以在任何时候被初始化。 一旦引用被初始化，就不能改变引用的关系，而指针则可以随时改变所指的对象。</li>
<li>单独定义引用时，必须要 <code>初始化</code>。</li>
<li>引用作为函数的参数声明时，<code>不</code> 需要进行初始化。</li>
<li>不能有 NULL 引用，引用必须与合法的存储单元关联，而指针则可以是NULL。</li>
</ul>
<p>引用使用时注意点</p>
<ul>
<li>传引用的效率比指针高，传递的直接是对象，而不是把对象复制。</li>
<li>函数内部的引用参数值可能会改变，一般需要加 <code>const</code> 解决。</li>
<li>不要返回局部变量的引用，全局变量和静态变量可以作为返回值的引用。 </li>
<li>C++编译器在编译时使用一个常量指针作为引用的内部实现。因此，引用占用的内存空间大小与指针占用空间大小相同。<code>type&amp; name &lt;==&gt; type* const name</code></li>
</ul>
<p>指针的引用 </p>
<ul>
<li>格式 <code>const int* &amp;a</code></li>
<li>指针的引用做函数参数</li>
<li>函数二级指针作为输出变量</li>
</ul>
<img src="./figures/reference.png">

<img src="./figures/reference-function.png">


<h2 id="5-2-lvalue-reference-左值引用"><a href="#5-2-lvalue-reference-左值引用" class="headerlink" title="5.2. lvalue reference(左值引用)"></a>5.2. lvalue reference(左值引用)</h2><p>左值就是一个能够被修改的变量。</p>
<ul>
<li><code>引用</code> 作为 <code>左值</code>时，返回的是变量的本身，是变量而不是值（value）。变量只能是全局变量或静态变量，不能是局部变量，否则会出现 <code>Segmentation fault</code>。</li>
<li>函数的返回值作为一个 <code>左值</code>时，应该返回的是一个引用<code>(reference)</code>。</li>
<li>左值表达式表示的是一个对象的身份。</li>
<li>变量表达式是一个左值，作用的时间比较长，右值的作用时间比较短暂。</li>
</ul>
<h2 id="5-3-rvalue-reference-右值引用"><a href="#5-3-rvalue-reference-右值引用" class="headerlink" title="5.3. rvalue reference(右值引用)"></a>5.3. rvalue reference(右值引用)</h2><p>何为右值引用？</p>
<ul>
<li>必须绑定到右值的引用，采用 <code>&amp;&amp;</code> 来获得右值引用，而不是 <code>&amp;</code> </li>
<li>右值表达式表示的是对象的值。</li>
<li>右值引用只能绑定到一个将要被销毁的对象，该对象没有其它的用户。</li>
</ul>
<p><code>std::move()</code></p>
<ul>
<li>显式的将左值转化为对应的右值引用类型。</li>
<li>使用 <code>move()</code> 函数时告诉编译器，处理左值时像右值一样去处理它；对左值进行赋值或销毁外，不再使用它。</li>
</ul>
<h2 id="5-4-const-reference-常量引用"><a href="#5-4-const-reference-常量引用" class="headerlink" title="5.4. const reference(常量引用)"></a>5.4. const reference(常量引用)</h2><p>让变量的引用拥有只读 (read-only) 的属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;y = x;   <span class="comment">// 不能通过y去修改x的值 </span></span><br></pre></td></tr></table></figure>

<p>初始化</p>
<ul>
<li>用变量初始化常引用。<code>int x = 10; const int &amp;y = x;</code></li>
<li>用自变量初始化常引用。<code>const int &amp;a = 100;</code> </li>
<li>使用常量引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为当前分配空间的别名。</li>
</ul>
<h1 id="6-function-函数"><a href="#6-function-函数" class="headerlink" title="6. function(函数)"></a>6. function(函数)</h1><p>C++ 对函数的检查更严格。C++ 支持 bool 类型：C++中的 <code>bool</code>，只占 1 个字节。</p>
<h2 id="6-1-inline-内联函数"><a href="#6-1-inline-内联函数" class="headerlink" title="6.1. inline(内联函数)"></a>6.1. inline(内联函数)</h2><p>函数定义时，加 <code>inline</code> 关键字，例如 <code>inline void func()&#123;&#125;</code>。内联函数的关键字 <code>inline</code> 与函数体的实现在一起，不需额外的声明。 </p>
<p>实现机制</p>
<ul>
<li>C++编译器直接将函数体插入函数调用的地方。</li>
</ul>
<p>什么时候可以用 <code>inline</code>？</p>
<ul>
<li>函数体不能过大。</li>
<li>函数声明必须在调用之前声明。</li>
<li>不能对函数进行取值地址操作。 </li>
<li>不能存在任何形式的循环语句（for、while）。</li>
<li>内联函数省去了普通函数调用时的压栈、跳转、返回操作。</li>
</ul>
<h2 id="6-2-function-parameter-函数参数"><a href="#6-2-function-parameter-函数参数" class="headerlink" title="6.2. function parameter(函数参数)"></a>6.2. function parameter(函数参数)</h2><p>默认参数</p>
<ul>
<li>函数的参数有一个默认的值。</li>
<li>函数带有参数列表，参数列表的右边必须有默认的值，左边可以不给默认参数赋值。</li>
</ul>
<p>占位参数</p>
<ul>
<li>只有函数类型声明，没有函数变量声明。<code>int func(int a, int b, int)</code></li>
</ul>
<h2 id="6-3-template-function-模板函数"><a href="#6-3-template-function-模板函数" class="headerlink" title="6.3. template function(模板函数)"></a>6.3. template function(模板函数)</h2><p>什么是模板函数？</p>
<blockquote>
<p>函数定义时不指定具体的数据类型，建立一个通用函数。函数调用时，根据实际的参数反推数据类型，即类型的参数化。</p>
</blockquote>
<h2 id="6-4-conversion-function-转换函数"><a href="#6-4-conversion-function-转换函数" class="headerlink" title="6.4. conversion function(转换函数)"></a>6.4. conversion function(转换函数)</h2><p>函数没有返回值，没有参数，函数的类型为需要转换的类型。通常转换函数中的内容都是不应该改变的，可以设置为 <code>const</code>。</p>
<img src="./figures/conversion-function.png">


<h2 id="6-5-functor-仿函数"><a href="#6-5-functor-仿函数" class="headerlink" title="6.5. functor(仿函数)"></a>6.5. functor(仿函数)</h2><p>什么是仿函数？</p>
<blockquote>
<p>一个 class 类中重载了函数调用操作运算符 <code>()</code>，任何一个东西能接受 <code>()</code> 操作运算符，这个东西就叫 <code>像函数</code> 或者叫 <code>仿函数</code>。</p>
</blockquote>
<img src="./figures/functor-like.png">

<p><font color=red>思考：</font>为什么 C++ 中要把 class 设计成 pointer(智能指针)和 function(仿函数)？</p>
<h1 id="7-Special-member-function-类中特别的成员函数"><a href="#7-Special-member-function-类中特别的成员函数" class="headerlink" title="7. Special member function (类中特别的成员函数)"></a>7. Special member function (类中特别的成员函数)</h1><h2 id="7-1-constructor-构造函数"><a href="#7-1-constructor-构造函数" class="headerlink" title="7.1. constructor(构造函数)"></a>7.1. constructor(构造函数)</h2><p>为什么要用构造函数？</p>
<ul>
<li>被用来初始化类的对象。  </li>
<li>类对象被创建时，编译器为对象(object)分配内存空间，并自动调用构造函数，完成成员的初始化</li>
</ul>
<p>构造函数特征 </p>
<ul>
<li>构造函数的 <code>函数名称</code> 与 <code>类的名称</code> 一样。</li>
<li><strong>函数没有返回值</strong></li>
<li>函数参数值<ul>
<li>创建的对象有默认值时，应传入创建对象的默认值。</li>
<li>创建的对象没有默认值时，编译器传入的默认值为 <code>0</code></li>
</ul>
</li>
</ul>
<p>构造函数注意点</p>
<ul>
<li>构造函数是一个 <code>成员函数</code>，函数内有一个 <code>this</code> 指针</li>
<li>构造函数的访问属性可以放在 <code>private</code> 中。在单例模式（singleton）中就采用这种用法。</li>
<li><code>构造函数</code> 与 <code>析构函数</code> 在类中声明了 ，必须要通过类的方法去实现，即声明了必须要用，否则编译时会报错。</li>
<li>多线程编程中，构造函数不能保证线程的安全。</li>
</ul>
<p>类中默认的构造函数</p>
<ul>
<li>默认无参数构造：当类中没有定义构造函数时，C++编译器会默认提供一个无参数构造函数，构造函数的函数体为空。</li>
<li>默认拷贝构造：当类中没有定义拷贝构造函数时，C++编译器会默认提供一个拷贝构造函数（浅拷贝），简单的进行成员变量的值拷贝操作。</li>
</ul>
<p>构造函数分类</p>
<ul>
<li><p>无参构造：一般为栈内存空间，自动释放内存空间。调用时不用 <code>加括号</code>。</p>
</li>
<li><p>带参数构造(重载了构造函数)</p>
<ul>
<li><p>一般为堆内存空间，需要使用delete释放内存空间；使用 <code>new</code> 关键字创建空间</p>
</li>
<li><p>一般需要初始化构造的参数</p>
</li>
<li><p>有默认值参数的构造函数，需要在类的声明中指定默认参数值，一般只能指定一次，在构造函数实现时不需要再给出默认值，否则会报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有参构造函数三种调用方法</span></span><br><span class="line"><span class="function">Test <span class="title">t1</span><span class="params">(<span class="number">10</span>)</span></span>;         <span class="comment">// 括号法</span></span><br><span class="line">Test t2 = t1;         <span class="comment">// 等号法</span></span><br><span class="line">Test t3 = <span class="built_in">Test</span>(<span class="number">30</span>);  <span class="comment">// 直接调用构造函数</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>拷贝构造</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个类</span></span><br><span class="line"><span class="function"><span class="keyword">class</span> <span class="title">String</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实例化一个对象</span></span><br><span class="line">String st_one;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line">String st_two = st_one;   <span class="comment">// 方法一：等号(=)是拷贝一个对象不是赋值运算</span></span><br><span class="line"><span class="function">String <span class="title">st_three</span><span class="params">(st_one)</span>   <span class="comment">// 方法二：初始化拷贝构造</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数在继承中的用法</p>
<blockquote>
<p>构造函数与父类的其它成员(成员变量和成员方法)不同，它不能被子类继承。因此，在创建子类对象时，为了初始化从父类中继承来的成员变量，编译器需要调用其父类的构造函数。如果子类的构造函数没有显示地调用父类的构造函数，则默认调用父类的无参构造函数。 </p>
</blockquote>
<ul>
<li>子类与父类均没有声明构造函数时，C++编译器会默认生成构造函数去调用。 </li>
<li>子类继承父类的方法，默认会调用父类的无参数构造函数，再调用子类的无参或有参构造函数。</li>
<li>当父类为有参构造函数时<ul>
<li>父类的有参构造函数有默认的值时，子类中不需要显式地调用父类的构造，C++编译器会默认的调用父类的有参构造函数。</li>
<li>父类的有参构造函数没有默认的值时，子类中需要显式地调用父类的构造<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Parent</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span>:<span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Child</span>(<span class="type">int</span> m, <span class="type">int</span> n):<span class="built_in">Parent</span>(a, b)     <span class="comment">// 显示的调用父类的构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>父类中既有无参默认构造又有带参默认构造函数时，子类继承父类时，需要子类显示的指定到底该调用哪一个构造函数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Initialization(初始化)</p>
<p>  类中成员的初始化</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;        <span class="comment">// 没有初始化，获得一个任意的值</span></span><br><span class="line">    string s;     <span class="comment">// 默认初始化为 empty string</span></span><br><span class="line">    <span class="type">int</span>* ptr;     <span class="comment">// 没有初始化，指向任意的地址</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Widget w;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a;        <span class="comment">// 初始化为 0</span></span><br><span class="line">    string s;     <span class="comment">// 默认初始化为 empty string</span></span><br><span class="line">    <span class="type">int</span>* ptr;     <span class="comment">// 初始化为 n</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Widget w&#123;&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Widget</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">10</span>;</span><br><span class="line">        s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> a;        </span><br><span class="line">    string s;     </span><br><span class="line">    <span class="type">int</span>* ptr;     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>构造函数中初始化，都是属于赋值操作（assignment operator）,</p>
<h2 id="7-2-copy-constructor-拷贝构造"><a href="#7-2-copy-constructor-拷贝构造" class="headerlink" title="7.2. copy constructor(拷贝构造)"></a>7.2. copy constructor(拷贝构造)</h2><ul>
<li>拷贝构造函数是由普通构造函数和赋值操作符共同实现的。</li>
<li>拷贝构造函数必须以 <code>引用(reference)</code>的形式传递(参数为引用值)。</li>
<li>拷贝构造函数使程序更有效率，因为它不用再构造一个对象的时候改变构造函数的参数列表</li>
<li>当某对象是按值传递时（无论是类的对象作为函数参数，还是作为函数返回值），编译器都会先建立一个此对象的临时拷贝，而在建立该临时拷贝时就会调用类的拷贝构造函数。</li>
</ul>
<hr>
<ul>
<li><p>浅拷贝（shallow copy）</p>
<ul>
<li><p>当类的对象发生复制过程的时候，类的对象自己有资源（堆或者是其它系统资源），但复制过程中并未复制资源，只是改变了指针的指向，这种称为浅拷贝。</p>
</li>
<li><p>只是将类的成员值进行拷贝，类指针没有进行拷贝，两个指针同时指向一块内存空间。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有做任何的说明，C++编译默认使用的是浅拷贝。</span></span><br><span class="line">People obj_2 = obj_1;   将obj_1对象的内容拷贝到obj_2对象中，不是拷贝的指针。</span><br></pre></td></tr></table></figure></li>
<li><p>浅拷贝完成后，在释放资源的时候会产生资源归属不清的情况，导致一个指针指向已经被删除的内存空间，使程序运行出错。即销毁对象时，两个对象的析构函数将对同一个内存空间释放两次。</p>
</li>
</ul>
</li>
<li><p>深拷贝（deep copy）</p>
<ul>
<li>当类的对象发生复制过程的时候，类的对象自己有资源（堆或者是其它系统资源），但拷贝过程中复制了资源，这种将一个对象的资源完整的拷贝到另一个对象的过程，称为深拷贝。</li>
<li>不仅拷贝了类的 <code>成员变量值</code>，还拷贝了类的指针，两个指针指向两块不同的内存空间。</li>
</ul>
</li>
<li><p>什么时候用深拷贝和浅拷贝？</p>
<ul>
<li>类中没有自定义拷贝构造函数时，编译器会默认调用浅拷贝，完成成员的复制。</li>
<li>当类的成员中没有指针时，浅拷贝是可行的。</li>
<li>当类的成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，因此必须要用深拷贝。</li>
</ul>
</li>
</ul>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/alantu2018/p/8459250.html">c++拷贝构造函数详解</a></li>
</ul>
<h2 id="7-3-copy-assignment-operator-拷贝赋值"><a href="#7-3-copy-assignment-operator-拷贝赋值" class="headerlink" title="7.3. copy assignment operator(拷贝赋值)"></a>7.3. copy assignment operator(拷贝赋值)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对象s1拷贝赋值给对象s2，内部处理过程分3步：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* m_data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* cstr = <span class="number">0</span>) &#123;&#125;             <span class="comment">// 带有初始值的构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; str) &#123;&#125;              <span class="comment">// 深拷贝构造</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str);     <span class="comment">// 操作符重载，拷贝赋值</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">getStr</span><span class="params">()</span> <span class="type">const</span> </span>&#123;<span class="keyword">return</span> m_data;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyString&amp; MyString::<span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; str) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;str)   <span class="comment">// 进行自我赋值检测</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span>[] m_data;                           <span class="comment">// 1、释放原先数据m_data的内存空间</span></span><br><span class="line">  m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str.m_data) + <span class="number">1</span>]; <span class="comment">// 2、重新给m_data 分配内存空间</span></span><br><span class="line">  <span class="built_in">strcpy</span>(m_data, str.m_data);                <span class="comment">// 3、执行拷贝操作</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在拷贝之前需要进行自我赋值检测。即自己把值赋给自己，保证在执行第二步操作时，指针有指向的位置。</span></span><br><span class="line"><span class="comment">// 若不进行自我检测步骤，先释放原先数据m_data的内存空间后，此时指针m_data没有一个确定的指向，</span></span><br><span class="line"><span class="comment">// 不能重新分配内存空间，导致程序出错。</span></span><br></pre></td></tr></table></figure>


<h2 id="7-4-Move-constructor-移动构造"><a href="#7-4-Move-constructor-移动构造" class="headerlink" title="7.4. Move constructor(移动构造)"></a>7.4. Move constructor(移动构造)</h2><h2 id="7-5-Move-assignment-operator-移动赋值操作"><a href="#7-5-Move-assignment-operator-移动赋值操作" class="headerlink" title="7.5. Move assignment operator(移动赋值操作)"></a>7.5. Move assignment operator(移动赋值操作)</h2><h2 id="7-6-destructor-析构函数"><a href="#7-6-destructor-析构函数" class="headerlink" title="7.6. destructor(析构函数)"></a>7.6. destructor(析构函数)</h2><p>析构函数就是一个函数，只不过这个函数的函数名称与类名一样，在函数名之前还多了一个波浪号 <code>~</code>。例如：<code>string::~string()</code>，就是 <code>string</code> 类的析构函数。</p>
<p>析构函数作用：类的对象离开作用域后释放对象使用的资源，在类死亡之前的前一刻调用，用于清除类中的资源（比如：释放内存）。</p>
<p>析构函数注意点：</p>
<ol>
<li>一个类只能有一个析构函数，若有多个类则有多个析构函数。如果没有显式的定义析构函数，编译器会自动生成一个默认的析构函数。</li>
<li>析构函数不能 <code>重载</code>。每有一次构造函数的调用就会有一次析构函数的调用。</li>
<li>只有当一切的构造动作都完成时，析构函数才有可能会被调用。因为在构造函数中可能会抛出异常从而导致程序结束。</li>
</ol>
<p>什么时候析构函数被调用？</p>
<ol>
<li>对象生命周期结束，对象被销毁时，编译器自动调用析构函数。</li>
<li>手动去释放内存，用 <code>delete</code> 关键字时，先执行 delete，释放掉在堆上申请的内存后，再调用析构析构函数。</li>
</ol>
<h1 id="8-empty-class"><a href="#8-empty-class" class="headerlink" title="8. empty class"></a>8. empty class</h1><p>若 C++ 中一个 class 中什么也没有写，就是一个空的类（empty class），形如 <code>class Stu &#123;&#125;;</code> 这样。程序编译时，C++ 编译器会给这个 <code>empty class</code> 提供默认构造函数（constructor）、析构函数（destructor）、拷贝构造函数（copy constructor）、拷贝赋值函数（copy assignment），并且这些函数的默认属性都是 <code>public</code> 且内联（ <code>inline</code>）。</p>
<ul>
<li><p>思考：为什么 C++ 中一个空类的大小为 <code>1byte</code> ？</p>
<p>空类中没有函数和数据成员，但可以实例化类；一个类能被实例化，编译器就要给他分配空间，来指示类实例化的地址，通常编译器分配为 1 个字节（char类型），这样分配同时也保证了 空类占用的空间最小。</p>
</li>
</ul>
<p>通常情况下，编译器生成一些函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">     <span class="built_in">Widget</span>();                                  <span class="comment">// Default constructor</span></span><br><span class="line">     <span class="built_in">Widget</span>(Widget <span class="type">const</span>&amp;);                     <span class="comment">// copy constructor</span></span><br><span class="line">      Widget&amp; <span class="keyword">operator</span>= (Widget <span class="type">const</span>&amp;);         <span class="comment">// Copy assignment operator</span></span><br><span class="line">     <span class="built_in">Widget</span>(Widget&amp;&amp; ) <span class="keyword">noexcept</span>;                <span class="comment">// Move constructor</span></span><br><span class="line">     Widget&amp; <span class="keyword">operator</span>= (Widget&amp;&amp;) noexcpet;     <span class="comment">// Move asignment operator</span></span><br><span class="line">     ~<span class="built_in">Widget</span>();                                 <span class="comment">// destructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="9-class-object-class-pointer"><a href="#9-class-object-class-pointer" class="headerlink" title="9. class object &amp;&amp; class pointer"></a>9. class object &amp;&amp; class pointer</h1><p>类对象与类指针的区别</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>类对象<ul>
<li>格式：<code>Stu s1;</code></li>
<li>定义之后就已经为 <code>s1</code> 这个对象在栈上分配了内存</li>
</ul>
</li>
<li>类指针<ul>
<li>格式：<code>Stu *s2 = new Stu;</code></li>
<li>定义 <code>*s2</code> 的时候没有分配内存，只有执行 <code>new</code> 后才会在堆上分配内存，是个永久的变量，需要用 <code>delete</code> 关键字手动去释放它。</li>
</ul>
</li>
</ul>
<h1 id="10-new-delete"><a href="#10-new-delete" class="headerlink" title="10. new &amp;&amp; delete"></a>10. new &amp;&amp; delete</h1><p>windows 下内存显示总是 <code>16</code> 的倍数，若果不是 16 的倍数，则填充为最靠近 16 的倍数的大小。 </p>
<p><code>new</code> 动态分配内存 </p>
<ul>
<li><p>先分配 memory，再调用构造函数 </p>
</li>
<li><p>new 创建一维动态数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通类型</span></span><br><span class="line">根据哪种数据类型来分配内存？根据数据类型来确定分配多少内存？找到这样的内存，并返回其地址。</span><br><span class="line">格式：typeName* pointer_name = <span class="keyword">new</span> typeName </span><br><span class="line">例如：<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"></span><br><span class="line">指针 p 指向的内存没有名称，那么要如何称呼它呢？我们说指针 p 指向一个数据对象， 这里的“对象”不是“面向对象编程”中的对象， 而是一种“东西”，它指的是为数据项分配的内存块。 </span><br><span class="line">数据对象：可以是复杂的结构类型，也可以是基本类型。</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一维数组</span></span><br><span class="line">typeName* pointer_name = <span class="keyword">new</span> typeName[num_elements];</span><br><span class="line">例如：<span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">注意：将数组的元素类型和元素数目告诉<span class="keyword">new</span>即可。 必须在类型名后加上方括号， 其中包含元素数目。<span class="keyword">new</span>运算符返回第一个元素的地址。</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建二维数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">格式：<span class="built_in">typeName</span> (*ptr)[col_num] = <span class="keyword">new</span> typeName[row_num][col_num];</span><br><span class="line">例子：<span class="built_in">int</span> (*ptr)[<span class="number">2</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure></li>
<li><p>创建对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Airplane</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Airplane *ap = <span class="keyword">new</span> Airplane;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><code>delete</code> 释放内存，与 new 配对使用。</p>
<ul>
<li>先调用析构函数，再释放 memory  </li>
<li>注意<ul>
<li>不要使用 delete 释放同一个内存块两次。</li>
<li>不是用 new 分配的动态内存空间，不能用 delete 释放</li>
<li>对空指针使用 delete 是安全的。</li>
<li>采用 <code>array new</code> 的方式创建一块内存空间，则一定要采用 <code> array delete</code> 方式去释放内存，否则在涉及指针的时候可能会导致内存泄漏。泄漏的并不是整个分配的内存空间，而是分配的空间中数组没有被释放的部分。</li>
<li>不配对地使用 new 和 delete，将发生内存泄漏(memory leak)，被分配的内存再也无法使用了，如果内存泄漏严重，则程序将由于不断寻找更多内存而终止。</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p>class member operator new()</p>
<img src="./figures/placement-new-delete-1.png">
<img src="./figures/placement-new-delete-2.png">
<img src="./figures/placement-new-delete-3.png">


</li>
<li><p>标准库中使用 <code>placement arguments new</code> 的例子 <br></p>
<img src="./figures/basic-string-new.png"></li>
</ul>
<h1 id="11-overload-重载"><a href="#11-overload-重载" class="headerlink" title="11. overload(重载)"></a>11. overload(重载)</h1><p>函数重载是指函数名相同，参数表列个数或顺序、类型不同的函数。注意：不能靠函数返回类型来判断，因为函数的返回值不是判断函数重载的标准。</p>
<p>函数重载的特点</p>
<ul>
<li>在同一个作用域中（C++中构造函数也可以重载）。</li>
<li>函数名字相同。</li>
<li>参数不同。</li>
<li>virtual 关键字可有可无。</li>
<li>返回值可以不同。</li>
<li>子类无法重载父类的函数。如果子类与父类的函数名称相同，则发生函数名称覆盖，不会发生函数重载。若想在子类和父类中分别调用具有相同名称的函数，则需要使用域分符号 <code>::</code></li>
<li>当子类中没有与父类相同参数的函数，只有名称相同的函数时，而子类去调用父类中重载的函数，则 C++ 编译器会将子类中有相同函数名称的函数去覆盖掉父类中相同名称的函数，从而将当前子类调用父类的函数当做子类中一个新的重载函数，但是编译器发现子类中并没有该函数的重载，因此会报错。</li>
</ul>
<p><strong>函数重载底层实现原理</strong>：编译器在编译时，根据函数的参数列表进行重命名。</p>
<h1 id="12-override-重写"><a href="#12-override-重写" class="headerlink" title="12. override(重写)"></a>12. override(重写)</h1><p>重写（也称为覆盖 override）是指派生类重新定义基类的虚函数。必须发生在子类与父类之间，并且父类与子类的函数具有完全相同的原型。使用 <code>virtual</code> 关键字声明后，能够产生多态，没有使用 <code>virtual</code> 关键字，只能叫重定义，不叫虚函数重写。</p>
<ul>
<li>不在同一个作用域，分别位于派生类与基类。</li>
<li>函数名字相同。</li>
<li>参数相同。</li>
<li>基类函数必须有 <code>virtual</code> 关键字，不能有 <code>static</code>。</li>
<li>返回值相同，否则会报错。</li>
<li>重写函数的访问修饰符可以不同。若基类中函数的修饰符是 <code>private</code>，派生类中重写的函数可以是 <code>public</code>，<code>protected</code>。</li>
</ul>
<p>
<font color=red> 
    重载与重写的区别</br>
1. 作用域不同：重载是在同一区域，子类无法重载父类，父类同名函数的将被覆盖，重写 是在父类与子类之间。</br>
2. 重载是静态多态性，在编译期间确定执行的函数或运算符。</br>
3. 重写是动态多态性，运行期间确定执行的函数，根据对象的实际类型调用相应的函数。</br>
</font>
</p>


<h1 id="13-const"><a href="#13-const" class="headerlink" title="13. const"></a>13. const</h1><ul>
<li>C 语言中，<code>const</code> 是只读的变量，有自己的存储空间。</li>
<li>C++ 中，<code>const</code> 可能分配存储空间，也可能不分配存储空间。<ul>
<li>当 <code>const</code> 作为全局变量，并在其它的文件中到调用时，会分配存储空间。</li>
<li>采用 <code>&amp;</code> 地址运算符去取 <code>const</code> 变量的地址时，会分配存储空间。</li>
</ul>
</li>
<li>加 <code>const</code> 后，不会改变数据的内容，不加<code>const</code>，则会改变数据的内容，一般数据的内容定义在 <code>private</code>中。</li>
</ul>
<p><code>const</code> 放在函数声明前表明函数的 <code>返回值是 const 类型</code>，不能修改。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义 <code>const</code> 成员函数时，把 <code>const</code> 关键字放在函数的参数表和函数体之间作用：表用该函数的数据成员不能被改变，<code>const</code> 修饰的是 <code>this</code> 指针指向的内存空间。如果在编写 <code>const</code> 成员函数时，不慎修改了数据成员，或者调用了其它非 <code>const</code> 成员函数，编译器则将报错。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不加const时，C++编译器简单编译等价为，不允许我们手动去改变this指针，否则会编译器会报错</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">(Complex* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在编写代码时，隐藏了this指针，不用书写；但实际上C++编译器已经帮我们做好了this指针的处理，加const后，上面的成员函数等价于下面的函数</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">real</span><span class="params">(<span class="type">const</span> Complex* <span class="type">const</span> <span class="keyword">this</span>, <span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<font color="red"> 
注意：void test() const {}; 这样定义的函数只能作为类的成员函数，不能作为一个全局的函数，即非类的外部这样使用，编译器会报错。
</font>

<p>在类中采用 <code>const</code>修饰函数，需要在类调用时必须加 <code>const</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definition</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">class</span> <span class="title class_">complex</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用：</span></span><br><span class="line"><span class="function"><span class="type">const</span> complex <span class="title">fx</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>const</code> 对象只能调用 <code>const</code> 成员函数，<code>const</code> 类对象成员的数据在类对象的生命周期内不能改变。</li>
<li><code>const</code> 成员函数是对 <code>const</code> 对象的限制；<code>const</code> 成员函数只能读类对象成员的数据，不能修改类对象成员的数据。</li>
</ul>
<img src="./figures/const.png">

<p>Tips：<code>const</code> 常量与 <code>宏定义</code> 用法比较</p>
<p>（1）编译器处理方式不同。</p>
<p><code>宏定义（#define）</code> 是在 <code>预处理</code> 阶段展开的，仅仅只是单纯的文本替换，不做计算，不做表达式求解，不能对宏定义进行调试，生命周期结束在编译时期；而 <code>const常量</code> 是在程序运行阶使用的，类似于一个只读的数据。</p>
<p>（2）类型和安全检查不同。</p>
<p> <code>const常量</code> 有具体的数据类型，在编译阶段提供作用域检查和类型检查；而 <code>宏定义</code> 没有类型，不做任何类型检查，仅仅是展开。</p>
<p>（3）定义域不同。</p>
<ul>
<li>宏定义可以通过 <code>#undef</code> 来使之前的宏定义失效</li>
<li>const 常量定义后将在定义域内永久有效。const 不能重定义，而 <code>#define</code> 可以通过 <code>#undef</code> 取消某个符号的定义，再重新定义。</li>
</ul>
<p>（4）存储方式不同。</p>
<p><code>宏定义</code> 仅仅是展开，有多少地方使用，就展开多少次，<strong>不会分配内存</strong>；<code>const常量</code> 可以在堆或栈中分配内存。</p>
<p>（5）<code>const</code>  可以节省空间，避免不必要的内存分配。</p>
<p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象 <code>#define</code> 一样给出的是立即数，所以，<code>const</code> 定义的常量在程序运行过程中只有一份拷贝（因为是全局的只读变量，存在静态区），而 <code>#define</code>定 义的常量在内存中有若干个拷贝，每使用一次宏就拷贝一次。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159       <span class="comment">// 常量宏，作用域为全局</span></span></span><br><span class="line"><span class="type">const</span> doulbe Pi=<span class="number">3.14159</span>; <span class="comment">// 此时并未将Pi放入ROM中</span></span><br><span class="line"><span class="type">double</span> i=Pi;             <span class="comment">// 调用 const 常量，此时为Pi分配内存，以后不再分配 </span></span><br><span class="line"><span class="type">double</span> I=PI;             <span class="comment">// 调用宏，编译期间进行宏替换，分配内存 </span></span><br><span class="line"><span class="type">double</span> j=Pi;             <span class="comment">// 调用 const 常量，没有内存分配 </span></span><br><span class="line"><span class="type">double</span> J=PI;             <span class="comment">// 调用宏，再进行宏替换，又一次分配内存</span></span><br></pre></td></tr></table></figure>

<p>（6） 提高了效率。 </p>
<p>编译器通常不为普通 <code>const常量</code> 分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率也很高。</p>
<h1 id="14-static"><a href="#14-static" class="headerlink" title="14. static"></a>14. static</h1><p><code>static</code> 成员定义</p>
<ul>
<li>一个 <code>static</code> 数据成员只能被定义一次。<code>static</code> 数据成员类似于全局变量，定义在任何的函数之外，一旦被定义，就一直存在与程序的<strong>整个生命周期内</strong>。</li>
<li>既可以在类的外部定义又可以在类的内部定义 <code>static</code> 成员，但是在类的外部定义时，不能重复 <code>static</code> 关键字，<code>static</code> 只出现在类的内部。</li>
</ul>
<p><code>static</code> 成员初始化</p>
<ul>
<li>若在类的内部提供了一个初始值，则在成员的定义时，不能再赋初值了。</li>
<li>不能在类的内部初始化静态成员，必须在类的外部初始化每个静态成员。</li>
<li>不能在构造函数或初始化列表中初始化静态成员。</li>
</ul>
<font color=red>
static 修饰的成员函数是属于 class 本身，在类加载的时候就会分配内存，可以通过类名直接去访问；而非 static 修饰的成员函数是属于 类的对象，只有在类的对象产生（创建类的实例）时才会分配内存，然后通过类的对象（实例）去访问。
</font>

<p>非静态成员初始化</p>
<ul>
<li><code>const</code> 类型的成员变量只能在初始化列表中初始化。</li>
<li>非 <code>const</code> 类型的成员变量可以在构造函数或初始化列表中初始化。</li>
</ul>
<p>继承中的 <code>static</code></p>
<ul>
<li>需要在类的外部进行初始化，并且C++编译器在外部初始化的同时还给变量分配内存空间，只有在使用时才分配内存空间，不调用不分配内存空间。</li>
</ul>
<p>类模板中的 <code>static</code></p>
<ul>
<li>每个类模板中都有自己的类模板 <code>static</code> 数据成员副本。</li>
<li>与非类模板的 <code>static</code> 数据成员一样，类模板中的 <code>static</code> 数据成员也需要进行<strong>定义</strong>和<strong>初始化</strong>。</li>
</ul>
<p><code>static</code> 成员与非 <code>static</code> 成员的区别?</p>
<ul>
<li>一个类的成员变量为 <code>static</code> 成员变量时，这个类中无论有多少个对象被创建，这些对象都共享这个 <code>static</code> 成员；即<strong>静态成员独立于任何的对象</strong>。</li>
<li>静态成员可以作为默认的参数，而非静态成员不能作为默认的参数，因为它本身的值属于对象的一部分。</li>
</ul>
<p><strong>为什么要用 static 成员函数？</strong></p>
<ol>
<li>由于没有 <code>this</code> 指针，可以把某些系统 API 的回调函数以静态函数的形式封装到类的内部。因为系统 API 的回调函数通常都是那种非成员函数，没有 <code>this</code> 指针的。比如你可以在类的内部写一个线程函数供 CreateThread 创建线程用，如果没有静态函数，那么这种回调函数就必须定义成 全局函数（非静态成员函数指针无法转换成全局函数指针），从而影响了OOP的“封装性”。</li>
<li>封装某些算法，比如数学函数，如 ln，sin，tan等等，这些函数本就没必要属于任何一个对象，所以从类上调用感觉更好，比如定义一个数学函数类Math，调用Math::sin(3.14);如果非要用非静态函数，那就必须：<code>Math math;math.sin(3.14); </code>行是行，只是不爽：就为了一个根本无状态存储可言的数学函数还要引入一次对象的构造和一次对象的析构，当然不爽。而且既然有了对象，说不得你还得小心翼翼的定义拷贝构造函数、拷贝赋值运算符等等，对于一些纯算法的东西显然是不合适的。</li>
</ol>
<p>静态对象（static object）：在作用域（scope）结束后，生命周期还存在，即没有结束，一直到整个程序结束了，它的生命周期也就结束了。</p>
<ul>
<li>静态的函数没有 <code>this</code> pointer，只能去处理静态的数据<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如何去调用？ </span><br><span class="line"></span><br><span class="line"><span class="number">1</span>、使用 object 调用。Account a.<span class="built_in">state</span>(<span class="number">10</span>);</span><br><span class="line"><span class="number">2</span>、通过 <span class="keyword">class</span> <span class="title class_">name</span> 来调用。Account::<span class="built_in">state</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>全局对象（global object）：整个程序结束了，它的生命周期也就结束了。</p>
<h1 id="15-this"><a href="#15-this" class="headerlink" title="15. this"></a>15. this</h1><ul>
<li>C++中的成员函数和成员变量是分开存储的。</li>
<li>什么叫成员函数：在类（class）中声明的函数。</li>
<li>什么叫非成员函数：没有在类（class）中声明的函数，非成员函数也叫全局函数。</li>
</ul>
<p>什么是 <code>this</code>?</p>
<p><code>this</code> 是C++中的一个关键字，是一个指针（pointer）。在面向对象中，哪个对象调用非静态成员函数，<code>this</code> 指针就指向哪个对象。静态成员函数中不包含 <code>this</code> 指针，非静态成员函数中包含 <code>this</code> 指针。<br><img src="./figures/this.png"></p>
<p>成员函数中 <code>const</code> 修饰的是谁？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TT</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  ......</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由C++面向对象模型知，上面的函数等价于</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(TT *<span class="keyword">this</span>, <span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 修饰的是this指针指向的内存空间。</span></span><br></pre></td></tr></table></figure>

<p>类名后直接加括号，表示是一个临时对象(local object)。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主要放置函数</span></span><br><span class="line">    ........</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 定义数据</span></span><br><span class="line">    ........</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用临时对象</span></span><br><span class="line"><span class="built_in">Complex</span>();</span><br></pre></td></tr></table></figure>

<p>匿名对象什么时候留下？什么时候被析构？</p>
<ul>
<li>用匿名对象初始化一个同类型的对象，则匿名对象转化为有名字的对象。</li>
<li>用匿名对象赋值给另外一个对象，则匿名对象被析构。</li>
</ul>
<h1 id="16-mutable"><a href="#16-mutable" class="headerlink" title="16. mutable"></a>16. mutable</h1><h2 id="16-1-mutable是什么？"><a href="#16-1-mutable是什么？" class="headerlink" title="16.1. mutable是什么？"></a>16.1. mutable是什么？</h2><p>mutable的中文译为 “可变的，易变的”，是 constant（即 C++ 中的 const ）的反义词。C++ 中为了突破 const 的限制而采用的，被 mutable 修饰的变量将永远处于可变的状态。</p>
<h2 id="16-2-为什么要用mutable？"><a href="#16-2-为什么要用mutable？" class="headerlink" title="16.2. 为什么要用mutable？"></a>16.2. 为什么要用mutable？</h2><ul>
<li>我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成 const 的。但是，有些时候，我们需要在 const 的函数里面修改一些跟类状态无关的数据成员，那么这个数据成员就应该被 mutable 来修饰。</li>
<li>mutable 常用于指定不影响类的外部可观察状态的成员（通常用于互斥体[mutexes]、记忆缓存 [memo caches]、惰性求值 [lazy evaluation]和访问指令 [access instrumentation] 等）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadsafeCounter</span> &#123;</span><br><span class="line"><span class="keyword">mutable</span> std::mutex m; <span class="comment">// mutable 和 mutex 用在一起情况</span></span><br><span class="line"><span class="type">int</span> data = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">    ++data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h2 id="16-3-使用-mutable-的注意事项"><a href="#16-3-使用-mutable-的注意事项" class="headerlink" title="16.3. 使用 mutable 的注意事项"></a>16.3. 使用 mutable 的注意事项</h2><p>mutable只能作用于类的非静态和非常量数据成员。mutable不能修饰static数据成员，因为static数据成员存储在Data段或BSS段，属于类，不属于类对象，因此类的static数据成员不需要 mutable 的修饰。但常对象和常函数可以对其任意地修改，对于常对象的数据成员一般不可以被修改，若想修改，则需要 mutable 的修饰。</p>
<p>在一个类中，应尽量或者不用 mutable，大量使用 mutable表示程序设计存在缺陷。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="keyword">mutable</span> <span class="type">int</span> getNum;             <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">mutable</span> <span class="type">const</span> <span class="type">int</span> test;         <span class="comment">// 编译出错</span></span><br><span class="line"><span class="comment">//mutable static int static1;   // 编译出错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="16-4-常函数"><a href="#16-4-常函数" class="headerlink" title="16.4. 常函数"></a>16.4. 常函数</h2><ul>
<li>什么是常函数？<br>常函数就是带 <code>const</code> 修饰的函数。</li>
<li>为什么要有常函数这个概念？<br>为了封装的良好性，有时我们用到的一些函数并不需要我们去改变类中的参数和成员变量，仅仅只是为了显示和输出的作用，因此才引进常函数。</li>
</ul>
<p>参考</p>
<ul>
<li>cpp reference官网解释mutable关键字: <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/cv">https://en.cppreference.com/w/cpp/language/cv</a></li>
<li>C++ mutable 的用法: <a target="_blank" rel="noopener" href="https://blog.csdn.net/K346K346/article/details/48030597">https://blog.csdn.net/K346K346/article/details/48030597</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/starlee/article/details/1430387?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control">C++中的mutable关键字</a></li>
</ul>
<h1 id="17-pass-by-value-pass-by-reference"><a href="#17-pass-by-value-pass-by-reference" class="headerlink" title="17. pass by value &amp;&amp; pass by reference"></a>17. pass by value &amp;&amp; pass by reference</h1><p>参数传递与返回值传递的区别</p>
<ul>
<li>传值(pass by value)是将整个的数据传递给调用者</li>
<li>传引用(pass by reference)本质是 <code>传指针</code>。<ul>
<li>采用一个 <code>&amp;</code> 符号表示。</li>
<li>希望调用者对传递的数据不能进行修改，在数据前加 <code>const</code> 限制。</li>
</ul>
</li>
<li>参数传递时：在能使用传reference的前提下，一般优先使用 <code>传引用</code> 而尽量少使用传值，并不是必须的。<code>传引用</code> 的速度比 <code>传值</code> 速度快。</li>
<li>函数返回 <code>值传递</code> 时：在能使用传reference的前提下，一般优先使用 <code>传引用</code> 而尽量少使用传值，并不是必须的。 </li>
<li>什么情况下不能使用 <code>引用传递（reference）</code>？<ul>
<li>当一个函数参数的变量为局部变量时，不能使用传引用。因为变量在函数结束时，变量就被销毁了，不存在，若再传递引用，调用者则不能得到值，会出错。</li>
</ul>
</li>
</ul>
<h1 id="18-friend-友元"><a href="#18-friend-友元" class="headerlink" title="18. friend(友元)"></a>18. friend(友元)</h1><p>友元函数</p>
<ul>
<li>在一个类中使用 <code>friend</code> 关键字时，不是当前类的成员函数可以去访问当前类的私有成员或 protect成员 数据。</li>
<li>重载运算符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 一般使用友元函数，其它的函数一般定义为 <code>类的成员函数</code>。</li>
<li><code>类模板</code> 中一般不要滥用友元函数，使用会很复杂，若将 <code>.h</code> 文件与 <code>.cpp</code> 文件分开实现，将会更加的复杂。</li>
</ul>
<p>同一个 class 中的各个对象(object) 互为友元。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义：</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">const</span> complex&amp; param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> param.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明对象:</span></span><br><span class="line">complex c1;</span><br><span class="line">complex c2;</span><br><span class="line">c<span class="number">2.f</span>unc(c1);   <span class="comment">// 采用友元的方式实现，通过对象参数访问私有成员数据</span></span><br></pre></td></tr></table></figure>

<p>友元类</p>
<ul>
<li>若B类是A类的友元类，则B类的所有成员函数都是A类的友元函数。</li>
<li>通常是为设计一种数据操作或类之间传递消息的辅助类。</li>
</ul>
<p>采用友元的优缺点</p>
<ul>
<li>优点<ul>
<li>可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务；</li>
<li>便于与其他不支持类概念的语言(如C语言、汇编等)进行混合编程；</li>
<li>通过使用友元函数重载可以更自然地使用C++语言的IO流库。</li>
</ul>
</li>
<li>缺点<ul>
<li>一个类将对其非公有成员的访问权限授予其他函数或者类，会破坏该类的封装性，降低该类的可靠性和可维护性。</li>
</ul>
</li>
</ul>
<h1 id="19-operator-overloading-操作运算符重载"><a href="#19-operator-overloading-操作运算符重载" class="headerlink" title="19. operator overloading(操作运算符重载)"></a>19. operator overloading(操作运算符重载)</h1><p>为什么要操作符重载？</p>
<p>普通的运算规则不能满足复杂的数据类型，像类<code>（class）</code>数据类型，需要编程人员自定义运算规则去实现。操作运算符重载的本质是个 <code>函数</code>。</p>
<p>操作符重载有两种实现的方式</p>
<ul>
<li>非成员函数方式，即全局函数（全域）的方式。<ul>
<li>通常与 <code>friend</code> 友元函数结合在一起使用。</li>
<li>应用场景：重载不同类之间的操作符。例如，重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>，编程人员自定义的类与C++编译器中 <code>ostream</code> 或 <code>istream</code> 类中的数据进行操作符重载。</li>
</ul>
</li>
<li>成员函数方式。<ul>
<li>函数的参数有一个隐藏的 <code>this</code> 指针，可以在函数里面去调用。</li>
</ul>
</li>
</ul>
<p>分析重载的步骤？</p>
<ul>
<li>确定函数名称</li>
<li>确定函数参数</li>
<li>根据业务，确定函数的返回值类型（是返回引用还是返回值？）以及函数体的实现。</li>
</ul>
<p><code>=</code> 赋值操作符重载。<code>=</code> 赋值操作只是将成员变量的值相应复制。若对象内包含指针，将造成不良后果：指针的值被丢弃了，但指针指向的内容并未释放。 </p>
<h1 id="20-smart-pointer-智能指针"><a href="#20-smart-pointer-智能指针" class="headerlink" title="20. smart pointer(智能指针)"></a>20. smart pointer(智能指针)</h1><p>自 C++11 起 C++ 标准库提供了两种类型的智能指针：<code>shared_ptr</code> 和 <code>unique_ptr</code>。而所有的智能指针都被封装在标准库的 <code>&lt;memory&gt;</code> 头文件中，要使用智能指针必须引入 <code>#include &lt;memory&gt;</code> 头文件。</p>
<h2 id="20-1-为什么要使用智能指针？"><a href="#20-1-为什么要使用智能指针？" class="headerlink" title="20.1. 为什么要使用智能指针？"></a>20.1. 为什么要使用智能指针？</h2><ul>
<li>动态分配内存时可能会出现一些问题<ul>
<li>忘记释放内存，会造成内存泄漏</li>
<li>有指针引用内存的情况下，释放了内存，产生引用非法内存的指针。</li>
</ul>
</li>
<li>需要更加安全的来管理动态内存。动态内存分配常用 <code>new</code> 和 <code>delete</code> 来分配内存。不使用 smart pointer 时，用动态内存分配时，可能会忘记 delete，导致内存泄漏；也可以使用异常捕获，但是会导致代码比较臃肿，不易阅读和维护。因此智能指针可以很好的解决这个问题。</li>
<li>负责自动释放所指向对象的内存资源。智能指针就是一个类（class），当智能对象超出了类的作用域时，类会自动调用析构函数，释放资源。</li>
</ul>
<h2 id="20-2-智能指针原理"><a href="#20-2-智能指针原理" class="headerlink" title="20.2. 智能指针原理"></a>20.2. 智能指针原理</h2><p>智能指针底层源码采用类模板（class template）来实现的，并不是一个简单的普通指针。可以用下面的模型来简单的表示<br><img src="./figures/smart-pointer.png"></p>
<h2 id="20-3-使用智能指针的优点"><a href="#20-3-使用智能指针的优点" class="headerlink" title="20.3. 使用智能指针的优点"></a>20.3. 使用智能指针的优点</h2><p>在函数结束时自动释放内存空间，不需要手动释放内存空间。</p>
<h2 id="20-4-auto-ptr"><a href="#20-4-auto-ptr" class="headerlink" title="20.4. auto_ptr"></a>20.4. auto_ptr</h2><ul>
<li>auto_ptr 智能指针采用所有权模式。</li>
<li>已被 C++11弃用，潜在内存崩溃问题。</li>
<li>存在非法的申请内存时，在编译期时可能通过，但程序在运行时可能会出错。</li>
</ul>
<h2 id="20-5-unique-ptr"><a href="#20-5-unique-ptr" class="headerlink" title="20.5. unique_ptr"></a>20.5. unique_ptr</h2><h3 id="20-5-1-概述"><a href="#20-5-1-概述" class="headerlink" title="20.5.1. 概述"></a>20.5.1. 概述</h3><p><code>unique_ptr</code> 实现的是一种独一无二拥有权 (exclusive ownership) 的概念。保证一个对象和其相应资源同一时间内只能被一个智能指针拥有(ownership)。当 unique_ptr 被销毁时，它所指向的对象也就自动销毁。</p>
<h3 id="20-5-2-为什么要用-unique-ptr"><a href="#20-5-2-为什么要用-unique-ptr" class="headerlink" title="20.5.2. 为什么要用 unique_ptr"></a>20.5.2. 为什么要用 unique_ptr</h3><p>它对于避免资源泄露，例如以 <code>new</code> 创建对象后因为发生异常而忘记调用 <code>delete</code>特别有用。 </p>
<h3 id="20-5-3-初始化"><a href="#20-5-3-初始化" class="headerlink" title="20.5.3. 初始化"></a>20.5.3. 初始化</h3><p>unique_ptr 智能指针提供三种方式进行对象的初始化。构造函数中初始化、移动构造函数中初始化 <code>std::move()</code>、采用 <code>reset()</code> 成员函数进行初始化。</p>
<ul>
<li><p><strong>unique_ptr 不允许执行 copy(拷贝) 和 assignment(赋值) 操作</strong>。但是可以用 <code>std::move()</code> 语义将对象的拥有权转移。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize a unique_ptr with a new object</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ClassA&gt; <span class="title">up1</span><span class="params">(<span class="keyword">new</span> ClassA)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy the unique_ptr</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ClassA&gt; <span class="title">up2</span><span class="params">(up1)</span></span>;  <span class="comment">// ERROR</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assign the unique_ptr, transfer ownership from up1 to up3</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;ClassA&gt; <span class="title">up3</span><span class="params">(std::move(up1))</span></span>;    <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当程序试图将一个 <code>unique_ptr</code> 赋值给另一个时，如果源 <code>unique_ptr</code> 是个临时右值，编译器允许这么做；如果源 <code>unique_ptr</code> 将存在一段时间，编译器将禁止这么做。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">pu1</span><span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello world&quot;</span>))</span></span>; </span><br><span class="line">unique_ptr&lt;string&gt; pu2; </span><br><span class="line">pu2 = pu1;                                      <span class="comment">// 不允许拷贝构造</span></span><br><span class="line">unique_ptr&lt;string&gt; pu3; </span><br><span class="line">pu3 = <span class="built_in">unique_ptr</span>&lt;string&gt;(<span class="keyword">new</span> <span class="built_in">string</span> (<span class="string">&quot;You&quot;</span>));   <span class="comment">// 允许</span></span><br></pre></td></tr></table></figure></li>
<li><p>想要执行 <code> pu2 = pu1;</code> 的操作，又要保证指针的安全。可以用C++有一个标准库函数 <code>std::move()</code>，让你能够将一个 <code>unique_ptr</code>赋给另一个。</p>
<blockquote>
<p>尽管转移所有权后 还是有可能出现原有指针调用（调用就崩溃）的情况。但是这个语法能强调你是在 <code>转移所有权</code>，让你清晰的知道自己在做什么，从而<code>不乱调用原有指针</code>。</p>
</blockquote>
</li>
<li><p><code>unique_ptr</code> 可以转移对象的拥有权。使<code>unique_ptr</code> 不必一定拥有对象，它也可以是 empty；例如：当它被默认构造函数创建时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;std::string&gt; ip;</span><br><span class="line">ip = <span class="literal">nullptr</span>;</span><br><span class="line">ip.<span class="built_in">reset</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-5-4-成员函数"><a href="#20-5-4-成员函数" class="headerlink" title="20.5.4. 成员函数"></a>20.5.4. 成员函数</h3><ul>
<li><code>move()</code>: 转移对象的拥有权</li>
<li><code>reset()</code>: 销毁内部对象并接受新对象的所有权并将该智能指针被置为空，等价于 up &#x3D; nullptr</li>
<li><code>release()</code>: 放弃内部对象的拥有权</li>
<li><code>swap()</code>: 交换两个指针指向的对象(即交换所拥有的对象)。</li>
<li><code>get()</code>: 获得内部对象的指针</li>
</ul>
<h3 id="20-5-5-unique-ptr-删除器"><a href="#20-5-5-unique-ptr-删除器" class="headerlink" title="20.5.5. unique_ptr 删除器"></a>20.5.5. unique_ptr 删除器</h3><p>unique_ptr 也有自己的 删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 但lambda 表达式中没有写捕获参数时，要实现自己的删除器，需要在模板参数中指定其参数类型</span></span><br><span class="line"><span class="keyword">using</span> func = <span class="built_in">void</span>(*)(Stu*);    <span class="comment">// void 类型的函数指针</span></span><br><span class="line"><span class="function">unique_ptr&lt;Stu, func&gt; <span class="title">s1</span><span class="params">(<span class="keyword">new</span> Stu(<span class="number">100</span>), [](Stu* p)&#123;    </span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">delete</span> p;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有捕获参数时，unique_ptr 模板参数类型为 仿函数的返回类型</span></span><br><span class="line">unique_ptr&lt;Stu, std::function&lt;<span class="type">void</span> (Stu*)&gt;&gt; <span class="built_in">s2</span>(<span class="keyword">new</span> <span class="built_in">Stu</span>(<span class="number">200</span>), [&amp;](Stu* p)&#123;    </span><br><span class="line">  <span class="keyword">delete</span> p;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请的内存为数组类型时，模板参数为数组类型</span></span><br><span class="line"><span class="function">unique_ptr&lt;Stu[]&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Stu[<span class="number">3</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>独占的智能指针能管理数组类型的地址，能够自动释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;Stu[]&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Stu[<span class="number">3</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>C++11 中 shared_ptr 不支持下面的语法，自C++11之后的版本，开始支持下面的语法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Stu[]&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> Stu[<span class="number">3</span>])</span></span>; </span><br></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><code>unique_ptr</code> 智能指针创建对象时，在 C++11 版本没有提供 <code>std::make_unique()</code> 的方式去创建对象，只能用 <code>new</code> 关键字创建对象。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique&lt;Employee&gt; <span class="title">employee</span><span class="params">(<span class="keyword">new</span> Employee)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要显示去调用delete，智能智能自动去调用delete</span></span><br></pre></td></tr></table></figure>

<p><code>std::make_unique</code> 在 C++14 中引入，可用下面的方式去创建对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> employee = std:<span class="built_in">make_unique</span>&lt;Employee&gt;();</span><br></pre></td></tr></table></figure>

<p>若编译器版本只支持 C++11，可以自己封装一个 <code>std::make_unique</code> 函数去实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">make_unique</span><span class="params">(Args&amp;&amp; ...args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>( std::forward&lt;Args&gt;(args)... ));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="20-6-shared-ptr"><a href="#20-6-shared-ptr" class="headerlink" title="20.6. shared_ptr"></a>20.6. shared_ptr</h2><h3 id="20-6-1-概述"><a href="#20-6-1-概述" class="headerlink" title="20.6.1. 概述"></a>20.6.1. 概述</h3><p><code>share_ptr</code> 实现的是一种共享所有权 (shared ownership)的概念。多个智能指针可以指向同一个对象，该对象和它的相关资源会在最后一个指针的指向 (<code>reference</code>) 被销毁时，得到释放。</p>
<h3 id="20-6-2-为什么要使用-shared-ptr"><a href="#20-6-2-为什么要使用-shared-ptr" class="headerlink" title="20.6.2. 为什么要使用 shared_ptr"></a>20.6.2. 为什么要使用 shared_ptr</h3><p>shared_ptr 是为了解决 auto_ptr 在对象所有权上的局限性(auto_ptr 是独占的)，在使用引用计数的机制上提供了可以共享所有权的智能指针。  </p>
<h3 id="20-6-3-成员函数"><a href="#20-6-3-成员函数" class="headerlink" title="20.6.3. 成员函数"></a>20.6.3. 成员函数</h3><ul>
<li><code>use_count()</code> 返回引用计数的个数</li>
<li><code>unique()</code> 返回指针对象的拥有者是否唯一(等价于 use_count&#x3D;1)</li>
<li><code>swap()</code> 交换两个 shared_ptr 对象(即交换所拥有的对象)</li>
<li><code>reset()</code> 放弃内部对象的所有权或拥有对象的变更, 会引起原有对象的引用计数的减少。简单来说，主要有两个作用：1、让指针指向另一块内存；2、重置指针，即让引用计数变为 0。</li>
<li><code>get()</code> 获得被 <code>shared_ptr</code> 包裹的内部对象, 即获得原始的指针，类似 <code>*p</code> 这样的。</li>
<li><code>get_deleter()</code> 返回删除器 (deleter) 的地址。</li>
</ul>
<h3 id="20-6-4-底层原理"><a href="#20-6-4-底层原理" class="headerlink" title="20.6.4. 底层原理"></a>20.6.4. 底层原理</h3><p>采用 <code>引用计数</code> 的方法，记录当前内存资源被多少个智能指针引用，该引用计数的内存在堆上分配。当新增一个指针时，<code>引用计数</code> 加1，当释放时 <code>引用计数</code> 减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。</p>
<h3 id="20-6-5-初始化"><a href="#20-6-5-初始化" class="headerlink" title="20.6.5. 初始化"></a>20.6.5. 初始化</h3><p><code>shared_ptr</code> 有四种初始化方式。</p>
<ul>
<li><p>通过构造函数初始化。</p>
</li>
<li><p>通过移动构造函数或者拷贝构造函数初始化。</p>
</li>
<li><p>通过 <code>reset()</code> 函数进行初始化。</p>
</li>
<li><p>通过 <code>make_shared</code> 初始化。用 <code>shared_ptr</code> 进行初始化时不能将一个普通指针直接赋值给智能指针，因为一个是指针，一个是类。但可以通过 <code>make_shared</code> 函数或者通过构造函数传入普通指针，并可以通过 <code>get()</code> 函数获得普通指针。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>);               <span class="comment">// ERROR</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;hello&quot;</span>))</span></span>;                <span class="comment">// OK</span></span><br><span class="line">shared_ptr&lt;string&gt; p = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="string">&quot;hello&quot;</span>));     <span class="comment">// OK</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="20-6-6-用法"><a href="#20-6-6-用法" class="headerlink" title="20.6.6. 用法"></a>20.6.6. 用法</h3><p>直接使用智能指针对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;Stu&gt; st5 = <span class="built_in">make_shared</span>&lt;Stu&gt;(<span class="number">9527</span>);</span><br><span class="line">st6-&gt;<span class="built_in">setValue</span>(<span class="number">777</span>);</span><br><span class="line">st6-&gt;<span class="built_in">getValue</span>();</span><br></pre></td></tr></table></figure>

<p>获取智能指针对象的原始指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Stu&gt; <span class="title">st1</span><span class="params">(<span class="keyword">new</span> Stu(<span class="number">007</span>))</span></span>;</span><br><span class="line">Stu* p = st<span class="number">1.</span><span class="built_in">get</span>();</span><br><span class="line">p-&gt;<span class="built_in">setValue</span>(<span class="number">100</span>);</span><br><span class="line">p-&gt;<span class="built_in">getValue</span>();</span><br></pre></td></tr></table></figure>


<h3 id="20-6-7-shared-ptr-删除器"><a href="#20-6-7-shared-ptr-删除器" class="headerlink" title="20.6.7. shared_ptr 删除器"></a>20.6.7. shared_ptr 删除器</h3><p>shared_ptr 默认的删除器函数不能自动析构申请的是数组类型对象的内存，因此需要手动实现一个删除器；当申请的内存不是数组类型时，不需要手动实现删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Stu&gt; <span class="title">st</span><span class="params">(<span class="keyword">new</span> Stu(<span class="number">10</span>), [](Stu* p)&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">delete</span> p;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中对象中的第二个参数是匿名对象，这个匿名对象可以对象的外部实现后再传入进来，也可以在对象中使用 lambda 表达式，例如：<code>[](Stu* p)&#123;&#125;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个自己的删除器：deleter,可以选择自己不手动实现</span></span><br><span class="line"><span class="function">shared_ptr&lt;string&gt; <span class="title">str</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Implement my deleter&quot;</span>),</span></span></span><br><span class="line"><span class="params"><span class="function">                       [](string* p) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                           cout &lt;&lt; <span class="string">&quot;deleter: &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="keyword">delete</span> p;</span></span></span><br><span class="line"><span class="params"><span class="function">                       &#125;)</span></span>;</span><br><span class="line">str = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须要手动实现删除器</span></span><br><span class="line"><span class="comment">// shared_ptr&lt;Stu&gt; St7(new Stu[5]);   // 执行 5 次 构造函数，析构函数执行一次，造成内存泄漏</span></span><br><span class="line"><span class="function">shared_ptr&lt;Stu&gt; <span class="title">St7</span><span class="params">(<span class="keyword">new</span> Stu[<span class="number">5</span>], [](Stu* t)&#123;  <span class="comment">// 改进版</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">delete</span> []t;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在删除数组内存时，除了自己编写删除器，也可以使用 C++ 提供的 std::default_delete<T>() 函数作为删除器，这个函数内部的删除功能也是通过调用 delete 来实现的，要释放什么类型的内存就将模板类型 T 指定为什么类型即可。具体处理代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;Stu&gt; <span class="title">st8</span><span class="params">(<span class="keyword">new</span> Stu(<span class="number">5</span>), default_delete&lt;Stu&gt;())</span></span>;</span><br></pre></td></tr></table></figure>

<p>自己封装一个 <code>make_shared_array</code> 方法来让 <code>shared_ptr</code> 支持数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared_array</span><span class="params">(<span class="type">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[len], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test05</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;Stu&gt; t = <span class="built_in">make_shared_array</span>&lt;Stu&gt;(<span class="number">4</span>);</span><br><span class="line">    cout &lt;&lt; t.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整的代码可在仓库中查看：<a href="./code/c11/shared_ptr.cpp">shared_ptr实现</a></p>
<h3 id="20-6-8-注意点"><a href="#20-6-8-注意点" class="headerlink" title="20.6.8. 注意点"></a>20.6.8. 注意点</h3><ul>
<li><code>shared_ptr</code> 还有可能导致内存泄漏。两个对象相互使用一个 <code>shared_ptr</code> 成员变量指向对方，会造成循环引用，从而导致内存泄漏。</li>
<li>不能使用一个原始地址值初始化多个 shared_ptr。</li>
<li>函数不能返回管理了 this 指针的 shared_ptr 对象。</li>
<li>shared_ptr 只提供 <code>operator*</code> 和 <code>operator-&gt;</code>，没有提供 <code>operator[]</code> 和指针运算。</li>
</ul>
<h2 id="20-7-weak-ptr"><a href="#20-7-weak-ptr" class="headerlink" title="20.7. weak_ptr"></a>20.7. weak_ptr</h2><h3 id="20-7-1-概述"><a href="#20-7-1-概述" class="headerlink" title="20.7.1. 概述"></a>20.7.1. 概述</h3><p><code>weak_ptr</code> 是弱引用指针，是一种不控制对象生命周期的智能指针，指向一个 <code>shared_ptr</code> 管理的对象。<code>weak_ptr</code> 只提供一种访问手段，它不共享指针，不能操作资源。</p>
<h3 id="20-7-2-为什么要使用-weak-ptr"><a href="#20-7-2-为什么要使用-weak-ptr" class="headerlink" title="20.7.2. 为什么要使用 weak_ptr"></a>20.7.2. 为什么要使用 weak_ptr</h3><ul>
<li>配合 <code>shared_ptr</code> 智能指针来进行工作，解决 <code>shared_ptr</code> 智能指针相互引用时死锁的问题。当两个 <code>shared_ptr</code>智能指针相互引用时，这两个指针的引用数永远不可能减到 0 ，导致资源永远不会释放。</li>
<li>它是对 对象的一种弱引用，不会增加对象的 <code>引用计数</code>。</li>
<li><code>weak_ptr </code> 与 <code>shared_ptr</code>之间可以相互转化。<code>shared_ptr</code> 可以直接赋值给 <code>weak_ptr</code>；而 <code>weak_ptr </code>通过调用 <code>lock()</code> 函数来获得 <code>shared_ptr</code>。</li>
</ul>
<h3 id="20-7-3-初始化"><a href="#20-7-3-初始化" class="headerlink" title="20.7.3. 初始化"></a>20.7.3. 初始化</h3><p><code>weak_ptr</code> 提供三种初始化的方式：构造函数中初始化、拷贝构造函数初始化、通过隐式类型转换，shared_ptr 对象直接赋值给 weak_ptr 对象来初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">st</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>())</span></span>; <span class="comment">// Create a object</span></span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wt1;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wt1.use_count = &quot;</span> &lt;&lt; wt<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wt2</span><span class="params">(st)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wt2.use_count = &quot;</span> &lt;&lt; wt<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wt3</span><span class="params">(wt1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wt3.use_count = &quot;</span> &lt;&lt; wt<span class="number">3.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">weak_ptr&lt;<span class="type">int</span>&gt; wt4 = st; <span class="comment">// 通过隐式类型转换，shared_ptr 对象直接赋值给 weak_ptr 对象</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;wt4.use_count = &quot;</span> &lt;&lt; wt<span class="number">4.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>


<h3 id="20-7-4-底层原理"><a href="#20-7-4-底层原理" class="headerlink" title="20.7.4. 底层原理"></a>20.7.4. 底层原理</h3><p><code>weak_ptr</code> 底层主要依赖于 <code>counter</code> 计数器类和 <code>shared_ptr</code> 赋值、构造等手段实现的。</p>
<ul>
<li><code>counter</code> 对象的目地就是用来申请一个块内存来存引用基数。</li>
<li><code>share_ptr</code> 给出的函数接口为：构造，拷贝构造，赋值，解引用。</li>
</ul>
<h3 id="20-7-5-成员函数"><a href="#20-7-5-成员函数" class="headerlink" title="20.7.5. 成员函数"></a>20.7.5. 成员函数</h3><ul>
<li><code>expired()</code> 检测所管理的对象是否已经释放, 如果已经释放, 返回 true; 否则返回 false。</li>
<li><code>lock()</code> 获取所管理的对象的强引用 <code>shared_ptr</code>；如果 <code>expired</code> 为 true, 返回一个空的 <code>shared_ptr</code>; 否则返回一个 <code>shared_ptr</code>, 其内部对象指向与 <code>weak_ptr</code> 相同。</li>
<li><code>reset()</code> 放弃被拥有物的拥有权，重新初始化为一个空的 <code>weak_ptr</code>。</li>
<li><code>use_count()</code> 返回所监测的 <code>shared_ptr</code> 共享对象的引用计数。</li>
</ul>
<p>代码用例实现在工程库中：<a href="./code/c11/weak_ptr.cpp">Weak_ptr 智能指针用法</a></p>
<h3 id="20-7-6-注意点"><a href="#20-7-6-注意点" class="headerlink" title="20.7.6. 注意点"></a>20.7.6. 注意点</h3><ul>
<li><code>weak_ptr</code> 没有重载 <code>*</code> 和<code>-&gt; </code> 但可以使用 <code>lock</code> 获得一个可用的 <code>shared_ptr</code> 对象。<code>weak_ptr</code> 在使用前需要检查合法性。</li>
<li><code>weak_ptr</code> 支持 <code>拷贝或赋值</code>, 但不会影响对应的 <code>shared_ptr</code> 内部对象的计数。</li>
</ul>
<p>参考</p>
<ul>
<li>详解C++11智能指针: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/WindSun/p/11444429.html">https://www.cnblogs.com/WindSun/p/11444429.html</a></li>
<li>C++智能指针详解: <a target="_blank" rel="noopener" href="https://blog.csdn.net/flowing_wind/article/details/81301001">https://blog.csdn.net/flowing_wind/article/details/81301001</a></li>
<li>C++ 智能指针类: <a target="_blank" rel="noopener" href="https://blog.csdn.net/heyabo/article/details/8791410">https://blog.csdn.net/heyabo/article/details/8791410</a></li>
</ul>
<h1 id="21-typename"><a href="#21-typename" class="headerlink" title="21. typename"></a>21. typename</h1><h2 id="21-1-概念"><a href="#21-1-概念" class="headerlink" title="21.1. 概念"></a>21.1. 概念</h2><p>从属名称(dependent names)：类模板中出现的名称依赖于某个参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">T::const_iterator <span class="title">iter</span><span class="params">(var.begin())</span></span>;  <span class="comment">// T::const_iterator 为从属名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>嵌套从属名称(nested depended name)：从属名称在 class 内嵌套。</p>
<h2 id="21-2-为什么要用-typename"><a href="#21-2-为什么要用-typename" class="headerlink" title="21.2. 为什么要用 typename ?"></a>21.2. 为什么要用 typename ?</h2><p><code>typename</code> 是C++中的一个关键字。当类模板中使用指针类型去定义变量时，编译并不知道 <code>T::const_iterator*</code> 是个类型还是一个变量，编译的时候会产生歧义，撰写C++解析的人员必须要考虑到所有可能出现的问题，因此引入了 <code>typename</code> 关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T::const_iterator* x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类模板中 <code>class</code> 关键字与 <code>typename</code> 关键字的用法一样，都是定义一个类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两者声明的效果一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; <span class="keyword">class</span> <span class="title class_">Stu</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>

<p><code>typename</code> 用于嵌套从属名称(nested depended name)。</p>
<ul>
<li>任何时候你要在 <code>template</code> 模板类中使用一个嵌套从属类型名称，就必须在它的前边放置 <code>typename</code> 关键字。</li>
<li>C++编译器有个解析的规则：如果解析器在 <code>template</code> 中遇到一个嵌套从属名称，它便假设这个名称不是类型，除非你要告诉编译器，这是一个类型。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未使用typename，可能在编译时出现问题</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (var.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 默认情况下编译器认为 T::const_iterator 这个不是类型名，可能是个变量</span></span><br><span class="line">    <span class="function">T::const_iterator <span class="title">iter</span><span class="params">(var.begin())</span></span>;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改进情况</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> T&amp; var)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (var.<span class="built_in">size</span>() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typename</span> T::const_iterator <span class="title">iter</span><span class="params">(var.begin())</span></span>;    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="21-3-注意点"><a href="#21-3-注意点" class="headerlink" title="21.3. 注意点"></a>21.3. 注意点</h2><p><code>typename</code> 不可以出现在 <code>base classes list</code> 内的嵌套从属名称之前，也不可以在 <code>member initialization list(成员初值列)</code> 中作为 <code>base class</code> 修饰符。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base&lt;T&gt;::Nested &#123;  <span class="comment">// base class list 中不允许 typename</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Derived</span> <span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">        : Base&lt;T&gt;::Nested(x)                    // mem.init.list中不允许typename</span></span><br><span class="line"><span class="function">        &#123;</span></span><br><span class="line">            <span class="comment">// 嵌套从属类型名称既不在base class list 中也不在 mem.init.list 中，</span></span><br><span class="line">            <span class="comment">// 作为一个 base class 修饰符则需要加上 typename</span></span><br><span class="line">            <span class="keyword">typename</span> Base&lt;T&gt;::Nested temp;       </span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<h1 id="22-explicit-conversions-显示类型转换"><a href="#22-explicit-conversions-显示类型转换" class="headerlink" title="22. explicit conversions(显示类型转换)"></a>22. explicit conversions(显示类型转换)</h1><p>C++中的类型转换有4种。</p>
<h2 id="22-1-static-cast"><a href="#22-1-static-cast" class="headerlink" title="22.1. static_cast&lt;&gt;()"></a>22.1. static_cast&lt;&gt;()</h2><p><code>static_cast</code> 是一种静态类型转换。编译时，编译器会做类型转换。C 语言中能使用隐式转换的类型均可以用 <code>static_cast</code> 类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static_cast</span>&lt;&gt;()，</span><br><span class="line">例如：</span><br><span class="line"><span class="type">double</span> a1 = <span class="number">12.0</span>;</span><br><span class="line"><span class="type">int</span> a2 = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(a1);  </span><br></pre></td></tr></table></figure>


<h2 id="22-2-reinterpret-cast"><a href="#22-2-reinterpret-cast" class="headerlink" title="22.2. reinterpret_cast&lt;&gt;()"></a>22.2. reinterpret_cast&lt;&gt;()</h2><p><code>reinterpret_cast&lt;&gt;()</code> 是一种重新解释类型转换。</p>
<h2 id="22-3-dynamic-cast"><a href="#22-3-dynamic-cast" class="headerlink" title="22.3. dynamic_cast&lt;&gt;()"></a>22.3. dynamic_cast&lt;&gt;()</h2><p><code>dynamic_cast&lt;&gt;()</code> 是一种动态类型转换，用于父类与子类之间的多态类型转换。</p>
<h2 id="22-4-const-cast"><a href="#22-4-const-cast" class="headerlink" title="22.4. const_cast&lt;&gt;()"></a>22.4. const_cast&lt;&gt;()</h2><p><code>const_cast&lt;&gt;()</code> 是一种 const 类型转换，去除类型的只读属性。常常用于有函数重载的上下文中。</p>
<h1 id="23-exception-异常处理"><a href="#23-exception-异常处理" class="headerlink" title="23. exception(异常处理)"></a>23. exception(异常处理)</h1><p>C++ 中使用 <code>throw</code> 抛出异常，<code>try...catch</code> 等关键字来捕获异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span> (exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// throw语法</span></span><br><span class="line"><span class="keyword">throw</span> 需要处理的表达式;</span><br></pre></td></tr></table></figure>

<p>注意：空的 <code>throw</code> 语句只能出现在 <code>catch</code> 语句或者被 <code>catch</code> 语句调用的函数体内，如果空的 <code>throw</code> 语句出现在处理代码以外，则编译器将执行 <code>terminate</code>。</p>
<p>异常的特性</p>
<ul>
<li>异常严格按照类型进行匹配，不会进行隐式的类型转换。</li>
<li>C++的异常处理机制使 <code>异常的检测</code> 与 <code>异常的处理</code> 不必在同一个函数中，很好的实现了软件的分层机制。</li>
<li>异常是一种 <code>跨越函数</code> 的机制。</li>
<li>栈解旋：类中的抛出异常会执行析构函数。</li>
</ul>
<h2 id="23-1-异常变量的生命周期"><a href="#23-1-异常变量的生命周期" class="headerlink" title="23.1. 异常变量的生命周期"></a>23.1. 异常变量的生命周期</h2><ul>
<li>异常接收时的变量是元素，且为 <code>类的类型</code> 时，则执行的是拷贝构造。</li>
<li>异常接收时的变量为 <code>类的引用</code> 时，使用 throw 去抛那个对象。</li>
<li>指针和引用或元素可以同时执行 <code>catch</code> 捕获，但引用和元素不能同时执行 <code>catch</code> 捕获。</li>
</ul>
<h2 id="23-2-异常的层次结构"><a href="#23-2-异常的层次结构" class="headerlink" title="23.2. 异常的层次结构"></a>23.2. 异常的层次结构</h2><p>标准库中常常在继承中处理。按照 <code>引用</code> 传递异常，在异常中使用虚函数。</p>
<p>标准程序库中所有基类的异常为 <code>Exception()</code> </p>
<img src="./figures/exception.png">


<h2 id="23-3-异常的优缺点"><a href="#23-3-异常的优缺点" class="headerlink" title="23.3. 异常的优缺点"></a>23.3. 异常的优缺点</h2><ul>
<li><p>优点</p>
<ul>
<li>函数的返回值可以忽略，但异常不可忽略。如果程序出现异常，但是没有被捕获，程序就会终止，这多少会促使程序员开发出来的程序更健壮一点。而如果使用C语言的error宏或者函数返回值，调用者都有可能忘记检查，从而没有对错误进行处理，结果造成程序莫名其面的终止或出现错误。</li>
<li>整型返回值没有任何语义信息，而异常却包含语义信息，有时你从类名就能够体现出来。整型返回值缺乏相关的上下文信息。异常作为一个类，可以拥有自己的成员，这些成员就可以传递足够的信息。</li>
<li>异常处理可以在调用时跳级。这是一个代码编写时的问题：假设在有多个函数的调用栈中出现了某个错误，使用整型返回码要求你在每一级函数中都要进行处理。而使用异常处理的栈展开机制，只需要在一处进行处理就可以了，不需要每级函数都处理。</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>C++没有垃圾回收机制，资源需要自己管理。C++中异常经常会导致资源泄漏的问题，比如在new和delete中抛出了异常，导致内存泄漏，在lock和unlock之间抛出了异常导致死锁。</li>
<li>异常会在程序运行出错时抛出异常，程序会乱跳，导致调试程序比较困难。</li>
<li>异常会有一些性能的开销。 </li>
<li>构造函数中不能抛异常，抛异常可能导致对象定义不完整。析构函数不能抛异常，可能导致内存泄漏。</li>
</ul>
</li>
</ul>
<h2 id="23-4-构造函数中的异常"><a href="#23-4-构造函数中的异常" class="headerlink" title="23.4. 构造函数中的异常"></a>23.4. 构造函数中的异常</h2><p>处理构造函数中初始值异常的唯一方法：将构造函数写成 <code>try函数语句块</code></p>
<h1 id="24-Meaningful-aphorisms-隽永警句"><a href="#24-Meaningful-aphorisms-隽永警句" class="headerlink" title="24. Meaningful aphorisms (隽永警句)"></a>24. Meaningful aphorisms (隽永警句)</h1><ul>
<li>编程—-写出大家风范。</li>
<li>吾道一以惯之。—&gt;出自孔子的《论语》</li>
<li>胸中自有丘壑。—&gt;出自叶圣陶的《苏州园林》</li>
<li>勿在浮沙筑高楼。</li>
<li>山高月小，水落石出。—&gt;出自宋代苏轼的《后赤壁赋》</li>
<li>当你发现自己的才华撑不起野心时，就请安静下来学习吧！</li>
<li>Don’t reinvent the wheel.</li>
</ul>
<hr>
<p><strong>StyleGuide(规范)</strong></p>
<ul>
<li>每个独立的类应单独放在一个文件里</li>
<li>变量一般声明为 private，采用间接访问</li>
</ul>
<hr>
<h1 id="25-References-by-website-学习参考"><a href="#25-References-by-website-学习参考" class="headerlink" title="25. References by website(学习参考)"></a>25. References by website(学习参考)</h1><ul>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/">cppreference</a>: 新版C++标准官方参考文档。</li>
<li><a target="_blank" rel="noopener" href="https://www.cplusplus.com/">cplusplus</a>: 旧版的C++学习参考文档</li>
<li><a target="_blank" rel="noopener" href="http://gcc.gnu.org/">GCC, the GNU Compiler Collection</a>: GCC编译器的官网</li>
<li><a target="_blank" rel="noopener" href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">C++ Core Guidelines</a>: Bjarne Stroustrup 与 Herb Sutter 联合编写的 C++ 教程。Github 地址：<a target="_blank" rel="noopener" href="https://github.com/isocpp/CppCoreGuidelines">https://github.com/isocpp/CppCoreGuidelines</a></li>
<li><a target="_blank" rel="noopener" href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/">open-std.org</a>: C++标准委员会列出的C++中某项技术如何被采纳到标准中？</li>
<li><a target="_blank" rel="noopener" href="https://isocpp.org/">isocpp.org</a>: 标准委员会官方站点，近期的会议、行程、活动、计划等等都会发布在这里。这里也会推荐一些比较好的文章、教程、书籍等等内容，供C++程序员阅读。</li>
<li><a target="_blank" rel="noopener" href="https://www.stroustrup.com/C++11FAQ.html">C++ FAQ</a>: 指出了C++编程中可能出现的一些问题，值得推荐阅读，中文网址 <a target="_blank" rel="noopener" href="https://www.stroustrup.com/C++11FAQ.html">C++11 FAQ</a>。</li>
<li><a target="_blank" rel="noopener" href="https://cpprocks.com/c11-compiler-support-shootout-visual-studio-gcc-clang-intel/">cpprocks.com</a>：查看C++11支持哪些编译，里面还有许多优质的东西，值得挖掘。</li>
<li><a target="_blank" rel="noopener" href="https://www.stroustrup.com/index.html">stroustrup.com</a>: C++之父的主页，确定不来看看吗？好东西贼多。</li>
<li><a target="_blank" rel="noopener" href="http://scottmeyers.blogspot.com/%EF%BC%9AScott">http://scottmeyers.blogspot.com/：Scott</a> Meyers 个人博客网址，长期更新，从 1999 年开始，每年都有文章更新，一直坚持到现在。</li>
<li><a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/cpp/cpp/?view=msvc-160">Microsoft C++ 语言文档</a>: 微软官方写的C++参考技术文档，用于Visual Studio 中。</li>
<li><a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/cppblog/">microsoft cppblog</a>: 微软C++团队的博客，没事的话也可以看看。 </li>
<li><a target="_blank" rel="noopener" href="https://www.geeksforgeeks.org/the-c-standard-template-library-stl/">geeksforgeeks.org</a>: GeeksforGeeks 是一个主要专注于计算机科学的网站。 它有大量的算法，解决方案和编程问题。</li>
<li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/cpp">reddit cpp版块</a>: reddit的cpp版块也不错，可以了解最新的C++消息，也可以提问题，也有人在这里写一些文章教程。</li>
<li><a target="_blank" rel="noopener" href="https://herbsutter.com/">herbsutter.com</a>: Herb Sutter的博客，Herb Sutter是C++核心人物之一，早期The Free Lunch Is Over这篇文章就出自他手，他还写过Exceptional系列C++图书.</li>
<li><a target="_blank" rel="noopener" href="http://stepanovpapers.com/">stepanovpapers.com</a>: 收录了泛型编程的祖师Alex Stepanov的论文网站，STL便是其杰作。可以说没人比他更懂泛型编程，而且这位大牛中的大牛竟然还仿照欧几里得的《几何原本》写了本《编程原本》，试图以公理化方法演绎编程。</li>
<li><a target="_blank" rel="noopener" href="https://www.modernescpp.com/index.php">modernescpp.com</a>: 一个开发者个人的网站，网站上的文章质量很高。值得一读。</li>
<li><a target="_blank" rel="noopener" href="https://preshing.com/">Preshing on Programming</a>: 自由开发者撰写的博客，内容质量很不错。</li>
<li><a target="_blank" rel="noopener" href="https://arne-mertz.de/">arne-mertz.de</a>: 同样是自由开发者撰写的博客，内容质量很不错。</li>
<li><a target="_blank" rel="noopener" href="https://www.learncpp.com/">learncpp</a>: 该网站主要是叫你如何使用C++，成为一个master。</li>
<li><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/index.htm">TutorialsPoint</a>: 网站上有许多关于编程语言学习的教程，可以看看。</li>
<li><a target="_blank" rel="noopener" href="http://cpp.sh/">C++ shell</a>: 在线的C++编译器，在线编辑代码。</li>
<li><a target="_blank" rel="noopener" href="https://herbsutter.com/">herbsutter</a>: ISO C++标准委员会主席，C++&#x2F;CLI首席架构师 的个人主页。</li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/compiler_support">cppreference 列出的 C++ compiler support</a> </li>
<li><a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/libstdc++/">官方在线 The GNU C++ Library 文档</a></li>
<li><a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/links/libs">open source C++ libraries</a>：cppreference 官方列出的一些开源的 C++ 库。</li>
<li><a href="https://www.fluentcpp.com：博客作者Jonathan">https://www.fluentcpp.com：博客作者Jonathan</a> Boccara 是C++软件工程负责人、博客作者和作家，专注于如何使代码具有表现力，顶级C++高手。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io">John Jeep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io/Cpp/Cpp/01-C++Novice/">https://johnjeep.github.io/Cpp/Cpp/01-C++Novice/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://johnjeep.github.io" target="_blank">Leaning Computer Science Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cpp/">cpp</a><a class="post-meta__tags" href="/tags/01-C-Novice/">01-C++Novice</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/CloudNative/CloudNative/modbus/" title="modbus"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">modbus</div></div><div class="info-2"><div class="info-item-1">   References modbus tools www.modbus.org Complete Modbus Guide Modbus_Application_Protocol_V1 Frequently Asked Questions doc: MinimalModbus Manual_Modbus Modbus仿真器 Modbus Poll 和Modbus Slave详细图文教程 Modbus调试软件–ModbusPoll、ModbusSlave使用详解  </div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/02-C++Advanced/" title="02-C++Advanced"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">02-C++Advanced</div></div><div class="info-2"><div class="info-item-1">  1. Object Oriented Programming(面向对象编程)Object Oriented Programming(OOP)叫面向对象编程。  class without pointer members：类中的成员不带有指针。 class with pointer members：类中的成员带有指针。  1.1. Encapsulation(封装)封装这个术语用来描述在过程接口后面隐藏实现细节的概念。 C++ 中对类的设计时，封装了属性和方法。若直接访问类的数据成员就违反了封装原则。设计原则应保持数据成员的私有性。 访问限定符  public  修饰类的成员变量和函数，既能在 类的内部 使用又能在 类的外部 使用 private 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用 protect 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用，可以在 继承的子类 中使用。  C++ 中类与类之间的关系主要归为三大类：复合、委托、继承。 1.2....</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Cpp/Cpp/02-C++Advanced/" title="02-C++Advanced"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">02-C++Advanced</div></div><div class="info-2"><div class="info-item-1">  1. Object Oriented Programming(面向对象编程)Object Oriented Programming(OOP)叫面向对象编程。  class without pointer members：类中的成员不带有指针。 class with pointer members：类中的成员带有指针。  1.1. Encapsulation(封装)封装这个术语用来描述在过程接口后面隐藏实现细节的概念。 C++ 中对类的设计时，封装了属性和方法。若直接访问类的数据成员就违反了封装原则。设计原则应保持数据成员的私有性。 访问限定符  public  修饰类的成员变量和函数，既能在 类的内部 使用又能在 类的外部 使用 private 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用 protect 修饰类的成员变量和函数，只能在 类的内部 使用，不能在 类的外部 使用，可以在 继承的子类 中使用。  C++ 中类与类之间的关系主要归为三大类：复合、委托、继承。 1.2....</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/03-C++Standard/" title="03-C++Standard"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">03-C++Standard</div></div><div class="info-2"><div class="info-item-1">  C++ 新特性演化整体概览。  1. C++11 新特性1.1. Template of  Space在 C++11 之后，对一些语法做了一些优化（Important Minor Syntax Cleanups）。比如，优化了 template（模板）中的尖括号的问题，中间是否需要加空格。 12vector&lt;list&lt;int&gt; &gt; ;  // C+11 之前版本，必须要加一个空格，否则编译器会报错vector&lt;list&lt;int&gt;&gt; ;   // C++11 之后，不用加空格，语法得到了优化   1.2. Initializer listsC++11 引入了初值列 (initializer list) 和一致性初始化 (Uniform Initialization)。即采用 &#123;&#125; 去初始化需要初始化的参数，引入新特的同时也兼容原版本的 () 初始化操作。    initializer list 的底层是采用 initializer_list&lt;T&gt; 这个类模板实现的，其中这个类模板下层采用...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/04-STL/" title="04-STL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">04-STL</div></div><div class="info-2"><div class="info-item-1">  1. Thinking(思考) 使用它是一件很愉快的事。 使用一个东西，却不明白它的道理，不高明！—林语堂 源码之前了无秘密。 天下大事，必作于细。 高屋建瓴，细致入微。 所谓剖析源码，其目的在于明理、解惑，提高自身水平，并不是要穷经皓首，倒背如流。  STL学习境界：会用，明理，能扩展。  会用：熟练使用 STL 的各种 API 接口。 明理：明白 STL 设计的思想，各种 API 的底层实现原理。 能扩展：对 STL 添加自己实现的各种接口，扩充 STL 的功能。   目标 Level 0: 使用C++标准库 Level 1: 深入认识C++标准库(胸中自有丘壑) Level 2: 良好使用C++标准库 Level 3: 扩充C++标准库  源码版本：GNU 2.91, GNU 4.9  2. History(历史)C++创始人：比尼亚·斯特鲁斯特鲁普（Bjarne Stroustrup） STL创始人：Alexander Stepanov(亚历山大·斯蒂芬诺夫) GPL(General Public licence):...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++MemoryManagement/" title="C++MemoryManagement"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++MemoryManagement</div></div><div class="info-2"><div class="info-item-1">  History(历史)Doug Lea自1986年开始研究malloc算法，他的作品被称为 DL Malloc，目前linux中的glibc的malloc算法就是直接来自Doug Lea，其它平台的malloc的实现或多或少受到DL的影响。 内存管理层级 OS（操作系统），Windows 系统的的 HeapAlloc 和 VirtualAlloc； GUNC++&#x2F;CRT 编译器的 malloc() C++ 标准库的 Allocator C++ 应用程序层面的内存 API 函数。  内存库作品 tcmalloc：稳定，占用内存更低。 jemalloc性能更高，占用内存更高  Bibliography(书目) STL源码剖析(侯捷) Small Memory Software(James Noble &amp; Charles Weir) Modern C++ Design General Programming and Design Patterns Applied(Andrei Alexandrescu)  Reference(参考) Doug Lea’s...</div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++Optimization/" title="C++Optimization"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++Optimization</div></div><div class="info-2"><div class="info-item-1"> 开销来自哪里 函数之间的调用。用模板和内联函数去解决。  编写高效的 C++ 程序让编写的程序提高运行效率的方式：  高效的算法。 避免不必要计算和步骤。 选择恰当的优化设计策略。  References Software optimization resources 《Optimized C++》Kurt Guntheroth 大师编写的 C++ 优化书籍。 《Effective STL》 《Effective C++》 《Effective Modern C++》  </div></div></div></a><a class="pagination-related" href="/Cpp/Cpp/C++SoftDesign/" title="C++SoftDesign"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">C++SoftDesign</div></div><div class="info-2"><div class="info-item-1">  1. C++ 软件设计1.1. 简单就是最好的 —&gt; 大道至简。API 是软件组件的接口，隐藏了实现这个接口所需的内部细节。 API 必须拥有良好的设计、文档、回归测试、并且保证发布之间的稳定性。 1.2. 重用哲学设计自己和其它程序员可以重复使用的代码。重用设计的准则：  编写一次，经常使用。 尽量避免代码重复。 不要重复写在自己写过的代码（Don’t repeat yourself）。  为什么要重用设计代码？  重用设计可以节约金钱和时间。 缺乏重用性会导致代码重复。  1.3. 如何设计可重用代码对于设计可重用代码而言，最重要的策略是抽象。设计代码时，需要考虑将    接口和实现进行分离，使代码更容易使用，程序员使用时不需要理解其内部实现细节。 ​ 抽象将代码分为接口和实现，因此设计可重用代码会关注这两个领域。代码实现时思考：如何做到恰到好处的设计代码结构？考虑使用什么样的类层次结构？需要使用模板吗？如何将代码切分割为子系统？设计接口时思考：设计分接口是库还是代码的“入口“，程序员使用这个接口时，应该给提供什么样的功能。 1.4....</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Jeep</div><div class="author-info-description">lifestyle is lazy, faster, thinking</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JohnJeep/Learning-CS-Journey"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xxxxx@gmail.com" target="_blank" title="Gmail"><i class="fa-solid fa-bell" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-concept-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1. concept(概念)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-c-basics-C-%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">2. c++ basics(C++基础)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-namespace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">3.</span> <span class="toc-text">3. namespace(命名空间)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-header-file-%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-number">4.</span> <span class="toc-text">4. header file(头文件)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-reference-%E5%BC%95%E7%94%A8"><span class="toc-number">5.</span> <span class="toc-text">5. reference(引用)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-ordinary-reference-%E6%99%AE%E9%80%9A%E5%BC%95%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text">5.1. ordinary reference(普通引用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-lvalue-reference-%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2. lvalue reference(左值引用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-rvalue-reference-%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3. rvalue reference(右值引用)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-const-reference-%E5%B8%B8%E9%87%8F%E5%BC%95%E7%94%A8"><span class="toc-number">5.4.</span> <span class="toc-text">5.4. const reference(常量引用)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-function-%E5%87%BD%E6%95%B0"><span class="toc-number">6.</span> <span class="toc-text">6. function(函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. inline(内联函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-function-parameter-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. function parameter(函数参数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-template-function-%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">6.3. template function(模板函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-conversion-function-%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-number">6.4.</span> <span class="toc-text">6.4. conversion function(转换函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-functor-%E4%BB%BF%E5%87%BD%E6%95%B0"><span class="toc-number">6.5.</span> <span class="toc-text">6.5. functor(仿函数)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Special-member-function-%E7%B1%BB%E4%B8%AD%E7%89%B9%E5%88%AB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">7.</span> <span class="toc-text">7. Special member function (类中特别的成员函数)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-constructor-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. constructor(构造函数)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-copy-constructor-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. copy constructor(拷贝构造)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-copy-assignment-operator-%E6%8B%B7%E8%B4%9D%E8%B5%8B%E5%80%BC"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. copy assignment operator(拷贝赋值)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-Move-constructor-%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0"><span class="toc-number">7.4.</span> <span class="toc-text">7.4. Move constructor(移动构造)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-5-Move-assignment-operator-%E7%A7%BB%E5%8A%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="toc-number">7.5.</span> <span class="toc-text">7.5. Move assignment operator(移动赋值操作)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-6-destructor-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">7.6. destructor(析构函数)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-empty-class"><span class="toc-number">8.</span> <span class="toc-text">8. empty class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-class-object-class-pointer"><span class="toc-number">9.</span> <span class="toc-text">9. class object &amp;&amp; class pointer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-new-delete"><span class="toc-number">10.</span> <span class="toc-text">10. new &amp;&amp; delete</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-overload-%E9%87%8D%E8%BD%BD"><span class="toc-number">11.</span> <span class="toc-text">11. overload(重载)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-override-%E9%87%8D%E5%86%99"><span class="toc-number">12.</span> <span class="toc-text">12. override(重写)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-const"><span class="toc-number">13.</span> <span class="toc-text">13. const</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-static"><span class="toc-number">14.</span> <span class="toc-text">14. static</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-this"><span class="toc-number">15.</span> <span class="toc-text">15. this</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-mutable"><span class="toc-number">16.</span> <span class="toc-text">16. mutable</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1-mutable%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">16.1.</span> <span class="toc-text">16.1. mutable是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8mutable%EF%BC%9F"><span class="toc-number">16.2.</span> <span class="toc-text">16.2. 为什么要用mutable？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3-%E4%BD%BF%E7%94%A8-mutable-%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">16.3.</span> <span class="toc-text">16.3. 使用 mutable 的注意事项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4-%E5%B8%B8%E5%87%BD%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">16.4. 常函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#17-pass-by-value-pass-by-reference"><span class="toc-number">17.</span> <span class="toc-text">17. pass by value &amp;&amp; pass by reference</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#18-friend-%E5%8F%8B%E5%85%83"><span class="toc-number">18.</span> <span class="toc-text">18. friend(友元)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#19-operator-overloading-%E6%93%8D%E4%BD%9C%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">19.</span> <span class="toc-text">19. operator overloading(操作运算符重载)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#20-smart-pointer-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">20.</span> <span class="toc-text">20. smart pointer(智能指针)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#20-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%9F"><span class="toc-number">20.1.</span> <span class="toc-text">20.1. 为什么要使用智能指针？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%8E%9F%E7%90%86"><span class="toc-number">20.2.</span> <span class="toc-text">20.2. 智能指针原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-3-%E4%BD%BF%E7%94%A8%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">20.3.</span> <span class="toc-text">20.3. 使用智能指针的优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-4-auto-ptr"><span class="toc-number">20.4.</span> <span class="toc-text">20.4. auto_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-5-unique-ptr"><span class="toc-number">20.5.</span> <span class="toc-text">20.5. unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">20.5.1.</span> <span class="toc-text">20.5.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-unique-ptr"><span class="toc-number">20.5.2.</span> <span class="toc-text">20.5.2. 为什么要用 unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.5.3.</span> <span class="toc-text">20.5.3. 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-4-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">20.5.4.</span> <span class="toc-text">20.5.4. 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-5-5-unique-ptr-%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">20.5.5.</span> <span class="toc-text">20.5.5. unique_ptr 删除器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">20.5.6.</span> <span class="toc-text">注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-6-shared-ptr"><span class="toc-number">20.6.</span> <span class="toc-text">20.6. shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">20.6.1.</span> <span class="toc-text">20.6.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-shared-ptr"><span class="toc-number">20.6.2.</span> <span class="toc-text">20.6.2. 为什么要使用 shared_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-3-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">20.6.3.</span> <span class="toc-text">20.6.3. 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-4-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">20.6.4.</span> <span class="toc-text">20.6.4. 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-5-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.6.5.</span> <span class="toc-text">20.6.5. 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-6-%E7%94%A8%E6%B3%95"><span class="toc-number">20.6.6.</span> <span class="toc-text">20.6.6. 用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-7-shared-ptr-%E5%88%A0%E9%99%A4%E5%99%A8"><span class="toc-number">20.6.7.</span> <span class="toc-text">20.6.7. shared_ptr 删除器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-6-8-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">20.6.8.</span> <span class="toc-text">20.6.8. 注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-7-weak-ptr"><span class="toc-number">20.7.</span> <span class="toc-text">20.7. weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">20.7.1.</span> <span class="toc-text">20.7.1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-weak-ptr"><span class="toc-number">20.7.2.</span> <span class="toc-text">20.7.2. 为什么要使用 weak_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">20.7.3.</span> <span class="toc-text">20.7.3. 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-4-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">20.7.4.</span> <span class="toc-text">20.7.4. 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-5-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">20.7.5.</span> <span class="toc-text">20.7.5. 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-7-6-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">20.7.6.</span> <span class="toc-text">20.7.6. 注意点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#21-typename"><span class="toc-number">21.</span> <span class="toc-text">21. typename</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">21.1.</span> <span class="toc-text">21.1. 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-typename"><span class="toc-number">21.2.</span> <span class="toc-text">21.2. 为什么要用 typename ?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-3-%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">21.3.</span> <span class="toc-text">21.3. 注意点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#22-explicit-conversions-%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">22.</span> <span class="toc-text">22. explicit conversions(显示类型转换)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#22-1-static-cast"><span class="toc-number">22.1.</span> <span class="toc-text">22.1. static_cast&lt;&gt;()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-2-reinterpret-cast"><span class="toc-number">22.2.</span> <span class="toc-text">22.2. reinterpret_cast&lt;&gt;()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-3-dynamic-cast"><span class="toc-number">22.3.</span> <span class="toc-text">22.3. dynamic_cast&lt;&gt;()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-4-const-cast"><span class="toc-number">22.4.</span> <span class="toc-text">22.4. const_cast&lt;&gt;()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#23-exception-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">23.</span> <span class="toc-text">23. exception(异常处理)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#23-1-%E5%BC%82%E5%B8%B8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">23.1.</span> <span class="toc-text">23.1. 异常变量的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-2-%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">23.2.</span> <span class="toc-text">23.2. 异常的层次结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-3-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">23.3.</span> <span class="toc-text">23.3. 异常的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8"><span class="toc-number">23.4.</span> <span class="toc-text">23.4. 构造函数中的异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#24-Meaningful-aphorisms-%E9%9A%BD%E6%B0%B8%E8%AD%A6%E5%8F%A5"><span class="toc-number">24.</span> <span class="toc-text">24. Meaningful aphorisms (隽永警句)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#25-References-by-website-%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83"><span class="toc-number">25.</span> <span class="toc-text">25. References by website(学习参考)</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/CONVENTION/" title="CONVENTION">CONVENTION</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/README/" title="README">README</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/STARCHARTS/" title="STARCHARTS">STARCHARTS</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/AIGC/" title="AIGC">AIGC</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/ollama/" title="ollama">ollama</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Jeep</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>