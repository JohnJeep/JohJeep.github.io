<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>docker | Leaning Computer Science Journey</title><meta name="author" content="John Jeep"><meta name="copyright" content="John Jeep"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. 为什么会出现 Docker？为了解决运行环境和配置的问题。开发人员在部署好的机器上开发，开发完成后，交付给测试和运维人员，而他们也需要在相同的环境下进行测试和产品的运维，需要部署同样的环境。在部署的过程中可能会存在环境不一致的问题，需要去逐一解决，这样很费时、费力。那么有没有一种技术，测试人员或运维的人员直接将开发人员的部署的环境直接拿来用？将开发人员打包好的环境，类似像安装软件一样，直">
<meta property="og:type" content="article">
<meta property="og:title" content="docker">
<meta property="og:url" content="https://johnjeep.github.io/Docker/CloudNative/Docker/docker/index.html">
<meta property="og:site_name" content="Leaning Computer Science Journey">
<meta property="og:description" content="1. 为什么会出现 Docker？为了解决运行环境和配置的问题。开发人员在部署好的机器上开发，开发完成后，交付给测试和运维人员，而他们也需要在相同的环境下进行测试和产品的运维，需要部署同样的环境。在部署的过程中可能会存在环境不一致的问题，需要去逐一解决，这样很费时、费力。那么有没有一种技术，测试人员或运维的人员直接将开发人员的部署的环境直接拿来用？将开发人员打包好的环境，类似像安装软件一样，直">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://johnjeep.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-04T12:24:00.000Z">
<meta property="article:modified_time" content="2025-04-04T12:24:27.265Z">
<meta property="article:author" content="John Jeep">
<meta property="article:tag" content="cloudNative">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://johnjeep.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "docker",
  "url": "https://johnjeep.github.io/Docker/CloudNative/Docker/docker/",
  "image": "https://johnjeep.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-04T12:24:00.000Z",
  "dateModified": "2025-04-04T12:24:27.265Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Jeep",
      "url": "https://johnjeep.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://johnjeep.github.io/Docker/CloudNative/Docker/docker/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Jeep","link":"链接: ","source":"来源: Leaning Computer Science Journey","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'docker',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">docker</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">docker</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T12:24:27.265Z" title="更新于 2025-04-04 20:24:27">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Docker/">Docker</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!--
 * @Author: JohnJeep
 * @Date: 2023-03-30 15:33:52
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-04-04 19:29:39
 * @Description: Docker learning
 * Copyright (c) 2025 by John Jeep, All Rights Reserved. 
-->

<h1 id="1-为什么会出现-Docker？"><a href="#1-为什么会出现-Docker？" class="headerlink" title="1. 为什么会出现 Docker？"></a>1. 为什么会出现 Docker？</h1><p>为了解决运行环境和配置的问题。开发人员在部署好的机器上开发，开发完成后，交付给测试和运维人员，而他们也需要在相同的环境下进行测试和产品的运维，需要部署同样的环境。在部署的过程中可能会存在环境不一致的问题，需要去逐一解决，这样很费时、费力。那么有没有一种技术，测试人员或运维的人员直接将开发人员的部署的环境直接拿来用？将开发人员打包好的环境，类似像安装软件一样，直接安装在测试环境或运维环境的机器上。随着技术的发展，真的有这一门技术，那就是 Docker，直接将打好的包，形成一个镜像文件（image），通过 Docker 引擎（engine）部署到其他的操作系统上，实现了一次部署，处处运行。</p>
<h1 id="2-Thinking"><a href="#2-Thinking" class="headerlink" title="2. Thinking"></a>2. Thinking</h1><p>学习三部曲：理论、实操、总结</p>
<h1 id="3-Docker-是什么"><a href="#3-Docker-是什么" class="headerlink" title="3. Docker 是什么"></a>3. Docker 是什么</h1><p>Docker 是基于 Go 语言实现的云开源项目。主要目标是“build, ship and run any app, anywhere”，通过对应用组件的封装、分发、部署、运行等生命周期的管理，使用户的 APP 及运行环境能做到“一次镜像，处处运行”。</p>
<p>Docker 是在 Linux 容器技术的基础上发展起来的。将应用打包成镜像，通过镜像成为运行在 Docker 容器上面的示例。Docker 能运行在任何的操作系统上，实现了跨平台、跨服务器。只需要一次配置好环境，换到别的机器上就可以一键部署了，大大简化了操作。</p>
<p>从面向对象的角度看 docker：Docker 利用容器，独立运行一个或一组应用，这些程序或服务都在容器里面，容器就类似于一个虚拟化的运行环境，<strong>容器是镜像创建的运行实例</strong>。</p>
<p>从镜像的角度看 docker：可以把容器看做是一个简易版的 Linux 环境，包括 root 用户权限、进程空间、用户空间、网络空间等，还有一些应用程序。</p>
<h1 id="4-Docker-与传统虚拟机有什么不同？"><a href="#4-Docker-与传统虚拟机有什么不同？" class="headerlink" title="4. Docker 与传统虚拟机有什么不同？"></a>4. Docker 与传统虚拟机有什么不同？</h1><ol>
<li>传统虚拟机不仅在操作系统上模拟一套虚拟的硬件，还需要模拟出一个完成的操作系统，然后再模拟出的操作系统上运行所需的进程（即软件）。</li>
<li>Docker 容器它没有自己的内核，也没有进行硬件的虚拟化，Docker 容器内的应用进程直接运行在宿主机（安装 Docker 软件的操作系统）的内核上，因此 Docker 容器要比传统虚拟机更轻便，占用系统资源少。每个容器之间相互隔离，容器与容器之间的进程彼此个不影响，并且每个容器都有自己的文件系统。</li>
<li>Docker 是内核级虚拟化，不像传统的虚拟化技术需要额外的 Hypersion 支持，因此一台物理机器上可以运行多个容器的示例，大大提升了物理机器的 CPU 和 内存的利用率，节省了很多钱。</li>
</ol>
<h1 id="5-为什么-Docker-比虚拟机快？"><a href="#5-为什么-Docker-比虚拟机快？" class="headerlink" title="5. 为什么 Docker 比虚拟机快？"></a>5. 为什么 Docker 比虚拟机快？</h1><ul>
<li><p>Docker 有比虚拟机更少的抽象层。<br>由于 Docker 不需要 Hyperversion（虚拟机）实现硬件资源虚拟化，运行在 Docker 容器上的程序直接使用的是实际物理机器的硬件资源，因此 CPU、内存利用率在 Docker 上有跟明显的优势。</p>
<p><img src="/../figures/vm-container.jpg"></p>
</li>
<li><p>Docker 利用的是宿主机的内核，不需要加载操作系统的内核。<br>当新建一个容器时，Docker 不需要和虚拟机一样加载一个操作系统的内核，而是利用的是宿主机的内核，避免了操作系统的加载、寻址、系统内核返回等比较费时、费资源的过程。当新建一个虚拟机时，虚拟机软件需要先加载操作系统，然后再返回，这个过程是非常耗时的，分钟级别的，而 Docker 则是直接省略了这一过程，新建一个 Docker 容器只需要几秒钟，非常的快。</p>
</li>
</ul>
<p>Docker 优点</p>
<ul>
<li>轻便：Docker 是基于容器的虚拟化，仅包含业务运行所需要的环境。</li>
<li>高效：不需要操作系统的虚拟化开销。</li>
<li>灵活性更高：支持多网络配置、分层存储和包管理。</li>
</ul>
<h1 id="6-Windows系统上为什么能运行-Docker？"><a href="#6-Windows系统上为什么能运行-Docker？" class="headerlink" title="6. Windows系统上为什么能运行 Docker？"></a>6. Windows系统上为什么能运行 Docker？</h1><p>Docker在早期是只专注于Linux虚拟化实现的一种容器技术，因为Linux得天独厚的 Namespace 和 CGroup 等系统内隔离机制特性，使得在 Linux更易实现，在经过容器技术的疯狂发展推崇之后，微软看到了这一红利，在于2014 年宣布与 Docker 公司合作，将容器技术迁移到 Windows 上，这一动作让 Windows 改变了过去，只能通过VM等大型虚拟机软件通过装Linux来装Docker的现状，现在也可以很轻量级的将Docker融入系统中使用了。由于Windows系统和Linux在实现上还是有些差别，尽管我们在Docker上的操作大致相同，仍然需要注意一些事项。</p>
<p>没有安装 WSL 的Windows，运行 Docker 原理：</p>
<blockquote>
<p>Docker 在 Windows 系统上安装时，Docker 会创建一个基于Linux的虚拟机，叫做 MobyLinuxVM 虚拟机，这个虚拟机是基于Alpine Linux的。Docker应用程序会连接到此虚拟机，你便可以开始创建具有必要操作组件的容器了。为了与本地网络和NAT（网络地址转换）进行通信，在Docker安装中会为虚拟机配置一个子网，以便你的容器在应用程序中使用。不过不必担心，MobyLinuxVM虚拟机是运行在Hyper-V，这是Windows是一项虚拟化技术，相比虚拟机之类的非常轻量级，容器可以共享主机内核，任务管理器里面可以看到对应进程。</p>
</blockquote>
<h1 id="7-Docker-Component"><a href="#7-Docker-Component" class="headerlink" title="7. Docker Component"></a>7. Docker Component</h1><p>Docker 中有三个重要的组件：Image，Container，Repository。只有理解了这些概念后，学习 Docker 就很轻松了。</p>
<p><img src="/../figures/docker-container-component.jpg"></p>
<ul>
<li><p>镜像（Image）</p>
<ul>
<li>Docker 镜像是一个特殊的文件系统，用来创建 Docker 容器，一个镜像可以创建很多个容器。比如 CentOS7 官方镜像。</li>
<li>Docker 中除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。</li>
<li>镜像不包含任何的动态数据，镜像中的内容在构建之后不会再被改变。</li>
</ul>
</li>
<li><p>容器（Container）</p>
<ul>
<li>Docker 利用容器，独立运行一个或一组应用，而应用程序或服务都运行在容器里面。</li>
<li>容器就类似于一个虚拟化的运行环境，容器是镜像创建运行时的实例，就像是面向对象程序设计中的<strong>类</strong> 和 <strong>实例</strong> 一样，镜像相当于<strong>类</strong>，容器相当于<strong>类的实例</strong>。</li>
<li>容器为镜像提供了一个标准的、容器之间相互隔离的运行环境，容器可以被创建、启动、停止、删除、暂停等。</li>
<li>创建的容器有两部分组成：一个是最小最核心的赖以生存的 Linux 内核文件，另一个是具体的应用程序。</li>
</ul>
</li>
<li><p>仓库（Repository）</p>
<ul>
<li>集中存放镜像文件的地方，类似 Git 的远程仓库。</li>
<li>仓库分为私有仓库和公开的仓库。私有仓库：比如公司内部搭建专门存放镜像文件的地方；公共仓库：任何人都能访问专门存放镜像文件的地方。全球最大的公开仓库是 Dockerhub(<a target="_blank" rel="noopener" href="https://hub.docker.com).在中国境内由于一些著名的原因,访问/">https://hub.docker.com)。在中国境内由于一些著名的原因，访问</a> Dockerhub 仓库比较慢，可以配置国内的镜像仓库，比如阿里云、网易等等。</li>
</ul>
</li>
</ul>
<h2 id="7-1-Docker-镜像加载原理"><a href="#7-1-Docker-镜像加载原理" class="headerlink" title="7.1. Docker 镜像加载原理"></a>7.1. Docker 镜像加载原理</h2><p>Docker 镜像实际上由一层一层的文件系统组成的，这种文件系统叫 UnionFS（联合文件系统）。Docker 镜像底层是引导文件系统 <code>bootfs</code>，这一层与典型的 Linux&#x2F;Unix 系统是一样的，包含 boot 加载器和内核。当 boot 加载完成之后，整个内核就存在与内存中了，此时的内存权已由 bootfs 转移给内核，然后系统会卸载 bootfs。</p>
<blockquote>
<p>bootfs 全名叫 boot file system，主要包含 BootLoader 和 kernel，BootLoader 主要是引导加载 kernel，Linux 刚启动时会加载 bootfs 文件系统。</p>
</blockquote>
<blockquote>
<p>rootfs（root file system）在 bootfs 文件系统之上，包含的是 Linux 系统中的 <code>/dev</code>、<code>/proc</code>、<code>/bin</code>、<code>/etc</code> 等标准目录和文件。rootfs 就是各种不同的操作系统的发行版，比如 Ubuntu、Redhat等。</p>
</blockquote>
<p>对于一个精简的 OS，rootfs 可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用 Host 的kernel，自己只需要提供 rootfs 就行了。可见对于不同的 Linux 发行版，bootfs 基本是一致的，rootfs 会有差别，因此不同的发行版可以公用 bootfs。</p>
<h2 id="7-2-Docker-image-layer"><a href="#7-2-Docker-image-layer" class="headerlink" title="7.2. Docker image layer"></a>7.2. Docker image layer</h2><p>Docker 镜像层是 <strong>只读</strong> 的，容器层是 <strong>可写</strong> 的。当容器启动时，一个新的、具有写权限的层被加载到容器的顶部，这一层通常成为“容器层”，容器层之下的都叫“镜像层”。所有对容器的添加、删除、修改等操作都只会发生在容器层中。</p>
<p>镜像层</p>
<p><img src="/../figures/images-layers.jpg" alt="images-layers"></p>
<p>容器层</p>
<p><img src="/../figures/container-layers.jpg"></p>
<p>Docker 镜像分层的优点：资源共享、方便复制迁移。比如：有多个镜像都是从相同的基类镜像（base）构建而来，那么 docker Host 只需在磁盘上保存一份 base 镜像，同时内存中也只需要加载一份 base 镜像，就可以为所有的容器服务了。</p>
<p><img src="/../figures/container-base-images.png"></p>
<h2 id="7-3-Docker-原理"><a href="#7-3-Docker-原理" class="headerlink" title="7.3. Docker 原理"></a>7.3. Docker 原理</h2><p><img src="/../figures/docker-view.png"></p>
<h1 id="8-Docker-Architecture"><a href="#8-Docker-Architecture" class="headerlink" title="8. Docker Architecture"></a>8. Docker Architecture</h1><p><img src="/../figures/docker-architecture.jpg"></p>
<p>Docker 是一个 Client-Server 结构的系统，Docker 守护进程（daemon）运行在主机（host）上，然后通过 Socket 连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。</p>
<p><img src="/../figures/docker-c_s.png"></p>
<h2 id="8-1-Docker-运行流程"><a href="#8-1-Docker-运行流程" class="headerlink" title="8.1. Docker 运行流程"></a>8.1. Docker 运行流程</h2><ol>
<li>用户是使用 Docker Client 与 Docker Daemon建立通信，并发送请求给 Docker daemon。</li>
<li>Docker Daemon 作为 Docker 架构中的主体部分，苜先提供 Docker Server 的功能使其可以接受 Docker Client的请求。</li>
<li>Docker Engine 执行 Docker 内部一系列工作，每一项工作都是以一个 Job 的形式的存在。</li>
<li>Job 运行的过程中，当需要容器镜像时，则从 Docker Registry 中下镜像，并通过镜像管理驱动 Graph drver 将下载镜像以 Grap 的形式存储。</li>
<li>当需要为 Docker 创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</li>
<li>当需要限制 Docker 容器运行资源或执行用户指令等操作时，则通过 exec driver 来完成。</li>
<li>libcantainer 是一项独立的容器管鋰包，network driver 以及 exec driver 都是通过 libcontainer 来实现具体对容器操作。</li>
</ol>
<h1 id="9-Docker-Command"><a href="#9-Docker-Command" class="headerlink" title="9. Docker Command"></a>9. Docker Command</h1><p>运行 Docker 的格式：<code>docker [OPTIONS] COMMAND</code></p>
<p>说明：</p>
<ul>
<li><code>docker</code> 为 docker 引擎的前缀，表示通过 docker 来执行命令。 </li>
<li>带有 <code>[]</code> 部分是可选项，这部分可要可不要，根据具体情况来定。</li>
<li><code>COMMAND</code> 是必须的，要运行的 Docker  命令。</li>
</ul>
<p>Docker 官方命令参考：<a target="_blank" rel="noopener" href="https://docs.docker.com/reference/">https://docs.docker.com/reference/</a></p>
<h2 id="9-1-help"><a href="#9-1-help" class="headerlink" title="9.1. help"></a>9.1. help</h2><p>start, stop, status docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl start docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止服务</span></span><br><span class="line">systemctl stop docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 服务运行状态</span></span><br><span class="line">systemctl status docker</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置 Docker 开机启动</span></span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>help 信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看Docker版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 概要信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 总体帮助文档</span></span><br><span class="line">docker --help</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 Docker 命令帮助文档，<span class="built_in">command</span> 指具体的命令</span></span><br><span class="line">docker command --help </span><br></pre></td></tr></table></figure>

<p>其它</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">卸载相关依赖</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> yum remove docker-ce docker-ce-cli containerd.io</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清空工作路径</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span></span><br></pre></td></tr></table></figure>

<h2 id="9-2-Container-Command"><a href="#9-2-Container-Command" class="headerlink" title="9.2. Container Command"></a>9.2. Container Command</h2><h3 id="9-2-1-docker-run"><a href="#9-2-1-docker-run" class="headerlink" title="9.2.1. docker run"></a>9.2.1. docker run</h3><p>在一个新的容器中运行一条命令。在指定的镜像中创建一个具有写权限的容器层（container layer），然后运行指定的命令。</p>
<p>用法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</span><br></pre></td></tr></table></figure>

<p>Docker run中的可选项</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS:</span><br><span class="line">  -i, --interactive   交互式运行容器</span><br><span class="line">  -t, --tty           给容器重新分配一个伪终端（pseudo-TTY）</span><br><span class="line">  -p(小写)            拉 container 的端口号到主机（host）上</span><br><span class="line">  -P(大写)            随机分配一个端口号</span><br><span class="line">  -d, --detach       后台运行容器和打印容器ID</span><br><span class="line">  --name=“容器名字”   给容器分配一个名字，不指定名字时，docker 会随机分配一个</span><br></pre></td></tr></table></figure>

<p>要启动 docker，运行 <code>Docker run</code> 命令即可，我们思考下，执行 <code>docker run</code> 命令 docker 引擎都干了什么。底层是怎样实现的？</p>
<p><img src="/../figures/docker-run.png"></p>
<p>示例1</p>
<p><code>docker run -it 36c607e7b14d /bin/bash</code>  命令表示：交互式启动一个镜像 ID 为 <code>36c607e7b14d</code> 的 zookeeper 容器，并在容器中执行  <code>/bin/bash</code> 命令。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker images</span><br><span class="line">REPOSITORY           TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">wurstmeister/kafka   latest    2dd91ce2efe1   2 weeks ago    508MB</span><br><span class="line">zookeeper            latest    36c607e7b14d   3 weeks ago    278MB</span><br><span class="line">hello-world          latest    feb5d9fea6a5   3 months ago   13.3kB</span><br><span class="line">[root@redis_181 ~]# docker run -it 36c607e7b14d /bin/bash</span><br><span class="line">root@c9fa3e7753a5:/apache-zookeeper-3.7.0-bin#</span><br></pre></td></tr></table></figure>

<p>示例2</p>
<p>交互式的方式启动一个容器，并给容器起一个新名字，同时分配一个伪终端。在标准输入中用 bash 命令启动伪终端。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker run -it --name=kafka wurstmeister/kafka /bin/bash</span><br><span class="line">bash-5.1#</span><br></pre></td></tr></table></figure>

<p>示例3</p>
<p>后台运行 Docker 容器</p>
<p>前提：要想 Docker 容器在后台运行，就必须有一个前台进程。若果容器运行的命令不是那些一直挂起的命令（比如：tail，top等），容器启动后就会自动退出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker run -d redis:6.0.8</span><br><span class="line">77e61214ea8c95c007dc02928d01179ba964e63a9c1861a870fedb6f4938dd56</span><br></pre></td></tr></table></figure>

<h3 id="9-2-2-docker-ps"><a href="#9-2-2-docker-ps" class="headerlink" title="9.2.2. docker ps"></a>9.2.2. docker ps</h3><p>列出本地主机中当前正在运行的容器信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -a, --all             Show all containers (default shows just running)</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print containers using a Go template</span><br><span class="line">  -n, --last int        Show n last created containers (includes all states) (default -1)</span><br><span class="line">  -l, --latest          Show the latest created container (includes all states)</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">  -q, --quiet           Only display container IDs</span><br><span class="line">  -s, --size            Display total file sizes</span><br><span class="line"></span><br><span class="line">[root@redis_181 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">176f87942045   wurstmeister/kafka   &quot;bash&quot;        5 seconds ago   Up 5 seconds             angry_pike</span><br><span class="line">ab67455c4ee2   wurstmeister/kafka   &quot;/bin/bash&quot;   2 minutes ago   Up 2 minutes             kafka</span><br><span class="line"></span><br><span class="line"># 查看本地主机中的所有容器</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>

<h3 id="9-2-3-exit"><a href="#9-2-3-exit" class="headerlink" title="9.2.3. exit"></a>9.2.3. exit</h3><p>从容器中退出。退出容器有两种方式：</p>
<ol>
<li>容器中执行 <code>exit</code> 命令后，直接退出，同时容器也停止了。</li>
<li>按 <code>Ctrl + p + q</code> 组合命令后，退出容器，当容器不停止，后台还在运行。</li>
</ol>
<h3 id="9-2-4-docker-start"><a href="#9-2-4-docker-start" class="headerlink" title="9.2.4. docker start"></a>9.2.4. docker start</h3><p>启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start &lt;容器id或容器名&gt;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-5-docker-stop"><a href="#9-2-5-docker-stop" class="headerlink" title="9.2.5. docker stop"></a>9.2.5. docker stop</h3><p>关闭容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker stop &lt;容器id或容器名&gt;</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">  批量停止所有的容器</span><br><span class="line">  docker stop $(docker ps -a | awk &#x27;&#123;print $1&#125;&#x27;| tail -n +2)</span><br></pre></td></tr></table></figure>

<h3 id="9-2-6-docker-restart"><a href="#9-2-6-docker-restart" class="headerlink" title="9.2.6. docker restart"></a>9.2.6. docker restart</h3><p>重启容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart &lt;容器ID或容器名&gt;</span><br></pre></td></tr></table></figure>


<h3 id="9-2-7-docker-kill"><a href="#9-2-7-docker-kill" class="headerlink" title="9.2.7. docker kill"></a>9.2.7. docker kill</h3><p>强制停止容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill &lt;容器ID或容器名&gt;</span><br></pre></td></tr></table></figure>


<h3 id="9-2-8-docker-rm"><a href="#9-2-8-docker-rm" class="headerlink" title="9.2.8. docker rm"></a>9.2.8. docker rm</h3><p>删除以停止的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器ID或容器名&gt;</span><br></pre></td></tr></table></figure>


<h3 id="9-2-9-docker-top"><a href="#9-2-9-docker-top" class="headerlink" title="9.2.9. docker top"></a>9.2.9. docker top</h3><p>显示一个容器内部运行的进程。<br>用法：<code>docker top CONTAINER [ps OPTIONS]</code></p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker ps</span><br><span class="line">  CONTAINER ID   IMAGE         COMMAND                  CREATED          STATUS          PORTS      NAMES</span><br><span class="line">  77e61214ea8c   redis:6.0.8   &quot;docker-entrypoint.s…&quot;   15 seconds ago   Up 13 seconds   6379/tcp   focused_almeida</span><br><span class="line"></span><br><span class="line">[root@redis_181 ~]# docker top 77e61214ea8c</span><br><span class="line">  UID        PID      PPID        C       STIME  TTY        TIME    CMD</span><br><span class="line">  polkitd             9516        9497    0      08:17     ?       00:00:00            redis-server *:6379</span><br></pre></td></tr></table></figure>

<h3 id="9-2-10-docker-inspect"><a href="#9-2-10-docker-inspect" class="headerlink" title="9.2.10. docker inspect"></a>9.2.10. docker inspect</h3><p>查看容器的内部细节信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker inspect [OPTIONS] NAME|ID [NAME|ID...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -f, --format string   Format the output using the given Go template</span><br><span class="line">  -s, --size            Display total file sizes if the type is container</span><br><span class="line">      --type string     Return JSON for specified type</span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line">    docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<h3 id="9-2-11-docker-exec"><a href="#9-2-11-docker-exec" class="headerlink" title="9.2.11. docker exec"></a>9.2.11. docker exec</h3><p>重新进入原先已退出的容器内部。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker exec [OPTIONS] CONTAINER COMMAND [ARG...]</span><br><span class="line"></span><br><span class="line">[OPTIONS]:</span><br><span class="line">  -d, --detach 在容器中后台执行命令； </span><br><span class="line">  -i, --interactive=true | false ：打开标准输入接受用户输入命令</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;容器ID&gt; /bin/bash</span><br><span class="line"></span><br><span class="line"># 使用 /bin/bash 命令前台交互的重新进入到容器内部 </span><br><span class="line">[root@redis_181 ~]# docker exec -it 77e61214ea8c /bin/bash</span><br><span class="line">root@77e61214ea8c:/data#</span><br></pre></td></tr></table></figure>

<h3 id="9-2-12-docker-attach"><a href="#9-2-12-docker-attach" class="headerlink" title="9.2.12. docker attach"></a>9.2.12. docker attach</h3><p>重新进入原先已退出的容器内部，并将本地标准输入、输出和错误流附加到正在运行的容器。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker attach [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  --detach-keys string   Override the key sequence <span class="keyword">for</span> detaching a container</span><br><span class="line">  --no-stdin             Do not attach STDIN</span><br><span class="line">  --sig-proxy            Proxy all received signals to the process (default <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>注意：<code>docker exec</code> 与 <code>docker attach</code> 的区别</p>
<ul>
<li><p><code>docker attach</code>  直接进入容器命令行的终端，不会启动新的进程，用 <code>exit</code> 命令退出容器时，会导致容器停止。</p>
<p>外部终端查看 docker 容器的 ID</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">86fcdb251eb9   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>   6 minutes ago   Up 6 minutes             romantic_murdock</span><br></pre></td></tr></table></figure>

<p>指定容器 ID，进入 docker 容器内部</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# docker attach 86fcdb251eb9</span><br><span class="line">root@86fcdb251eb9:/#</span><br><span class="line">root@86fcdb251eb9:/# <span class="built_in">ls</span></span><br><span class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br></pre></td></tr></table></figure>

<p>执行 <code>exit</code> 命令退出容器后，再次查看容器的进程，发现容器没有跑起来，已经停止运行了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@86fcdb251eb9:/# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@CentOS7 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行 <code>docker exec</code> 是在容器内部打开新的终端，并且可以启动新的进程，用 <code>exit</code> 命令退出容器时，不会导致容器停止。</p>
<p>外部终端查看 docker 容器的 ID</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES</span><br><span class="line">178c5e88904a   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>   20 seconds ago   Up 19 seconds             eager_ellisS</span><br></pre></td></tr></table></figure>

<p>指定容器 ID 和命令，比如指定 ID 为 <code>178c5e88904a</code> 的容器，以交互式的方式重新打开一个伪终端后进入容器内部。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@CentOS7 ~]# docker <span class="built_in">exec</span> -it 178c5e88904a  /bin/bash</span><br><span class="line">root@178c5e88904a:/#</span><br></pre></td></tr></table></figure>

<p>执行 <code>exit</code> 命令退出容器后，再次查看容器的进程，发现容器还在后台运行，并没有停止。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@178c5e88904a:/# <span class="built_in">exit</span></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">[root@CentOS7 ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS         PORTS     NAMES</span><br><span class="line">178c5e88904a   ubuntu    <span class="string">&quot;/bin/bash&quot;</span>   3 minutes ago   Up 3 minutes             eager_ellis</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="9-2-13-docker-cp"><a href="#9-2-13-docker-cp" class="headerlink" title="9.2.13. docker cp"></a>9.2.13. docker cp</h3><p>在容器和本地文件系统（本地主机）之间拷贝文件或文件夹。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH</span><br><span class="line">    docker cp [OPTIONS] SRC_PATH CONTAINER:DEST_PATH</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -a, --archive       Archive mode (copy all uid/gid information)</span><br><span class="line">  -L, --follow-link   Always follow symbol link in SRC_PATH</span><br></pre></td></tr></table></figure>

<h3 id="9-2-14-docker-logs"><a href="#9-2-14-docker-logs" class="headerlink" title="9.2.14. docker logs"></a>9.2.14. docker logs</h3><p>查看容器内部日志</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker logs [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">      --details        Show extra details provided to logs</span><br><span class="line">  -f, --follow         Follow log output</span><br><span class="line">      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br><span class="line">  -n, --tail string    Number of lines to show from the end of the logs (default &quot;all&quot;)</span><br><span class="line">  -t, --timestamps     Show timestamps</span><br><span class="line">      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)</span><br></pre></td></tr></table></figure>

<h3 id="9-2-15-docker-export"><a href="#9-2-15-docker-export" class="headerlink" title="9.2.15. docker export"></a>9.2.15. docker export</h3><p>导出一个容器文件系统作为一个 tar 包。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker <span class="built_in">export</span> [OPTIONS] CONTAINER</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>


<p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE                COMMAND                  CREATED          STATUS                    PORTS      NAMES</span><br><span class="line">302e76d7a7af   redis:6.0.8          <span class="string">&quot;docker-entrypoint.s…&quot;</span>   19 minutes ago   Up 19 minutes             6379/tcp   elated_feistel</span><br><span class="line">bdbd7d438f8f   hello-world          <span class="string">&quot;/hello&quot;</span>                 2 days ago       Exited (0) 2 days ago                elastic_chaplygin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面两种方式是等效的</span></span><br><span class="line">[root@redis_181 ~]# docker <span class="built_in">export</span> bdbd7d438f8f &gt; hello.tar</span><br><span class="line">                    hello.tar </span><br><span class="line"></span><br><span class="line">[root@redis_181 ~]# docker <span class="built_in">export</span> -o=<span class="string">&quot;hw.tar&quot;</span> bdbd7d438f8f</span><br><span class="line">                    hw.tar  </span><br></pre></td></tr></table></figure>

<h3 id="9-2-16-docker-import"><a href="#9-2-16-docker-import" class="headerlink" title="9.2.16. docker import"></a>9.2.16. docker import</h3><p>从 tar 包中的内容创建一个新的文件系统，再导入为 Docker 镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">  docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -c, --change list       Apply Dockerfile instruction to the created image</span><br><span class="line">  -m, --message string    Set commit message <span class="keyword">for</span> imported image</span><br><span class="line">      --platform string   Set platform <span class="keyword">if</span> server is multi-platform capable</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号</span></span><br><span class="line">    [root@redis_181 ~]# <span class="built_in">cat</span> hello.tar | docker import - john/hello:5.0</span><br><span class="line">    sha256:ed584048180e082610c982dc8f56ccf9618872f80d5848d0e8c840dfd46c13bc</span><br><span class="line">    [root@redis_181 ~]# docker images</span><br><span class="line">    REPOSITORY           TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">    john/hello           5.0       ed584048180e   12 seconds ago   13.3kB</span><br><span class="line">    wurstmeister/kafka   latest    2dd91ce2efe1   2 weeks ago      508MB</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 从远程位置导入</span></span><br><span class="line">   docker import https://example.com/exampleimage.tgz</span><br><span class="line"></span><br><span class="line"> <span class="comment"># 从本地文件中导入</span></span><br><span class="line">   docker import /path/to/exampleimage.tgz</span><br></pre></td></tr></table></figure>

<h2 id="9-3-Image-Command"><a href="#9-3-Image-Command" class="headerlink" title="9.3. Image Command"></a>9.3. Image Command</h2><h3 id="9-3-1-docker-images"><a href="#9-3-1-docker-images" class="headerlink" title="9.3.1. docker  images"></a>9.3.1. docker  images</h3><p>列出本地主机上已下载的所有 Docker 镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker images [OPTIONS] [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -a, --all   显示所有的镜像，包括默认隐藏的中间镜像（历史镜像）</span><br><span class="line">  -q, --quiet 只显示镜像 ID</span><br></pre></td></tr></table></figure>


<p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker images</span><br><span class="line">REPOSITORY           TAG       IMAGE ID       CREATED        SIZE</span><br><span class="line">wurstmeister/kafka   latest    2dd91ce2efe1   2 weeks ago    508MB</span><br><span class="line">zookeeper            latest    36c607e7b14d   3 weeks ago    278MB</span><br><span class="line">hello-world          latest    feb5d9fea6a5   3 months ago   13.3kB</span><br></pre></td></tr></table></figure>

<p>显示结果说明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY：镜像的仓库源</span><br><span class="line">TAG：镜像的标签版本号</span><br><span class="line">IMAGE ID：镜像 ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure>

<p>同一个仓库源可以有多个 TAG 版本，说明仓库源有不同的版本，用 <code>REPOSITORY:TAG</code> 来表示不同的镜像。<br>比如 <code>redis:6.0.8</code> 表示从仓库源获取的是 redis 版本为6.0.8 ，<br>在这个 Docker engine 中还可以拉取 redis 版本为 5.0 的仓库源，用 <code>redis:5.0</code> 表示，二者可以同时共存。<br>若在拉取镜像时不指定镜像的标签版本，Docker 将默认使用 TAG 为 latest 的版本（最新版本）。</p>
<h3 id="9-3-2-docker-search"><a href="#9-3-2-docker-search" class="headerlink" title="9.3.2. docker  search"></a>9.3.2. docker  search</h3><p>从仓库源中搜索某个镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker search [OPTIONS] TERM</span><br><span class="line"></span><br><span class="line">OPTIONS：</span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-<span class="built_in">print</span> search using a Go template</span><br><span class="line">      --<span class="built_in">limit</span> int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don<span class="string">&#x27;t truncate output</span></span><br></pre></td></tr></table></figure>


<p>显示结果说明</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker search redis</span><br><span class="line">NAME                             DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">redis                            Redis is an open <span class="built_in">source</span> key-value store that…   10443     [OK]</span><br><span class="line">grokzen/redis-cluster            Redis cluster 3.0, 3.2, 4.0, 5.0, 6.0, 6.2      83</span><br><span class="line">sameersbn/redis                                                                  83                   [OK]</span><br><span class="line">rediscommander/redis-commander   Alpine image <span class="keyword">for</span> redis-commander - Redis man…   73                   [OK]</span><br><span class="line">redislabs/redisearch             Redis With the RedisSearch module pre-loaded…   47</span><br><span class="line">redislabs/rejson                 RedisJSON - Enhanced JSON data <span class="built_in">type</span> processi…   39</span><br><span class="line">redislabs/redisinsight           RedisInsight - The GUI <span class="keyword">for</span> Redis                35</span><br><span class="line">redislabs/redis                  Clustered in-memory database engine compatib…   32</span><br><span class="line">oliver006/redis_exporter          Prometheus Exporter <span class="keyword">for</span> Redis Metrics. Supp…   31</span><br><span class="line">arm32v7/redis                    Redis is an open <span class="built_in">source</span> key-value store that…   24</span><br><span class="line">arm64v8/redis                    Redis is an open <span class="built_in">source</span> key-value store that…   19</span><br><span class="line">redislabs/rebloom                A probablistic datatypes module <span class="keyword">for</span> Redis       18                   [OK]</span><br><span class="line">redislabs/redisgraph             A graph database module <span class="keyword">for</span> Redis               17                   [OK]</span><br><span class="line">redislabs/redismod               An automated build of redismod - latest Redi…   17                   [OK]</span><br><span class="line">webhippie/redis                  Docker image <span class="keyword">for</span> redis                          11                   [OK]</span><br><span class="line">insready/redis-stat              Docker image <span class="keyword">for</span> the real-time Redis monitor…   10                   [OK]</span><br><span class="line">s7anley/redis-sentinel-docker    Redis Sentinel                                  10                   [OK]</span><br><span class="line">redislabs/redistimeseries        A <span class="keyword">time</span> series database module <span class="keyword">for</span> Redis         10</span><br><span class="line">goodsmileduck/redis-cli          redis-cli on alpine                             9                    [OK]</span><br><span class="line">centos/redis-32-centos7          Redis in-memory data structure store, used a…   6</span><br><span class="line">clearlinux/redis                 Redis key-value data structure server with t…   3</span><br><span class="line">wodby/redis                      Redis container image with orchestration        1                    [OK]</span><br><span class="line">tiredofit/redis                  Redis Server w/ Zabbix monitoring and S6 Ove…   1                    [OK]</span><br><span class="line">xetamus/redis-resource           forked redis-resource                           0                    [OK]</span><br><span class="line">flant/redis-sentinel-proxy       Redis sentinel proxy by enriclluelles writte…   0                    [OK]</span><br></pre></td></tr></table></figure>

<ul>
<li>NAME：镜像名称</li>
<li>DESCRIPTION：镜像说明</li>
<li>STARS：点赞数量</li>
<li>OFFICIAL：是否是官方的</li>
<li>AUTOMATED：是否是自动构建的</li>
</ul>
<h3 id="9-3-3-docker-pull"><a href="#9-3-3-docker-pull" class="headerlink" title="9.3.3. docker pull"></a>9.3.3. docker pull</h3><p>从仓库源中拉取指定的镜像或仓库</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker pull [OPTIONS] NAME[:TAG|@DIGEST]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -a, --all-tags                Download all tagged images <span class="keyword">in</span> the repository</span><br><span class="line">      --disable-content-trust   Skip image verification (default <span class="literal">true</span>)</span><br><span class="line">      --platform string         Set platform <span class="keyword">if</span> server is multi-platform capable</span><br><span class="line">  -q, --quiet                   Suppress verbose output</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">从 docker 仓库中拉取 redis 镜像，拉取时不指定版本，Docker 引擎默认从仓库源拉取最新的版本</span><br><span class="line">[root@redis_181 ~]# docker pull redis</span><br><span class="line"></span><br><span class="line">拉取时指定版本 TAG</span><br><span class="line">[root@redis_181 ~]# docker pull redis:6.0.8</span><br></pre></td></tr></table></figure>

<h3 id="9-3-4-docker-rmi"><a href="#9-3-4-docker-rmi" class="headerlink" title="9.3.4. docker rmi"></a>9.3.4. docker rmi</h3><p>删除指定的镜像（rmi: Remove one or more images）</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">    docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -f, --force      Force removal of the image</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<ol>
<li><p>删除单个镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker rmi -f hello-world</span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:975f4b14f326b05db86e16de00144f9c12257553bba9484fed41f9b6f2257800</span><br><span class="line">Deleted: sha256:feb5d9fea6a5e9606aa995e879d862b825965ba48de054caab5ef356dc6b3412</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除多个镜像</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker rmi -f redis:6.0.8 rdis:5.0</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用脚本：删除以myapp开头的所有镜像</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">for</span> image <span class="keyword">in</span> $(docker images | grep <span class="string">&#x27;^myapp&#x27;</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>); <span class="keyword">do</span></span><br><span class="line">    docker rmi -f <span class="variable">$image</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用参数续传来删除，将查找到的 Ubuntu 镜像 ID 传入要删除的表达式后面<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker rmi -f $(docker images -q ubuntu)</span><br><span class="line">Untagged: ubuntu:latest</span><br><span class="line">Untagged: ubuntu@sha256:b5a61709a9a44284d88fb12e5c48db0409cfad5b69d4ff8224077c57302df9cf</span><br><span class="line">Deleted: sha256:d13c942271d66cb0954c3ba93e143cd253421fe0772b8bed32c4c0077a546d4d</span><br><span class="line">Deleted: sha256:0eba131dffd015134cb310c284b776c1e44d330146cd2f0e30c4e464d0b76d24</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="9-3-5-docker-system-df"><a href="#9-3-5-docker-system-df" class="headerlink" title="9.3.5. docker system df"></a>9.3.5. docker system df</h3><p>查看镜像、容器、数据卷所占用的空间大小</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker system df</span><br><span class="line">TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE</span><br><span class="line">Images          3         3         785.9MB   0B (0%)</span><br><span class="line">Containers      5         0         344B      344B (100%)</span><br><span class="line">Local Volumes   5         5         2B        0B (0%)</span><br><span class="line">Build Cache     0         0         0B        0B</span><br><span class="line"></span><br><span class="line">可选项</span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">清理磁盘，删除关闭的容器、无用的数据卷和网络，以及无tag的镜像</span></span><br><span class="line">	docker system prune</span><br><span class="line"><span class="meta prompt_">	</span></span><br><span class="line"><span class="meta prompt_">	# </span><span class="language-bash">清理掉所有的 Docker 镜像，包括你暂时关闭的容器，以及暂时没有使用的 docker 镜像</span></span><br><span class="line">	docker system prune -a</span><br></pre></td></tr></table></figure>

<p>显示结果说明</p>
<ul>
<li>TYPE：类型</li>
<li>TOTAL：总数</li>
<li>ACTIVE：激活状态</li>
<li>SIZE：大小</li>
<li>RECLAIMABLE：可回收</li>
</ul>
<h3 id="9-3-6-docker-save"><a href="#9-3-6-docker-save" class="headerlink" title="9.3.6. docker save"></a>9.3.6. docker save</h3><p>保存一个或多个镜像到 <code>tar</code> 包中，默认是通过标准输出流。 </p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">  docker save [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -o, --output string   Write to a file, instead of STDOUT</span><br></pre></td></tr></table></figure>

<h3 id="9-3-7-docker-load"><a href="#9-3-7-docker-load" class="headerlink" title="9.3.7. docker load"></a>9.3.7. docker load</h3><p>从一个 <code>tar</code> 包或标准输入中导入 Docker 镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">  docker load [OPTIONS]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -i, --input string   Read from tar archive file, instead of STDIN</span><br><span class="line">  -q, --quiet          Suppress the load output</span><br></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种方式都是等效的</span></span><br><span class="line">docker load --input fedora.tar</span><br><span class="line"></span><br><span class="line">docker load &lt; busybox.tar.gz</span><br><span class="line"></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="9-3-8-docker-build"><a href="#9-3-8-docker-build" class="headerlink" title="9.3.8. docker build"></a>9.3.8. docker build</h3><p>从一个 Dockerfile 中构建一个 Docker 镜像。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用法</span><br><span class="line">docker build [OPTIONS] PATH | URL | -</span><br></pre></td></tr></table></figure>

<h1 id="10-Docker-下安装软件"><a href="#10-Docker-下安装软件" class="headerlink" title="10. Docker 下安装软件"></a>10. Docker 下安装软件</h1><p>Docker下安装软件的步骤</p>
<ol>
<li>搜索镜像。去docker 官网去搜索镜像。</li>
<li>拉取镜像</li>
<li>查看镜像</li>
<li>启动镜像：注意端口映射。</li>
<li>停止容器</li>
<li>移除容器</li>
</ol>
<h1 id="11-Docker-Volume"><a href="#11-Docker-Volume" class="headerlink" title="11. Docker Volume"></a>11. Docker Volume</h1><h2 id="11-1-Volume-是什么？"><a href="#11-1-Volume-是什么？" class="headerlink" title="11.1. Volume 是什么？"></a>11.1. Volume 是什么？</h2><p>卷就是目录或文件，存在于一个或多个容器中，由 docker 挂载到容器，但不属于联合文件系统，因此能绕过联合文件系统（Union File System）提供一些用于持续存储或共享数据的特性。</p>
<p>卷的设计目的：就是数据的持久化，完全独立于容器的生存周期，因此 docker 不会在容器删除时删除其挂载的数据卷。</p>
<p>命令用法</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录    镜像名</span><br><span class="line"></span><br><span class="line">// 实例</span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /home/docker_data:/data  --name redis-7 redis /bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 默认情况下，容器内的目录具有读写权限：rW</span><br><span class="line">// 限制容器内的权限，具有只读属性 ro</span><br><span class="line">docker run -it --privileged=<span class="literal">true</span> -v /宿主机绝对路径目录:/容器内目录:ro    镜像名</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="11-2-Volume-能干吗？"><a href="#11-2-Volume-能干吗？" class="headerlink" title="11.2. Volume 能干吗？"></a>11.2. Volume 能干吗？</h2><p>将运行的环境打包镜像，run 后形成容器实例运行。若 Docker 容器产生的数据不进行备份，那么当容器的实例删除后，容器内的数据也就没有了，为了能保存数据在 docker 中，因此使用卷（volume）。</p>
<p>数据卷的特点</p>
<ul>
<li>可在容器之间共享或重用数据。</li>
<li>卷中的更改可以直接实时生效。</li>
<li>数据卷的生命周期一直持续到没有容器使用它为止。</li>
<li>数据卷中的更改不会包含在镜像的更新中。</li>
</ul>
<h1 id="12-Dockerfile"><a href="#12-Dockerfile" class="headerlink" title="12. Dockerfile"></a>12. Dockerfile</h1><p>镜像构建的方式有两种，一种是通过 docker build 执行 Dockerfile 里的指令来构建镜像，另一种是通过 docker commit 将存在的容器打包成镜像，通常我们都是使用第一种方式来构建容器镜像。</p>
<h3 id="12-0-1-构建的基本原则"><a href="#12-0-1-构建的基本原则" class="headerlink" title="12.0.1. 构建的基本原则"></a>12.0.1. 构建的基本原则</h3><ol>
<li>镜像层数尽可能少</li>
<li>使用多阶段构造。<br> 所谓多阶段构建，实际上是允许在一个 Dockerfile 中出现多个 FROM 指令。最后生成的镜像，以最后一条 FROM 构建阶段为准，之前的 FROM 构建阶段会被抛弃。通过多阶段构建，<br> 后一个阶段的构建过程可以直接利用前一阶段的构建缓存，有效降低镜像大小。一个典型的场景是将编译环境和运行环境分离。</li>
<li>使用最小的基础镜像</li>
<li>避免不必要的安装包</li>
<li>一个容器只运行一个进程</li>
<li>构建缓存</li>
</ol>
<h3 id="12-0-2-Buildkit"><a href="#12-0-2-Buildkit" class="headerlink" title="12.0.2. Buildkit"></a>12.0.2. Buildkit</h3><p>Buildkit是改进后的后端，用于替代传统的Docker构建器。自2018年起，它已经与Docker捆绑在一起，并成为Docker引擎23.0版本的默认构建器。</p>
<p>它提供了一些特殊的功能：</p>
<ul>
<li>改进的缓存能力；</li>
<li>并行构建不同的层；</li>
<li>延迟拉取基础镜像（≥Buildkit 0.9）；</li>
</ul>
<p>使用Buildkit时，会发现docker build命令的输出看起来更清晰、更结构化。</p>
<p>在Docker版本低于23.0时，使用Buildkit的一种典型方法是设置Buildkit参数如下：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_BUILDKIT=1 docker build --platform linux/amd64 . -t someImage:someVersion</span><br><span class="line">DOCKER_BUILDKIT=1 docker push someImage:someVersion</span><br></pre></td></tr></table></figure>

<h3 id="12-0-3-Buildx"><a href="#12-0-3-Buildx" class="headerlink" title="12.0.3. Buildx"></a>12.0.3. Buildx</h3><p>Buildx是Docker的一个插件，能够充分利用Docker中的Buildkit的潜力。它的创建是因为Buildkit支持许多新的配置选项，不能全部以向后兼容的方式集成到docker build命令中。</p>
<h2 id="12-1-Dockerfile-是什么？"><a href="#12-1-Dockerfile-是什么？" class="headerlink" title="12.1. Dockerfile 是什么？"></a>12.1. Dockerfile 是什么？</h2><p>Dockerfile 是用来构建 Docker 镜像的文本文件，是一条条构建镜像所需的指令和参数构成的脚本。</p>
<p>关键字字母必须大写，后面必须有一个空格，以及至少一个参数。每条指令都会创建一个新的镜像层，并对镜像层进行提交。</p>
<h2 id="12-2-docker-commit"><a href="#12-2-docker-commit" class="headerlink" title="12.2. docker commit"></a>12.2. docker commit</h2><p>基于原有镜像的改变，创建一个新的镜像（image）。</p>
<p>用法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;提交的描述信息&quot;</span> -a=<span class="string">&quot;作者&quot;</span> 容器ID 目标镜像名:[标签名]</span><br><span class="line"></span><br><span class="line">Usage:  docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</span><br><span class="line"></span><br><span class="line">Create a new image from a container<span class="string">&#x27;s changes</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Options:</span></span><br><span class="line"><span class="string">  -a, --author string    Author (e.g., &quot;John Hannibal Smith &lt;hannibal@a-team.com&gt;&quot;)</span></span><br><span class="line"><span class="string">  -c, --change list      Apply Dockerfile instruction to the created image</span></span><br><span class="line"><span class="string">  -m, --message string   Commit message</span></span><br><span class="line"><span class="string">  -p, --pause            Pause container during commit (default true)</span></span><br></pre></td></tr></table></figure>

<h2 id="12-3-Dockerfile-builder"><a href="#12-3-Dockerfile-builder" class="headerlink" title="12.3. Dockerfile builder"></a>12.3. Dockerfile builder</h2><p>Dockerfile 是一个文本文件，其内包含了一条条的 **指令(Instruction)**，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p>
<p>注意：</p>
<blockquote>
<p>Docker 镜像构建使，确保每一层只添加真正需要添加的东西，任何无关的东西都应该清理掉。可以添加一组命令做清理的工作，删除为了编译构建所需要的软件。</p>
<p>在构建镜像时，RUN, ADD, COPY 指令对应的层会增加镜像大小，其他命令并不会增加最终的镜像大小。</p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除构建缓存 build cache</span></span><br><span class="line">docker builder prune -a -f</span><br></pre></td></tr></table></figure>

<p>从 <code>Docker 17.05</code> 版本起， <code>Docker</code> 才开始支持容器镜像的多阶段构建(multi-stage build)，所以使用 <code>docker</code> 版本必须高于 <code>17.05</code> （多阶段构建的意思就是把编译的过程也放同一个 <code>Dockerfile</code> 里，不用在自己的开发机或服务器上编译，再把编译出的二进制程序打入镜像）。</p>
<p>语法说明</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FROM：指定需要使用的基础镜像；</span><br><span class="line"></span><br><span class="line">MAINTAINER：定义脚本维护者；</span><br><span class="line"></span><br><span class="line">VOLUME：指定持久化文件目录；</span><br><span class="line"></span><br><span class="line">WORKDIR：切换到工作目录；</span><br><span class="line"></span><br><span class="line">ADD：将宿主机中的文件拷贝至 image 中，且会自动处理 URL 和解压 tar 压缩包。</span><br><span class="line"></span><br><span class="line">COPY：将文件和目录拷贝至 image 中。</span><br><span class="line"></span><br><span class="line">RUN：镜像构建时执行的命令；</span><br><span class="line"></span><br><span class="line">ENTRYPOINT：容器参数配置；</span><br></pre></td></tr></table></figure>


<p>例子：传统方式构建</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Go语言编译环境基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-alpine</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源码到镜像</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> server.go /build/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译镜像时，运行 go build 编译生成 server 程序</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux GOARCH=amd64 GOARM=6 go build -ldflags ‘-w -s’ -o server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器运行时入口程序</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [“/build/server”]</span></span><br></pre></td></tr></table></figure>

<p>多级构建</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 1 编译构建阶段</span></span><br><span class="line"><span class="comment">#  Go语言编译环境基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> golang:<span class="number">1.16</span>-alpine AS build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拷贝源码到镜像</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> server.go /build/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /build</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译镜像时，运行 go build 编译生成 server 程序</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> CGO_ENABLED=0 GOOS=linux GOARCH=amd64 GOARM=6 go build -ldflags ‘-w -s’ -o server</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 2 运行构建阶段</span></span><br><span class="line"><span class="comment">#  采用更小的运行时基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从编译阶段仅拷贝所需的编译结果到当前镜像中</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> —from=build /build/server /build/server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定容器运行时入口程序</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [“/build/server”]</span></span><br></pre></td></tr></table></figure>


<h3 id="12-3-1-RUN"><a href="#12-3-1-RUN" class="headerlink" title="12.3.1. RUN"></a>12.3.1. RUN</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN  # 用来执行命令的，运行一个 RUN 就表示构建一层镜像的层数</span><br></pre></td></tr></table></figure>

<h3 id="12-3-2-COPY"><a href="#12-3-2-COPY" class="headerlink" title="12.3.2. COPY"></a>12.3.2. COPY</h3><h3 id="12-3-3-ENV"><a href="#12-3-3-ENV" class="headerlink" title="12.3.3. ENV"></a>12.3.3. ENV</h3><p>设置环境变量</p>
<p>格式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br></pre></td></tr></table></figure>



<h3 id="12-3-4-EXPOSE"><a href="#12-3-4-EXPOSE" class="headerlink" title="12.3.4. EXPOSE"></a>12.3.4. EXPOSE</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 格式</span><br><span class="line">EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]</span><br></pre></td></tr></table></figure>

<p>在 Dockerfile 中写入这样的声明有两个好处:</p>
<ul>
<li>一个是帮助镜像使用者理解这个镜像服务的守护端口，以方便配置映射；</li>
<li>另一个用处则是在运行时使用随机端口映射时，也就是 <code>docker run -P</code> 时，会自动随机映射 <code>EXPOSE</code> 的端口。</li>
</ul>
<p>要将 <code>EXPOSE</code> 和在运行时使用 <code>-p &lt;宿主端口&gt;:&lt;容器端口&gt;</code> 区分开来。<code>-p</code>，是映射宿主端口和容器端口，</p>
<p><code>EXPOSE</code> 指令是声明容器运行时提供服务的端口，这只是一个声明，仅仅是声明容器打算使用什么端口而已，并不会自动在宿主进行端口映射。</p>
<h3 id="12-3-5-WORKDIR"><a href="#12-3-5-WORKDIR" class="headerlink" title="12.3.5. WORKDIR"></a>12.3.5. WORKDIR</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">WORKDIR 工作目录路径</span><br></pre></td></tr></table></figure>

<p>使用 <code>WORKDIR</code> 指令可以来指定工作目录（或者称为当前目录），以后各层的当前目录就被改为指定的目录，如该目录不存在，<code>WORKDIR</code> 会帮你建立目录。</p>
<p>不同层之间的执行环境是不一样的，是两个完全不同的容器。<code>WORKDIR</code> 的作用有效范围在当前层中，即下一个 <code>RUN</code> 执行之前。 </p>
<h3 id="12-3-6-USER"><a href="#12-3-6-USER" class="headerlink" title="12.3.6. USER"></a>12.3.6. USER</h3><p>格式：<code>USER &lt;用户名&gt;[:&lt;用户组&gt;]</code></p>
<p><code>USER</code> 指令和 <code>WORKDIR</code> 相似，都是改变环境状态并影响以后的层。<code>WORKDIR</code> 是改变工作目录，<code>USER</code> 则是改变之后层的执行 <code>RUN</code>, <code>CMD</code> 以及 <code>ENTRYPOINT</code> 这类命令的身份。</p>
<p>注意，<code>USER</code> 只是帮助你切换到指定用户而已，这个用户必须是事先建立好的，否则无法切换。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line">USER redis</span><br><span class="line">RUN [ <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>

<p>如果以 <code>root</code> 执行的脚本，在执行期间希望改变身份，比如希望以某个已经建立好的用户来运行某个服务进程，不要使用 <code>su</code> 或者 <code>sudo</code>，这些都需要比较麻烦的配置，而且在 TTY 缺失的环境下经常出错。建议使用 <a target="_blank" rel="noopener" href="https://github.com/tianon/gosu"><code>gosu</code></a>。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立 redis 用户，并使用 gosu 换另一个用户执行命令</span></span><br><span class="line">RUN groupadd -r redis &amp;&amp; useradd -r -g redis redis</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载 gosu</span></span><br><span class="line">RUN wget -O /usr/local/bin/gosu <span class="string">&quot;https://github.com/tianon/gosu/releases/download/1.12/gosu-amd64&quot;</span> \</span><br><span class="line"> &amp;&amp; <span class="built_in">chmod</span> +x /usr/local/bin/gosu \</span><br><span class="line"> &amp;&amp; gosu nobody <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 CMD，并以另外的用户执行</span></span><br><span class="line">CMD [ <span class="string">&quot;exec&quot;</span>, <span class="string">&quot;gosu&quot;</span>, <span class="string">&quot;redis&quot;</span>, <span class="string">&quot;redis-server&quot;</span> ]</span><br></pre></td></tr></table></figure>



<h2 id="12-4-问题"><a href="#12-4-问题" class="headerlink" title="12.4. 问题"></a>12.4. 问题</h2><h3 id="12-4-1-优化的基本原则"><a href="#12-4-1-优化的基本原则" class="headerlink" title="12.4.1. 优化的基本原则"></a>12.4.1. 优化的基本原则</h3><ul>
<li>变动越小的命令，越靠前，增加 cache 使用率。</li>
<li>合并目的相同的命令，减少构建层(layer)数。</li>
<li>使用国内源，或者内网服务加速构建。</li>
<li>少装些东西，不是代码依赖的就尽量别装。</li>
<li>记得加上合适的注释，以便日后的维护。</li>
</ul>
<h3 id="12-4-2-镜像构建很慢"><a href="#12-4-2-镜像构建很慢" class="headerlink" title="12.4.2. 镜像构建很慢"></a>12.4.2. 镜像构建很慢</h3><p>在dockerfile里面加上这个，或者全局挂代理，直接外网build就可以了。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUN sed -i <span class="string">&quot;s/archive.ubuntu./mirrors.aliyun./g&quot;</span> /etc/apt/sources.list</span><br><span class="line">RUN sed -i <span class="string">&quot;s/deb.debian.org/mirrors.aliyun.com/g&quot;</span> /etc/apt/sources.list</span><br><span class="line">RUN sed -i <span class="string">&quot;s/security.debian.org/mirrors.aliyun.com\/debian-security/g&quot;</span> /etc/apt/sources.list</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="12-4-3-镜像瘦身"><a href="#12-4-3-镜像瘦身" class="headerlink" title="12.4.3. 镜像瘦身"></a>12.4.3. 镜像瘦身</h3><p>镜像构建后，发现构建的体积很大，需要减小体积。</p>
<ul>
<li><p>用 distroless 去除容器中所有不必要的东西。</p>
<blockquote>
<p>distroless镜像只包含应用程序及其运行时依赖项，不包含程序包管理器、shell 以及标准 Linux 发行版中可以找到的任何其他程序都没有，是原始操作系统的精简版，没有额外的二进制文件。</p>
</blockquote>
<p>在生产环境中运行容器，并且关心性能问题，使用 distroless 更合适。</p>
</li>
<li><p>用小体积的的 Alpine 基础镜像。</p>
<blockquote>
<p>Alpine 是一个基于 musl libc 和 busybox 的面向安全的轻量级 Linux 发行版。</p>
</blockquote>
<p>注意点：</p>
<blockquote>
<p>基于 Alpine 基础镜像构建容器可能会导致非预期的行为，因为标准 C 库是不一样的。</p>
</blockquote>
</li>
</ul>
<h1 id="13-Docker-network"><a href="#13-Docker-network" class="headerlink" title="13. Docker network"></a>13. Docker network</h1><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@redis_181 ~]# docker network create --driver bridge --subnet=172.18.0.0/16 --gateway=172.18.0.1 zk_network</span><br><span class="line">7de8536fcab27bd0318f783fbe4c2ce5f72123fbe646f559eaf80e742bde63c5</span><br><span class="line">[root@redis_181 ~]#</span><br><span class="line"></span><br><span class="line">[root@redis_181 ~]# docker network <span class="built_in">ls</span></span><br><span class="line">NETWORK ID     NAME         DRIVER    SCOPE</span><br><span class="line">2914ee1d3e2a   bridge       bridge    <span class="built_in">local</span></span><br><span class="line">9a2d889dab32   host         host      <span class="built_in">local</span></span><br><span class="line">c6cc0e89cb3c   none         null      <span class="built_in">local</span></span><br><span class="line">7de8536fcab2   zk_network   bridge    <span class="built_in">local</span></span><br></pre></td></tr></table></figure>



<h2 id="13-1-bridge"><a href="#13-1-bridge" class="headerlink" title="13.1. bridge"></a>13.1. bridge</h2><p>Dcoker 服务默认会创建一个 docker0 网桥（其上有一个docker0内部接口），该桥接网络的名称为 <code>docker0</code>，它在内核层连通了其它的物理或虚拟网卡，这就将所有的容器和本地主机都放到同一个物理网络。Docker 默认制定了 docker0 接口的 IP 地址和子网掩码，让主机和 container 之间可以通过网桥互相通信。 </p>
<h2 id="13-2-Host"><a href="#13-2-Host" class="headerlink" title="13.2. Host"></a>13.2. Host</h2><p>container 将不会获得一个独立的 Network namespace ，而是和宿主机公用一个 Network namespace。container 将不会虚拟自己的网卡而是使用宿主机的IP和端口。</p>
<h1 id="14-面试问题"><a href="#14-面试问题" class="headerlink" title="14. 面试问题"></a>14. 面试问题</h1><ol>
<li><p>解释 Docker 的虚悬镜像是什么？</p>
<p> 仓库命、标签命都是 <code>none</code> 的镜像，俗称为虚悬镜像(dangling image)。</p>
</li>
</ol>
<h1 id="15-FAQ"><a href="#15-FAQ" class="headerlink" title="15. FAQ"></a>15. FAQ</h1><h2 id="15-1-Docker-空间占用清理"><a href="#15-1-Docker-空间占用清理" class="headerlink" title="15.1. Docker 空间占用清理"></a>15.1. Docker 空间占用清理</h2><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/longailk/article/details/122728982">https://blog.csdn.net/longailk/article/details/122728982</a></p>
<p>Docker下&#x2F;var&#x2F;lib&#x2F;docker&#x2F;overlay2空间清理办法</p>
<ul>
<li><p>docker的overlay2中存的都是什么？<br>存的是我们的镜像文件和容器内的文件</p>
</li>
<li><p>如何清理 <code>/var/lib/docker/overlay2</code>？</p>
<ul>
<li>删除不用的镜像</li>
<li>检查是否有容器内的服务会往容器内的本地写文件</li>
<li>检查各容器的磁盘占用，如果有发现磁盘占用过高的情况则对应处理【原则上如果容器内服务有写文件行为，则写文件的目录应当挂载到宿主机上，而不是直接往容器的本地写</li>
<li>需要应急处理的话可以先进入容器内直接删除容器内可以删除的文件</li>
</ul>
</li>
</ul>
<h1 id="16-References"><a href="#16-References" class="headerlink" title="16. References"></a>16. References</h1><ul>
<li>Docker 官网：<a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com/</a></li>
<li>Dockerhub，安装 Docker 镜像文件的仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></li>
<li>docker docs strtage: <a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver">https://docs.docker.com/storage/storagedriver</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Jacian/p/11421114.html">Docker搭建Zookeeper&amp;Kafka集群</a></li>
<li><a target="_blank" rel="noopener" href="https://thenewstack.io/container-networking-landscape-cni-coreos-cnm-docker">THE CONTAINER NETWORKING LANDSCAPE: CNI FROM COREOS AND CNM FROM DOCKER</a> 一篇英文文章，讲解 docker 和 container ecosystem。</li>
<li>Microsoft introduce docker-defined: <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/docker-defined">https://docs.microsoft.com/zh-cn/dotnet/architecture/microservices/container-docker-introduction/docker-defined</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/containernetworking/cni">Github 英文讲解 CNI - the Container Network Interface</a></li>
<li>Docker 社区版源码：<a target="_blank" rel="noopener" href="https://github.com/moby/moby">https://github.com/moby/moby</a></li>
<li>Docker在Windows的使用说明: <a target="_blank" rel="noopener" href="http://www.520code.net/index.php/archives/39">http://www.520code.net/index.php/archives/39</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/docker-containers-and-kubernetes-an-architectural">Docker Containers and Kubernetes: An Architectural Perspective</a></li>
<li><a target="_blank" rel="noopener" href="https://docker.renkeju.com/docker/docker.html">Docker 总体架构</a></li>
<li><a target="_blank" rel="noopener" href="https://www.linkedin.com/pulse/docker-kubernetes-security-principles-practices-dr-rabi-prasad-padhy">Docker and Kubernetes Security: Principles &amp; Practices</a> 深入讲解了 Docker 的底层原理。</li>
<li>Dockerfile 定制镜像：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/image/build">https://yeasy.gitbook.io/docker_practice/image/build</a></li>
<li>Dockers镜像瘦身：<a target="_blank" rel="noopener" href="https://docs.erda.cloud/blog/post/2021/07/15/docker-compression/">https://docs.erda.cloud/blog/post/2021/07/15/docker-compression/</a></li>
<li>如何优化 docker 镜像体积：<a target="_blank" rel="noopener" href="https://waynerv.com/posts/how-to-reduce-docker-image-size/">https://waynerv.com/posts/how-to-reduce-docker-image-size/</a></li>
<li>构建 Go 应用 docker 镜像的十八种姿势：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kevinwan/p/16033634.html">https://www.cnblogs.com/kevinwan/p/16033634.html</a></li>
<li>容器技术原理(一)：从根本上认识容器镜像：<a target="_blank" rel="noopener" href="https://waynerv.com/posts/container-fundamentals-learn-container-with-oci-spec">https://waynerv.com/posts/container-fundamentals-learn-container-with-oci-spec</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io">John Jeep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io/Docker/CloudNative/Docker/docker/">https://johnjeep.github.io/Docker/CloudNative/Docker/docker/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://johnjeep.github.io" target="_blank">Leaning Computer Science Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/cloudNative/">cloudNative</a><a class="post-meta__tags" href="/tags/docker/">docker</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Docker/CloudNative/Docker/Internal/" title="Internal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Internal</div></div><div class="info-2"><div class="info-item-1">  1. 理解 Docker 内部原理 Docke 容器本质上是宿主机的进程。 namespace 实现了资源隔离。 cgroups 实现了资源限制。 写时复制机制(copy-on-write)实现了高效的文件操作。  1.1. namespace资源隔离linux 内核提拱了 6 种 namespace 隔离的系统调用，如下图所示，但是真正的容器还需要处理许多其他工作。    namespace 系统调用参数 隔离内容    UTS CLONE_NEWUTS 主机名或域名   IPC CLONE_NEWIPC 信号量、消息队列和共享内存   PID CLONE_NEWPID 进程编号   Network CLONE_NEWNET 网络设备、网络战、端口等   Mount CLONE_NEWNS 挂载点（文件系统）   User CLONE_NEWUSER 用户组和用户组   实际上，linux 内核实现 namespace 的主要目的，就是为了实现轻量级虚拟化技术服务。在同一个...</div></div></div></a><a class="pagination-related" href="/Jenkins/CloudNative/Jenkins/Jenkins/" title="Jenkins"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Jenkins</div></div><div class="info-2"><div class="info-item-1">   JenkinsJenkins是一款开源 CI&amp;CD 软件，用于自动化各种任务，包括构建、测试和部署软件。  CI&#x2F;CD持续集成、自动部署流程  开发人员将代码push到gitlab中，触发jenkins的自动pull拉取代码，通过maven编译、打包，然后通过执行shell脚本使docker构建镜像并push到私服（或者阿里云）仓库，此操作完成后jenkins服务器上再执行SSH命令登录到部署服务器，docker从仓库（私服）拉取镜像，启动容器。整个操作流程完成。 References 【Linux】Docker 搭建 Jenkins: https://open.alipay.com/portal/forum/post/125401045 https://www.cnblogs.com/kevinwan/p/16007379.html 微服务从代码到k8s部署应有尽有大结局(k8s部署)：https://www.cnblogs.com/kevinwan/p/16007379.html  </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Docker/CloudNative/Docker/Compose-k8s/" title="Compose-k8s"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Compose-k8s</div></div><div class="info-2"><div class="info-item-1">   Docker Compose Kubernetes 区别Docker Compose和Kubernetes是两个不同的容器编排工具，它们解决了不同层次的问题，并且适用于不同规模和复杂度的应用程序。以下是它们之间的主要区别： 1. 复杂度和规模 Docker Compose： Docker Compose适用于相对较小、简单的应用，通常在单机或者少量主机上运行。它通过一个简单的docker-compose.yml文件来定义和管理应用程序的多个服务，适用于开发、测试、本地部署等场景。 Kubernetes： Kubernetes是一个用于自动化部署、扩展和管理容器化应用程序的开源平台，适用于大规模、复杂的分布式系统。它可以管理数千个容器，并提供高可用性、自动伸缩、负载均衡等功能。  2. 编排和管理 Docker Compose： Docker Compose提供了一个相对简单的编排模型，适用于启动和管理少量的容器服务。它对单机或者少量主机上的容器进行编排和管理。 Kubernetes：...</div></div></div></a><a class="pagination-related" href="/Docker/CloudNative/Docker/Compose/" title="Compose"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Compose</div></div><div class="info-2"><div class="info-item-1">  1. Introduce2. Abbreviation   缩写 英文全称 说明    dev development 开发   sit System Integrate Test 系统整合测试（内测）   uat User Acceptance Test 用户验收测试   pet Performance Evaluation Test 性能评估测试（压测）   sim simulation 仿真   prd&#x2F;prod production 产品&#x2F;正式&#x2F;生产   2.1. Install123456781. 下载镜像sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.23.2/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose2. 添加可执行权限chmod +x /usr/local/bin/docker-compose3....</div></div></div></a><a class="pagination-related" href="/Docker/CloudNative/Docker/Install/" title="Install"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Install</div></div><div class="info-2"><div class="info-item-1">  Linux 换源更换方法Ubuntu采用apt作为软件安装工具，其镜像源列表记录在/etc/apt/source.list文件中。首先将source.list复制为source.list.bak备份，然后将source.list内容改为需要的镜像源列表即可。修改完成后保存source.list文件，执行： 1sudo apt update  等待更新完成即可。 常用国内镜像源本节均为 Ubuntu 20.04 的镜像源列表。若为其他版本，将所有focal更改为其他版本代号即可。 常用的Ubuntu版本代号如下： 1234Ubuntu 22.04：jammyUbuntu 20.04：focalUbuntu 18.04：bionicUbuntu 16.04：xenial  Ubuntu...</div></div></div></a><a class="pagination-related" href="/Docker/CloudNative/Docker/Internal/" title="Internal"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Internal</div></div><div class="info-2"><div class="info-item-1">  1. 理解 Docker 内部原理 Docke 容器本质上是宿主机的进程。 namespace 实现了资源隔离。 cgroups 实现了资源限制。 写时复制机制(copy-on-write)实现了高效的文件操作。  1.1. namespace资源隔离linux 内核提拱了 6 种 namespace 隔离的系统调用，如下图所示，但是真正的容器还需要处理许多其他工作。    namespace 系统调用参数 隔离内容    UTS CLONE_NEWUTS 主机名或域名   IPC CLONE_NEWIPC 信号量、消息队列和共享内存   PID CLONE_NEWPID 进程编号   Network CLONE_NEWNET 网络设备、网络战、端口等   Mount CLONE_NEWNS 挂载点（文件系统）   User CLONE_NEWUSER 用户组和用户组   实际上，linux 内核实现 namespace 的主要目的，就是为了实现轻量级虚拟化技术服务。在同一个...</div></div></div></a><a class="pagination-related" href="/CloudNative/CloudNative/Actor/" title="Actor"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Actor</div></div><div class="info-2"><div class="info-item-1">  1. Actor Model1.1. 带着问题思考1.1.1. Actors是如何发送和接收消息的？在Actor模型中，消息是唯一的通信机制。Actors通过消息进行相互通信，它们不直接共享内存。以下是Actors如何发送和接收消息的基本概念：  发送消息：  Actors可以发送消息给其他Actors，也可以发送消息给自己。当一个Actor想要与另一个Actor通信时，它创建一个消息并将其发送给目标Actor的地址（通常称为PID，即Process...</div></div></div></a><a class="pagination-related" href="/CloudNative/CloudNative/CloudNative/" title="CloudNative"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">CloudNative</div></div><div class="info-2"><div class="info-item-1">   Cloud Native LandscapeCNCF Cloud Native Interactive Landscape </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Jeep</div><div class="author-info-description">lifestyle is lazy, faster, thinking</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JohnJeep/Learning-CS-Journey"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xxxxx@gmail.com" target="_blank" title="Gmail"><i class="fa-solid fa-bell" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0-Docker%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1. 为什么会出现 Docker？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Thinking"><span class="toc-number">2.</span> <span class="toc-text">2. Thinking</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Docker-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.</span> <span class="toc-text">3. Docker 是什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Docker-%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4. Docker 与传统虚拟机有什么不同？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88-Docker-%E6%AF%94%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%BF%AB%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5. 为什么 Docker 比虚拟机快？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Windows%E7%B3%BB%E7%BB%9F%E4%B8%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%BF%90%E8%A1%8C-Docker%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6. Windows系统上为什么能运行 Docker？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Docker-Component"><span class="toc-number">7.</span> <span class="toc-text">7. Docker Component</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-Docker-%E9%95%9C%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">7.1. Docker 镜像加载原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-Docker-image-layer"><span class="toc-number">7.2.</span> <span class="toc-text">7.2. Docker image layer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-Docker-%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">7.3. Docker 原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-Docker-Architecture"><span class="toc-number">8.</span> <span class="toc-text">8. Docker Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-Docker-%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.1.</span> <span class="toc-text">8.1. Docker 运行流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-Docker-Command"><span class="toc-number">9.</span> <span class="toc-text">9. Docker Command</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-help"><span class="toc-number">9.1.</span> <span class="toc-text">9.1. help</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-Container-Command"><span class="toc-number">9.2.</span> <span class="toc-text">9.2. Container Command</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-1-docker-run"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1. docker run</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-2-docker-ps"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2. docker ps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-3-exit"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3. exit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-4-docker-start"><span class="toc-number">9.2.4.</span> <span class="toc-text">9.2.4. docker start</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-5-docker-stop"><span class="toc-number">9.2.5.</span> <span class="toc-text">9.2.5. docker stop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-6-docker-restart"><span class="toc-number">9.2.6.</span> <span class="toc-text">9.2.6. docker restart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-7-docker-kill"><span class="toc-number">9.2.7.</span> <span class="toc-text">9.2.7. docker kill</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-8-docker-rm"><span class="toc-number">9.2.8.</span> <span class="toc-text">9.2.8. docker rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-9-docker-top"><span class="toc-number">9.2.9.</span> <span class="toc-text">9.2.9. docker top</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-10-docker-inspect"><span class="toc-number">9.2.10.</span> <span class="toc-text">9.2.10. docker inspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-11-docker-exec"><span class="toc-number">9.2.11.</span> <span class="toc-text">9.2.11. docker exec</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-12-docker-attach"><span class="toc-number">9.2.12.</span> <span class="toc-text">9.2.12. docker attach</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-13-docker-cp"><span class="toc-number">9.2.13.</span> <span class="toc-text">9.2.13. docker cp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-14-docker-logs"><span class="toc-number">9.2.14.</span> <span class="toc-text">9.2.14. docker logs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-15-docker-export"><span class="toc-number">9.2.15.</span> <span class="toc-text">9.2.15. docker export</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-16-docker-import"><span class="toc-number">9.2.16.</span> <span class="toc-text">9.2.16. docker import</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-Image-Command"><span class="toc-number">9.3.</span> <span class="toc-text">9.3. Image Command</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-docker-images"><span class="toc-number">9.3.1.</span> <span class="toc-text">9.3.1. docker  images</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-docker-search"><span class="toc-number">9.3.2.</span> <span class="toc-text">9.3.2. docker  search</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-docker-pull"><span class="toc-number">9.3.3.</span> <span class="toc-text">9.3.3. docker pull</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-docker-rmi"><span class="toc-number">9.3.4.</span> <span class="toc-text">9.3.4. docker rmi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-docker-system-df"><span class="toc-number">9.3.5.</span> <span class="toc-text">9.3.5. docker system df</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-6-docker-save"><span class="toc-number">9.3.6.</span> <span class="toc-text">9.3.6. docker save</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-7-docker-load"><span class="toc-number">9.3.7.</span> <span class="toc-text">9.3.7. docker load</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-8-docker-build"><span class="toc-number">9.3.8.</span> <span class="toc-text">9.3.8. docker build</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-Docker-%E4%B8%8B%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6"><span class="toc-number">10.</span> <span class="toc-text">10. Docker 下安装软件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-Docker-Volume"><span class="toc-number">11.</span> <span class="toc-text">11. Docker Volume</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1-Volume-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">11.1.</span> <span class="toc-text">11.1. Volume 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2-Volume-%E8%83%BD%E5%B9%B2%E5%90%97%EF%BC%9F"><span class="toc-number">11.2.</span> <span class="toc-text">11.2. Volume 能干吗？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-Dockerfile"><span class="toc-number">12.</span> <span class="toc-text">12. Dockerfile</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-0-1-%E6%9E%84%E5%BB%BA%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">12.0.1.</span> <span class="toc-text">12.0.1. 构建的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-0-2-Buildkit"><span class="toc-number">12.0.2.</span> <span class="toc-text">12.0.2. Buildkit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-0-3-Buildx"><span class="toc-number">12.0.3.</span> <span class="toc-text">12.0.3. Buildx</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-1-Dockerfile-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">12.1.</span> <span class="toc-text">12.1. Dockerfile 是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2-docker-commit"><span class="toc-number">12.2.</span> <span class="toc-text">12.2. docker commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-Dockerfile-builder"><span class="toc-number">12.3.</span> <span class="toc-text">12.3. Dockerfile builder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1-RUN"><span class="toc-number">12.3.1.</span> <span class="toc-text">12.3.1. RUN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2-COPY"><span class="toc-number">12.3.2.</span> <span class="toc-text">12.3.2. COPY</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-3-ENV"><span class="toc-number">12.3.3.</span> <span class="toc-text">12.3.3. ENV</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-4-EXPOSE"><span class="toc-number">12.3.4.</span> <span class="toc-text">12.3.4. EXPOSE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-5-WORKDIR"><span class="toc-number">12.3.5.</span> <span class="toc-text">12.3.5. WORKDIR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-6-USER"><span class="toc-number">12.3.6.</span> <span class="toc-text">12.3.6. USER</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4-%E9%97%AE%E9%A2%98"><span class="toc-number">12.4.</span> <span class="toc-text">12.4. 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-1-%E4%BC%98%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="toc-number">12.4.1.</span> <span class="toc-text">12.4.1. 优化的基本原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-2-%E9%95%9C%E5%83%8F%E6%9E%84%E5%BB%BA%E5%BE%88%E6%85%A2"><span class="toc-number">12.4.2.</span> <span class="toc-text">12.4.2. 镜像构建很慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-3-%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB"><span class="toc-number">12.4.3.</span> <span class="toc-text">12.4.3. 镜像瘦身</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#13-Docker-network"><span class="toc-number">13.</span> <span class="toc-text">13. Docker network</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-bridge"><span class="toc-number">13.1.</span> <span class="toc-text">13.1. bridge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-Host"><span class="toc-number">13.2.</span> <span class="toc-text">13.2. Host</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">14.</span> <span class="toc-text">14. 面试问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#15-FAQ"><span class="toc-number">15.</span> <span class="toc-text">15. FAQ</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-Docker-%E7%A9%BA%E9%97%B4%E5%8D%A0%E7%94%A8%E6%B8%85%E7%90%86"><span class="toc-number">15.1.</span> <span class="toc-text">15.1. Docker 空间占用清理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#16-References"><span class="toc-number">16.</span> <span class="toc-text">16. References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/CONVENTION/" title="CONVENTION">CONVENTION</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/README/" title="README">README</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/STARCHARTS/" title="STARCHARTS">STARCHARTS</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/AIGC/" title="AIGC">AIGC</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/ollama/" title="ollama">ollama</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Jeep</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>