<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Git | Leaning Computer Science Journey</title><meta name="author" content="John Jeep"><meta name="copyright" content="John Jeep"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="1. Git Command1.1. Git init git init 初始化一个 Git 仓库  1.2. Git add git add &lt;file&gt; 添加文件到暂存区 git add -p(patch) 依次存储每一个文件的改动，包括文件中做的哪些些改动  1.3. Git log git log 查看历史记录。按提交时间列出所有的更新，最近的更新排在最上面。显示的有 HA">
<meta property="og:type" content="article">
<meta property="og:title" content="Git">
<meta property="og:url" content="https://johnjeep.github.io/Git-SVN/Git-SVN/Git/index.html">
<meta property="og:site_name" content="Leaning Computer Science Journey">
<meta property="og:description" content="1. Git Command1.1. Git init git init 初始化一个 Git 仓库  1.2. Git add git add &lt;file&gt; 添加文件到暂存区 git add -p(patch) 依次存储每一个文件的改动，包括文件中做的哪些些改动  1.3. Git log git log 查看历史记录。按提交时间列出所有的更新，最近的更新排在最上面。显示的有 HA">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://johnjeep.github.io/img/butterfly-icon.png">
<meta property="article:published_time" content="2025-04-04T12:24:00.000Z">
<meta property="article:modified_time" content="2025-04-04T12:24:27.225Z">
<meta property="article:author" content="John Jeep">
<meta property="article:tag" content="git-SVN">
<meta property="article:tag" content="git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://johnjeep.github.io/img/butterfly-icon.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Git",
  "url": "https://johnjeep.github.io/Git-SVN/Git-SVN/Git/",
  "image": "https://johnjeep.github.io/img/butterfly-icon.png",
  "datePublished": "2025-04-04T12:24:00.000Z",
  "dateModified": "2025-04-04T12:24:27.225Z",
  "author": [
    {
      "@type": "Person",
      "name": "John Jeep",
      "url": "https://johnjeep.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://johnjeep.github.io/Git-SVN/Git-SVN/Git/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: John Jeep","link":"链接: ","source":"来源: Leaning Computer Science Journey","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Git',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/custom.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"></a><a class="nav-page-title" href="/"><span class="site-name">Git</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Git</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-04-04T12:24:27.225Z" title="更新于 2025-04-04 20:24:27">2025-04-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Git-SVN/">Git-SVN</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><!--
 * @Author: JohnJeep
 * @Date: 2019-04-04 23:28:59
 * @LastEditors: JohnJeep
 * @LastEditTime: 2025-04-04 19:20:16
 * @Description: Git 
 * Copyright (c) 2022 by johnjeep, All Rights Reserved.
-->

<h1 id="1-Git-Command"><a href="#1-Git-Command" class="headerlink" title="1. Git Command"></a>1. Git Command</h1><h2 id="1-1-Git-init"><a href="#1-1-Git-init" class="headerlink" title="1.1. Git init"></a>1.1. Git init</h2><ul>
<li><code>git init</code> 初始化一个 Git 仓库</li>
</ul>
<h2 id="1-2-Git-add"><a href="#1-2-Git-add" class="headerlink" title="1.2. Git add"></a>1.2. Git add</h2><ul>
<li><code>git add &lt;file&gt;</code> 添加文件到暂存区</li>
<li><code>git add -p(patch)</code> 依次存储每一个文件的改动，包括文件中做的哪些些改动</li>
</ul>
<h2 id="1-3-Git-log"><a href="#1-3-Git-log" class="headerlink" title="1.3. Git log"></a>1.3. Git log</h2><ul>
<li><code>git log</code> 查看历史记录。按提交时间列出所有的更新，最近的更新排在最上面。显示的有 HASH 散列码、提交日期、提交的注释等。<ul>
<li><code>HEAD</code> 表示当前版本，下标从零开始。</li>
<li><code>HEAD^</code> 上一个版本就是，<code>HEAD^^</code> 上上一个版本就是, 当然往上 100 个版本写 100 个 ^ 比较容易数不过来，所以写成 <code>HEAD~100</code></li>
</ul>
</li>
<li><code>git log -g</code>: 按照标准日志的格式输出引用日志 <code>reflog</code></li>
<li><code>git log -p</code> 打印提交更新的所有内容，包括文件的内容</li>
<li><code>git log -p -2</code> 显示最近两次提交的内容</li>
<li><code>git log --stat</code> 显示每次提交的简略统计信息，包括多少个文件改变、HASH 码、日期、提交的注释等信息。</li>
<li><code>git log --pretty=keyword</code> 指定使用不同于默认格式的方式展示提交历史。keyword 有以下内建的子选项<ul>
<li>online：将每个提交放在一行显示，查看的提交数很大时非常有用。</li>
<li>format：定制自己要显示的记录格式。</li>
</ul>
</li>
<li><code>git log --graph</code>：显示 ASCII 图形表示的分支合并历史，常与 <code>--pretty=format</code> 结合使用。例如：<code>git log --pretty=format:&quot;%h %s&quot; --graph</code></li>
<li><code>git log --all --graph --decorate</code> 用 ASCII 图像化显示所有提交的历史记录、各个分支的指向以及项目的分支分岔情况。</li>
<li><code>git log --since=2.weeks</code> 列出所有最近两周内的提交。since 与 until 按照时间对提交的内容做筛选，后面可以直接跟特定的时间。<code>--since=2020-01-07</code></li>
<li><code>git log -S 筛选内容 </code>  列出那些添加或移除了某些字符串的提交。</li>
<li><code>git fsck --full</code>: 显示出所有没有被其他对象指向的对象。<code>git fsck</code> 检查所有数据库的完整性。</li>
<li><code>gir log --name-status</code> 显示每次修改的文件列表及修改状态：新增、修改、删除。</li>
<li><code>git log --name-only</code> 只显示每次修改的文件列表</li>
</ul>
<hr>
<ul>
<li><code>git whatchanged</code>  显示每次修改的文件列表</li>
<li><code>git whatchanged --stat</code> 显示每次修改的文件列表及统计信息</li>
</ul>
<hr>
<ul>
<li><code>git reflog expire --expire=now --all</code> 清除所有 <code>reflog</code> 的引用</li>
<li><code>git show</code> 显示最后一次文件改变的具体内容</li>
</ul>
<h2 id="1-4-Git-tag"><a href="#1-4-Git-tag" class="headerlink" title="1.4. Git tag"></a>1.4. Git tag</h2><p>Git tag 有两种类型。</p>
<ul>
<li>轻量标签（lightweight）：很像一个不会改变的分支——它只是一个特定提交的引用。<ul>
<li>本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。</li>
<li><code>git tag 标签名 </code> 创建标签</li>
</ul>
</li>
<li>附注标签（annotated）：存储在 Git 数据库中的一个完整对象<ul>
<li><code>git tag -a v1.0 -m &quot;first commit&quot;</code> 创建标签;<code>-m</code> 选项指定了一条将会存储在标签中的信息。</li>
<li><code>git show 标签名 </code> 看到标签信息与对应的提交信息</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li><p><code>git tag -a 标签号 HASH 码 </code> 后期给指定文件打标签</p>
</li>
<li><p><code>git push origin(仓库别名) 标签名 </code> 将标签共享到远程仓库上</p>
</li>
<li><p><code>git push origin --tags</code> 将所有不在远程仓库服务器上的标签全部推送到上面。</p>
</li>
<li><p><code>git tag -d &lt;tagname&gt;</code> 删除掉本地仓库上的标签</p>
</li>
<li><p><code>git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; </code> 更新并删除远程仓库标签</p>
</li>
<li><p><code>git tag</code> 查看历史 tag 记录</p>
</li>
<li><p><code>git checkout v1.0</code> 切换到某个 tag，查看某个标签所指向的文件版本。</p>
<blockquote>
<p>注意： 会导致仓库处于分离头指针 (detacthed HEAD) 状态. 在 “分离头指针” 状态下，如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非确切的提交哈希。</p>
</blockquote>
</li>
</ul>
<h2 id="1-5-Git-alias"><a href="#1-5-Git-alias" class="headerlink" title="1.5. Git alias"></a>1.5. Git alias</h2><ul>
<li><code>git config --global alias.unstage &#39;reset HEAD --&#39;</code>  给取消暂存取一个别名</li>
</ul>
<h2 id="1-6-Git-checkout"><a href="#1-6-Git-checkout" class="headerlink" title="1.6. Git checkout"></a>1.6. Git checkout</h2><p>切换或者创建新分支</p>
<ul>
<li><code>git checkout  &lt;new_branch_name&gt;</code>   切换到 new_branch_name 分支下</li>
<li><code>git branch Develop</code>  新建 Develop 分支</li>
<li><code>git checkout -b &lt;new_branch_name&gt;</code>   创建 new_branch_new 分支，并切换到当前分支<blockquote>
<p>Git 2.23 版本之后，使用 <code>git switch</code> 替代原先的 <code>git chechout</code>。切换到已存在的分支: <code>git switch testing-branch</code>; 创建一个新分支并切换到当前分支: <code>git switch -c new-branch</code>; 返回到你 checkout 之前的分支: <code>git switch -</code></p>
</blockquote>
</li>
<li><code>git checkout -b &lt;new_branch_name&gt; origin/feature</code> 从远程已存在的 <code>feature</code> 分支上拉取代码到本地新建的分支 <code>new_branch_name</code>，同时切换到新创建的分支上。</li>
</ul>
<p>用暂存区或者指定 commit 提交内容覆盖工作区内容</p>
<ul>
<li>用暂存区内容覆盖工作区内容<ul>
<li><code>git checkout readme.txt</code> 将暂存区中的 <code>readme.txt</code> 文件还原到工作区，如果要还原多个文件，使用 <strong>空格</strong> 分隔</li>
<li>还原所有文件 <code>git checkout .</code></li>
<li>特别说明：如果 checkout 后面是文件名称，以下写法更为稳妥：<code>git checkout -- readme.txt</code><ul>
<li>文件名称前面有两个 <strong>横杠</strong>，并且中间采用 <strong>空格</strong> 分隔（否则报错）。此种方式可以防止 Git 出现误判，加入暂存区有一个文件名为 <code>ant</code>（没有后缀名），恰好当前项目也有有个名为 <code>ant</code> 的分支，这个时候 Git 会优先将 <code>ant</code> 当做分支处理，于是就有可能导致错误</li>
</ul>
</li>
</ul>
</li>
<li>指定 commit 提交的内容覆盖工作区<ul>
<li><code>git checkout Develop -- readme.txt</code>  将对应分支中的文件 (readme.txt) 还原到当前分支 (Develop) 的工作区</li>
</ul>
</li>
</ul>
<h2 id="1-7-Git-commit"><a href="#1-7-Git-commit" class="headerlink" title="1.7. Git commit"></a>1.7. Git commit</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">参数项</span><br><span class="line">  pick 使用这个参数，commit 信息什么都不用做。</span><br><span class="line">  reword 修改 commit 信息。</span><br><span class="line">  --edit  修改 commit 提交的内容。但是使用这个命令的时候，rebase 操作会停在 commit 提交处，等待修改完毕，使用 git add . 和  git commit --amend 修改提交，git rebase --<span class="built_in">continue</span> 继续 rebase 进程。</span><br><span class="line">  --squash 将当前需要改变的 commit 信息与之前 commit 提交的信息进行合并，把融合的信息保存到融合后的提交中。</span><br><span class="line">  --fixup 放弃融合后提交的提交信息。</span><br><span class="line">  <span class="built_in">exec</span> 在新的一行使用 shell 来运行 commit 信息。</span><br><span class="line">  drop 删除 commit 提交信息。</span><br></pre></td></tr></table></figure>

<p>修改最近一次的注释</p>
<ul>
<li><code>git commit --amend</code> 修改最后一次提交的注释</li>
<li><code>git rebase --continue</code> 执行修改的 commit</li>
<li>push 到远程 GitHub，若有冲突，需要将远程 repository 的代码 pull 到本地，然后再 push 到远程 repository。</li>
</ul>
<p>修改历史提交的注释</p>
<ul>
<li><code>git log -n 4</code> 查看最近 4 次操作的日志</li>
<li><code>git rabase -i HEAD~n</code> 修改倒数第 n 次的 commit</li>
<li>将 <code>pick</code> 修改为 <code>edit</code></li>
<li><code>git commit --amend</code> 修改 commit 的内容</li>
<li><code>git rebase --continue</code> 执行修改的 commit</li>
<li>push 到远程 GitHub，若有冲突，需要将远程 repository 的代码 pull 到本地，然后再 push 到远程 repository。</li>
</ul>
<p>Git commit 提交规范：请参考 <a href="./Git-commit-convertion.md">Git-commit-convertion.md</a> 文档。</p>
<h2 id="1-8-Git-diff"><a href="#1-8-Git-diff" class="headerlink" title="1.8. Git diff"></a>1.8. Git diff</h2><p>执行 <code>Git diff</code> 命令后，显示的结果分析：</p>
<blockquote>
<p>执行命令之后，绿色部分代表增加的内容，红色部分代表删除的内容，</p>
<p>—代表源文件，即修改前的文件；+++代表目标文件，即修改后的文件;</p>
<p>小技巧：比较两个分支中的文件有哪些差异时，先将原来的文件放在前面，改动后的文件放在后面。这样放的好处是：对显示的结果好分析，更符合常人的逻辑思考结果。比如，改动后的文件相对未改动之前的文件，有添加的行，显示结果就为 ++++，若有删除除的行，显示的结果就显示 ———，非常的直观。</p>
</blockquote>
<ul>
<li><code>git diff</code> 比较工作区和暂存区之间的差异</li>
<li><code>git diff HEAD</code> 比较工作区与最新本地仓库之间的差异</li>
<li><code>git diff --cached</code> 比较暂存区与最新本地仓库的差异</li>
<li><code>git diff --stat &lt;local branch&gt; &lt;remote branch&gt;</code> 比较本地分支与远程指定分支之间的差异。<ul>
<li>统计有哪些文件被改动，有多少文件被改动，使用 <code>--stat</code> 参数。<br>例如，比较本地分支 <code>feat_grpc</code> 与远程分支 <code>dev</code> 之间的差异<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff --stat feat_grpc  remotes/origin/dev</span><br></pre></td></tr></table></figure></li>
<li>查看指定路径下文件的详细差别。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 注意：路径名要在仓库的根路径之下</span><br><span class="line">git diff feat_grpc  remotes/origin/dev /src/comm.cpp</span><br></pre></td></tr></table></figure></li>
<li>查看本地仓库中分支为 <code>master</code> 的文件与 Github 远程仓库中别名为 <code>origin</code> 下 <code>master</code> 分支文件的差异。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff master origin/master</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="1-9-Git-stash"><a href="#1-9-Git-stash" class="headerlink" title="1.9. Git stash"></a>1.9. Git stash</h2><ul>
<li>Git 提供了一个 <code>stash</code> 功能，把当前工作现场” 储藏” 起来，等以后恢复现场后继续工作：<code>git stash</code>，去解决 Bug 问题。</li>
<li><code>git stash list</code> ：查看所有已存储的工作现场 。</li>
<li>Git 把 <code>stash</code> 内容存在某个地方了，需要恢复存储的内容，有两个办法<ol>
<li>用 <code>git stash apply</code> 恢复，但是恢复后，stash 内容并不删除，你需要用 <code>git stash drop</code> 来删除</li>
<li>用 <code>git stash pop</code>，恢复的同时把 <code>stash</code> 内容也删了。</li>
</ol>
</li>
</ul>
<h2 id="1-10-Git-blame"><a href="#1-10-Git-blame" class="headerlink" title="1.10. Git blame"></a>1.10. Git blame</h2><p>在 Git 中，<code>blame</code> 是一个命令，用于查看文件的每一行是由哪个提交引入的。它可以帮助你确定代码中每个行的作者和最后修改的时间。</p>
<p><code>git blame</code> 的基本用法如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;file&gt;</span><br></pre></td></tr></table></figure>

<p>这会显示文件的每一行，以及每一行最后一次修改的提交信息，包括提交的哈希值、作者的姓名、修改的日期和时间。</p>
<p>你也可以通过指定一个特定的提交范围来限制 <code>blame</code> 的输出。以下是几个示例：</p>
<ol>
<li>指定一个文件的某个版本：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;commit&gt; -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
这会显示指定提交中文件的每一行。</li>
<li>指定某个提交之前的所有提交：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;commit&gt;^ -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
这会显示指定提交之前的所有提交中文件的每一行。</li>
<li>指定一个提交范围：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git blame &lt;start-commit&gt;..&lt;end-commit&gt; -- &lt;file&gt;</span><br></pre></td></tr></table></figure>
这会显示指定提交范围内文件的每一行。</li>
</ol>
<p><code>git blame</code> 还支持其他一些选项，例如 <code>-L</code> 选项用于指定只显示文件中的特定行号范围，以及 <code>-w</code> 选项用于忽略空白字符的变化。<br>这些只是 <code>git blame</code> 的基本用法和一些常见选项，还有其他更高级的用法，你可以查看 Git 的官方文档或运行 <code>git blame --help</code> 来获取更多详细信息。</p>
<h2 id="1-11-Git-bisect"><a href="#1-11-Git-bisect" class="headerlink" title="1.11. Git bisect"></a>1.11. Git bisect</h2><p>找到某个 bug 是哪次 commit 的。</p>
<h2 id="1-12-Git-rebase"><a href="#1-12-Git-rebase" class="headerlink" title="1.12. Git rebase"></a>1.12. Git rebase</h2><p>Rebase 官方翻译为 “变基”，我觉得翻译为 <strong>重新改变基准</strong> 更为合适。<code>git rebase</code> 和 <code>git merge</code> 都可以用于分支的合并，但使用 <code>git rebase</code> 合并的分支，提交（commit）信息是线性的，因为它会清除当前分支提交（commit）的版本历史信息，只选择保留最后一次的提交信息；而 <code>merge</code> 是把不同分支的最终结果合并在一起。</p>
<p>总结下，<code>git rebase</code> 有两个功能</p>
<ol>
<li>压缩提交的记录。</li>
<li>分支合并时，让合并的分支更简洁，只选择保留最后一次的提交信息，线性显示提交的记录，观察起来更优美。</li>
</ol>
<h2 id="1-13-Git-revert"><a href="#1-13-Git-revert" class="headerlink" title="1.13. Git revert"></a>1.13. Git revert</h2><h2 id="1-14-Git-Reset"><a href="#1-14-Git-Reset" class="headerlink" title="1.14. Git Reset"></a>1.14. Git Reset</h2><p><code>git reset</code> 命令是 Git 提供的后悔药之一，它可以帮我们把内容恢复到指定的 <code>commit</code> 提交版本。</p>
<p><code>reset</code> 翻译成中文有 <strong>重置</strong> 的意思，恰如起名，<code>git reset</code> 命令可以重置当前分支所指向提交的位置。使用 <code>git reset</code> 命令后 <code>commit </code> 提交信息依然存在，只是当前分支所指向的 <code>commit</code> 提交进行了重置，分支所指向的新 <code>commit</code> 提交之后的提交就像消失了一样（<code>git log</code> 无法查询到）。</p>
<p><code>git reset</code> 后面紧跟一个指定的标识项。标识可以是 <code>sha-1</code> 值或者 <code>HEAD</code>、<code>HEAD^</code> 或者分支名称等形式。</p>
<ul>
<li>标识为 <code>commit</code> 提交信息的 hash 值。比如： <code>git reset 5609309 --hard</code>，也可以</li>
<li>标识为分支名称。比如：<code>git reset master^ --hard</code>。</li>
<li>标识为 <code>HEAD</code>。例如：<code>git reset HEAD^ --hard</code></li>
<li>标识为 <code>^</code>。<code>^</code> 表示当前分支所指向提交的前一个提交，<code>^^</code> 表示当前分支所指向提交的前一个分支的前一个分支，以此类推；<code>^^</code> 过多自然不太方便，可以使用 <code>HEAD~2</code> 表示</li>
</ul>
<p><code>mixed</code>、<code>soft</code> 和 <code>hard</code> 参数项的区别</p>
<ul>
<li><code>--mixed</code>：默认值，当重置分支所指向 <code>commit</code> 提交位置时，暂存区中的内容会被新指向的 <code>commit</code> 提交内容所替换，工作区内容不变，即它回退到某个版本，只保留源码，回退 commit 和 index 信息。</li>
<li><code>--soft</code>：暂存区和工作区的内容都保持原样，不会被替换，只回退了 commit 的信息。</li>
<li><code>--hard</code>：暂存区和工作区的内容都会被新指向的 <code>commit</code> 提交内容所替换，彻底回退到某个版本，本地的源码也会变为上一个版本的内容；<code>git reset --hard</code> 只影响被跟踪的文件，如果工作区有新增的文件，并不会被影响。</li>
</ul>
<p><font color=red> 注意 </font></p>
<blockquote>
<p>假如 <code>commit</code> 已经被 <code>push</code> 到远程仓库上，那么其他开发人员可能会基于对应的 <code>commit</code> 提交进行开发产生新的 <code>commit</code>，如果此时进行 <code>reset</code> 操作，会造成其他开发人员的提交历史丢失，这可能会产生严重后果。</p>
</blockquote>
<h2 id="1-15-Remove-or-Restore"><a href="#1-15-Remove-or-Restore" class="headerlink" title="1.15. Remove or Restore"></a>1.15. Remove or Restore</h2><p>文件的删除与重新存储文件。</p>
<h3 id="1-15-1-remove"><a href="#1-15-1-remove" class="headerlink" title="1.15.1. remove"></a>1.15.1. remove</h3><ul>
<li><p><code>rm</code> 删除命令，指令前面不加 <code>git</code></p>
<p>删除本地目录文件，不会删除提交到暂存区的文件。例如：<code>rm filename</code></p>
</li>
<li><p><code>git rm</code> 是 git 中封装的 <code>rm</code> 命令。</p>
<ul>
<li><code>git rm filename</code>：，删除已经提交到本地版本库中的内容，同时删除暂存区中的内容。</li>
<li><code>git rm --cache filename</code>：只删除暂存区中的 filename 文件。<blockquote>
<p><strong>特别说明</strong>：处于未跟踪状态 (untracked) 只是没有存在于暂存区。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>删除暂存区步骤</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> filename</span><br><span class="line">git commit -m <span class="string">&quot;comment content&quot;</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>删除暂存区并更新远程仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached filename</span><br><span class="line">git commit -m <span class="string">&quot;comment content&quot;</span></span><br><span class="line">git push origin master --force</span><br></pre></td></tr></table></figure>


<h3 id="1-15-2-restore"><a href="#1-15-2-restore" class="headerlink" title="1.15.2. restore"></a>1.15.2. restore</h3><p>恢复工作区中被删除的文件</p>
<ul>
<li><code>rm</code> 指令只是将工作区中的文件删除，已提交到暂存区中的文件依然存在。此时想要恢复被 <code>rm</code> 指令删除的文件，只要将暂存区内容恢复到工作区即可。</li>
<li><code>git checkout filename</code> ：恢复误删除的单个文件</li>
<li>恢复误删除的多个个文件<ul>
<li><code>git ls-files -d</code>：查看误删除的有哪些文件</li>
<li><code>git ls-files -d | xargs -i git checkout &#123;&#125;</code> 恢复多个文件</li>
</ul>
</li>
</ul>
<p>恢复暂存区中误删除的文件</p>
<ul>
<li><code>git rm</code> 命令会删除已经提交到本地版本库中的内容，同时暂存区中的内容也会被删除。若要想恢复删除的内容，那么只能从 <code>commit</code> 提交记录中恢复。使用 <code>git checkout HEAD readme.txt</code> 命令， 将最后一次 <code>commit</code> 提交的 <code>readme.txt</code> 文件从本地仓库中恢复。</li>
</ul>
<p><font color="red"> 任何情况都可以恢复吗? </font></p>
<blockquote>
<p>当然不是，如果你把 <code>.gti</code> 目录删除了，那肯定是无法再恢复。实质上，之所以能将删除的文件恢复，因为在 <code>.git</code> 目录中有备份，<code>Git</code> 会将 <strong>暂存区</strong> 或者 <strong>历史提交</strong> 中内容来恢复。</p>
</blockquote>
<h2 id="1-16-other-command"><a href="#1-16-other-command" class="headerlink" title="1.16. other command"></a>1.16. other command</h2><ul>
<li><code>git gc</code>: 清理不必要的文件并优化本地存储库（Cleanup unnecessary files and optimize the local repository）。</li>
<li><code>git count-objects -v</code>: 计算未打包的对象数量及其磁盘消耗（Count unpacked number of objects and their disk consumption）。</li>
<li><code>git update</code>: windows 下更新 git，使用命令 <code>git update-git-for-windows</code></li>
</ul>
<h1 id="2-Git-Branch"><a href="#2-Git-Branch" class="headerlink" title="2. Git Branch"></a>2. Git Branch</h1><h2 id="2-1-Local-repo-branch"><a href="#2-1-Local-repo-branch" class="headerlink" title="2.1. Local repo branch"></a>2.1. Local repo branch</h2><p>本地仓库分支常用命令</p>
<ul>
<li><code>git branch</code> 只查看本地仓库分支。</li>
<li><code>git branch -r</code> 只查看远程仓库的所有分支。</li>
<li><code>git branch -a</code> 查看远程和本地的已有的所有分支。</li>
<li><code>git branch -v</code> 查看每个分支最后一次提交的内容。</li>
<li><code>git reflog show --date=iso master</code>  查看指定分支的历次更改记录。</li>
<li><code>git branch --merge</code> 查看哪些分支已经合并到当前分支。</li>
<li><code>git branch --no-merged</code> 查看所有包含未合并工作的分支。</li>
<li><code>git branch branch_name</code> 创建一个分支，且不会自动切换到新分支中去。</li>
<li><code>git merge</code> 合并分支：在分支 <code>a</code> 下写代码，与分支 <code>master</code> 上的代码合并<ul>
<li>第一步，切换到分支 <code>master</code> 下 <code>git chechout master</code></li>
<li>第二步，与分支 <code>a</code> 合并 <code>git merge a</code></li>
</ul>
</li>
<li><code>git branch -d a</code> 删除指定分支 a 。删除分支时，不要在当前分支删除当前分支，一定要切换的到另一个分支去删除。</li>
<li><code>git branch -D a</code> 强制把未合并的分支删除</li>
<li><code>git branch | grep &quot;feature-&quot; | xargs git branch -d</code>  批量删除多个本地的分支</li>
<li><code>git log --oneline --decorate --graph --all</code> 查看提交历史、各个分支的指向以及项目的分支分叉情况</li>
<li><code>git stash save</code> 切换分支之前保存要修改的文件，不想提交之前的工作</li>
<li><code>git stash list</code> 查看存储在栈上的文件</li>
<li><code>git stash apply</code> 将最近存储的文件重新使用</li>
<li><code>git stash apply stash_name</code> 使用之前某次存储的文件</li>
</ul>
<h2 id="2-2-Remote-repo-branch"><a href="#2-2-Remote-repo-branch" class="headerlink" title="2.2. Remote repo branch"></a>2.2. Remote repo branch</h2><p>远程仓库分支常用命令</p>
<ul>
<li><p><code>git branch --remote</code> 查看远程仓库分支</p>
</li>
<li><p><code>git push &lt;remote&gt; --delete &lt;branch&gt;</code> 命令行终端删除远程仓库分支，remote 可为远程仓库地址或者是仓库的别名，branch 为待删除分支的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete feature_0426</span><br></pre></td></tr></table></figure></li>
</ul>
<p>常用分支命名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">develop</span><br><span class="line"></span><br><span class="line">topic</span><br><span class="line"></span><br><span class="line">proposed</span><br><span class="line"></span><br><span class="line">hotfix(紧急分支)</span><br><span class="line"></span><br><span class="line">iss534</span><br><span class="line"></span><br><span class="line">experiment</span><br></pre></td></tr></table></figure>

<p>重命名远程分支</p>
<ol>
<li>本地分支改名： <code>git branch -m 旧分支名 新分支名 </code></li>
<li>删除远程分支：<code>git push --delete origin 旧分支名 </code></li>
<li>将新分支名推上去： <code>git push origin 新分支名 </code></li>
<li>将新本地分支和远程相连： <code>git branch --set-upsteam-to origin / 新分支名 </code></li>
</ol>
<h2 id="2-3-Branches-Principle"><a href="#2-3-Branches-Principle" class="headerlink" title="2.3. Branches Principle"></a>2.3. Branches Principle</h2><p><font color="red">Git 中的分支只是指向提交对象之一的轻量级可移动指针。</font></p>
<p>Git 是怎么创建新分支的呢？ 很简单，它只是为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支， 你需要使用 git branch 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch testing</span><br></pre></td></tr></table></figure>

<img src="./figures/ctreate-branch.png" style="zoom: 50%;">

<blockquote>
<p>Git 分支的本质是一个文件：包含所指对象的校验和（长度为 40 的 SHA-1 character），所以它的创建和销毁都非常高效。 创建一个新分支就相当于往一个文件中写入 41 个 bytes (40 characters 和 1 newline)。</p>
</blockquote>
<p>Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 HEAD 的特殊指针。 请注意它和许多其它版本控制系统（如 Subversion 或 CVS）里的 HEAD 概念完全不同。 在 Git 中，它是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。 在本例中，你仍然在 master 分支上。 因为 git branch 命令仅仅 创建 一个新分支，并不会自动切换到新分支中去。<p><br><img src="./figures/HEAD-point-to-branch.png" style="zoom: 50%;"></p>
<p><font color="red">HEAD 指针指向的当前所在分支，HEAD 分支随着提交操作自动向前移动。</font></p>
<p>每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支。<code>HEAD</code> 不是指向提交，而是 <strong>指向</strong> <code>master</code>，<code>master</code> 才是 <strong>指向</strong> 提交的，所以 <code>HEAD</code> 指向当前所在分支。</p>
<p>一开始的时候，<code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code><strong>指向</strong><code>master</code>，就能确定当前分支，以及当前分支的提交点：<p><br><img src="./figures/HEAD-point-to-master.png" style="zoom:50%;"></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着你不断提交，<code>master</code> 分支的线也越来越长。当创建一个新的分支时，Git 就新建了一个指针叫 <code>testing</code>，指向与 <code>master</code> 相同的提交，当你 checkout 到 <code>testing</code> 分支下时，再把 <code>HEAD</code> 指针指向 <code>testing</code>，就表示当前分支在 <code>testing</code> 上:<p><br><img src="./figures/HEAD-point-to-current-branch.png" style="zoom:50%;"></p>
<p>Git 创建一个分支很快，因为除了增加一个 <code>testing</code> 指针，改变 <code>HEAD</code> 的指向，工作区的文件都没有任何变化！不过，从现在开始，对工作区的修改和提交就是针对 <code>testing</code> 分支了，比如新提交一次后，<code>testing</code> 指针往前移动一步，而 <code>master</code> 指针不变：<p><br><img src="./figures/HEAD-moves-checkout-master.png" style="zoom:50%;"></p>
<p>此时 Git 工作区中的 分支历史：<p><br><img src="./figures/divergent-history.png"></p>
<p>假如我们在 <code>testing</code> 上的工作完成了，就可以把 <code>testing</code> 合并到 <code>master</code> 上。Git 怎么合并呢？最简单的方法，就是直接把 <code>master</code> 指向 <code>testing</code> 的当前提交，就完成了合并：</p>
<p>合并完分支后，甚至可以删除 <code>testing</code> 分支。删除 <code>testing</code> 分支就是把 <code>testing</code> 指针给删掉，删掉后，我们就剩下了一条 <code>master</code> 分支：</p>
<h2 id="2-4-Branches-conflict"><a href="#2-4-Branches-conflict" class="headerlink" title="2.4. Branches conflict"></a>2.4. Branches conflict</h2><p>为什么会产冲突？</p>
<ul>
<li>两个分支中修改了相同的文件。<strong>注意：</strong> 两个分支中分别修改了不同文件中的部分，不会产生冲突，可以直接将这两部分合并。</li>
<li>两个分支中修改了同一个文件的名称</li>
</ul>
<p>采用 <code>Git rebase</code> 与 <code>git merge</code> 进行解决</p>
<h3 id="2-4-1-Git-rebase"><a href="#2-4-1-Git-rebase" class="headerlink" title="2.4.1. Git rebase"></a>2.4.1. Git rebase</h3><ul>
<li><p>合并多次提交纪录<br>例如：合并前 4 次提交的记录 <code>git rebase -i HEAD~4</code>，合并的 commit 不能是已经 push 到远程仓库的记录。</p>
<blockquote>
<p>本质是先取消自己的提交，临时保存，然后把当前分支更新到最新的 origin 分支，最后应用自己的提交。</p>
</blockquote>
</li>
</ul>
<p><font color="red"> 注意: </font><br>已经推送到 github 远程仓库的文件（多人开发的重要分支）不要使用 <code>git rebase</code>，否则远程仓库的分支记录会被修改，别人就不能正常的提交了。</p>
<h3 id="2-4-2-Git-merge"><a href="#2-4-2-Git-merge" class="headerlink" title="2.4.2. Git merge"></a>2.4.2. Git merge</h3><p>默认情况下，Git 执行 “快进式合并”（fast-farward merge），会直接将 Master 分支指向 Develop 分支。使用 <code>--no-ff</code>  参数，用普通模式合并，在 master 主分支上生成一个新的节点。可以在分支历史上看哪些曾经做过哪些的合并；而 <code>fast forward</code> 合并，则没有合并操作的记录，会丢掉分支信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev</span><br></pre></td></tr></table></figure>

<p>两个分支合并时，将一个分支的变更集成到另一个分支上。其中分支合并的语法如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git merge 要合并进来的分支名 --strategy = 合并策略</span><br><span class="line">git merge 要合并进来的分支名 --s = 合并策略</span><br></pre></td></tr></table></figure>

<p>合并策略可以省略。Git  merge 有很多的合并策略。其中常见的是 <code>Fast-forward</code>、<code>Recursive</code> 、<code>Ours</code>、<code>Theirs</code>、<code>Octopus</code>。 Git 默认会帮你自动挑选合适的合并策略，如果你需要强制指定，使用 <code>git merge -s &lt;策略名字&gt;</code> 即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fast-forward</span><br><span class="line"></span><br><span class="line">recursive：默认的合并策略，如果你不指定策略参数，那么将使用这个合并策略。这将直接使用递归三路合并算法进行合并。</span><br><span class="line"></span><br><span class="line">ours</span><br><span class="line"></span><br><span class="line">octopus</span><br><span class="line"></span><br><span class="line">subtree</span><br><span class="line"></span><br><span class="line">resolve</span><br></pre></td></tr></table></figure>

<p>分支合并步骤</p>
<ul>
<li>从远程仓库拉取数据 <code>git fetch origin master</code> 。有时需要将远程仓库分支的数据拉取到本地临时分支，可执行 <code>git fetch origin master:temp</code></li>
<li>查看远程仓库的版本 <code>git remote -v</code></li>
<li>比较本地仓库与远程仓库的区别 <code>git diff master origin/master</code></li>
<li>手动解决冲突，提交（commit）信息。</li>
<li>合并冲突，将远程仓库与本地仓库合并 <code>git merge origin master</code></li>
</ul>
<blockquote>
<p>Git <strong>合并分支</strong> 很快！就改改指针，工作区内容不变。</p>
</blockquote>
<h1 id="3-Git-Area"><a href="#3-Git-Area" class="headerlink" title="3. Git Area"></a>3. Git Area</h1><img  src="./figures/git-workflow.png" style="zoom: 50%;" />

<p>Git 与 GitHub 使用，有<strong>四个区</strong>，需要理解。</p>
<ul>
<li><code>Workspace</code>：名为工作区，也可以称为 Working Directory (工作目录)，是你电脑存放代码的地方。</li>
<li><code>Index</code>：名为暂存区，是 <code>.git</code> 目录下的一个 <code>index</code> 文件，它是 <strong>指向</strong> 文件的一个索引。</li>
<li><code>local repository</code>：名为本地版本库，是 <code>Git</code> 用来保存本地项目的元数据和对象数据库的地方。</li>
<li><code>Remote repository</code>：名为远程仓库，是远程服务器存放代码的地方。</li>
</ul>
<h2 id="3-1-Workspace"><a href="#3-1-Workspace" class="headerlink" title="3.1. Workspace"></a>3.1. Workspace</h2><p>Workspace (工作区) 也可以称为 Working Directory (工作目录)，是你电脑存放代码的地方。</p>
<img width="50%" hight="50%" src="./figures/working-directory.png"/>


<p>工作区目录下的每一个文件只有两种状态：已跟踪（tracked：添加到暂存区）或未跟踪（untracked：没有添加都暂存区）。</p>
<h2 id="3-2-Index"><a href="#3-2-Index" class="headerlink" title="3.2. Index"></a>3.2. Index</h2><p>在工作区路径下打开终端执行 <code>git init</code> 指令后，工作区内生成一个 <code>.git</code> 的文件，默认情况下，该文件的属性是隐藏的，不可见。<strong>暂存区</strong> 就是 <code>.git</code> 目录下有一个 <code>index</code> 文件，这个 <code>index</code> 中文翻译为 <code>暂存区</code>，它是 <strong>指向</strong> 文件的一个索引。而真正的文件是存储在 <code>.git/objects</code> 目录中。</p>
<p>当删除 <strong>暂存区</strong> 内容时，其实就是删除 <code>index</code> 文件中的内容，但 <code>.git/objects</code> 目录中的内容不会被删除。</p>
<img width="50%" hight="50%" src="./figures/index.png"/>


<ol>
<li>Git 清空暂存区</li>
</ol>
<ul>
<li><p>暂存区实质是 <code>.git</code> 目录下的 <code>index</code> 文件，只要将此文件删除，那么暂存区就被清空。可用这条命令来将暂存区中的内容清空 <code>rm .git /index</code> 。</p>
<p>暂存区存在的必要性</p>
<ul>
<li>有些朋友感觉暂存区多余，其实并非如此，通过这个过渡性区域可以使提交更加条理，避免无用琐碎提交。</li>
<li>暂存区就如同一个临时性仓库，可以将来自工作区的新文件或者修改文件暂时存放起来，然后统一提交到分支中的版本库中。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><code>git ls-files</code> 查看暂存区里所有的内容，后面可加下面任意的选项参数。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git ls-files 命令的默认参数是 --cached(-c)，默认情况下默认参数没有显示。</span><br><span class="line"></span><br><span class="line">- --cached(-c) 显示暂存区中的文件</span><br><span class="line">- --deleted(-d) 显示删除的文件</span><br><span class="line">- --modified(-m) 显示修改过的文件</span><br><span class="line">- --other(-o) 显示没有被 git 跟踪的文件</span><br><span class="line">- --stage(-s) 显示 mode 以及文件对应的 Blob 对象，可以获取暂存区中对应文件里面的内容。</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="3-3-Local-repository"><a href="#3-3-Local-repository" class="headerlink" title="3.3. Local repository"></a>3.3. Local repository</h2><p>Git 本地版本库是 <code>Git</code> 用来保存项目的元数据和对象数据库的地方。从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<p>工作目录下有一个默认隐藏的目录 <code>.git</code>，它并不属于工作目录，而是 Git 的本地版本库（Repository）。而版本库中内容很多，并且都很重要，有两个是我们实际操作中经常要遇到的，那就是暂存区（<code>index</code>）和分支（<code>branch</code>）。</p>
<p>将文件最终提交到版本库基本流程如下：</p>
<ul>
<li><code>git add</code>    将工作区未跟踪和修改文件提交到暂存区。</li>
<li><code>git commit</code> 将暂存区内容提交到版本库中，并执行更新 HEAD 指向的指针，这样就完成了引用与提交、提交与改动快照的——对应了。</li>
</ul>
<img width="50%" hight="50%" src="./figures/.git.png"/>

<p>Git 清空版本库</p>
<ul>
<li><code>rm -rf .git</code> 删除当前目录下的版本库（<code>.git</code> 目录）</li>
<li><code>git init</code>    重新初始化一个全新的版本库</li>
</ul>
<h2 id="3-4-Remote-repository"><a href="#3-4-Remote-repository" class="headerlink" title="3.4. Remote repository"></a>3.4. Remote repository</h2><h3 id="3-4-1-Git-remote"><a href="#3-4-1-Git-remote" class="headerlink" title="3.4.1. Git remote"></a>3.4.1. Git remote</h3><ul>
<li><p><code>git remote -v</code> 显示远程仓库的别名和对应的 URL。</p>
</li>
<li><p><code>git remote show remote_name</code> 查看某个远程仓库。</p>
</li>
<li><p><code>git remote rename old_name new_name</code> 重命名原仓库名字。</p>
</li>
<li><p><code>git remote rm remote_name</code> 移除一个远程仓库。</p>
</li>
<li><p><code>git remote add &lt;alias_name&gt; &lt;url&gt;</code> 本地仓库与仓库地址为 URL，别名为 <code>alias_name</code> 的远程仓库进行关联。</p>
</li>
<li><p>有些分支在远程其实早就被删除了，但是在你本地依然可以看见这些被删除的分支，可用下面的命令删除远程服务器上不再存在的远程分支引用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 删除本地仓库中已经不存在的远程分支引用</span></span><br><span class="line">git remote prune origin</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">更新远程分支信息并清理不存在的分支引用，保持本地仓库和远程仓库的同步。</span></span><br><span class="line">git remote update --prune</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-4-2-Git-pull-Git-fetch"><a href="#3-4-2-Git-pull-Git-fetch" class="headerlink" title="3.4.2. Git pull &amp;&amp; Git fetch"></a>3.4.2. Git pull &amp;&amp; Git fetch</h3><ul>
<li><code>git pull</code>: 将远程仓库上当前分支的数据抓取到本地仓库，并自动合并远程分支与本地仓库的分支，<code>git pull</code> 相当于 <code>git fetch</code> 和 <code>git merge</code> 两步操作的叠加。</li>
<li><code>git fetch</code>: 将远程仓库上当前分支的数据抓取到本地仓库，不修改本地仓库中的内容，需要自己手动进行合并。</li>
<li><code>git fetch &lt;远程仓库名&gt; &lt; 分支名 &gt; : &lt; 目标分支 &gt;</code><ul>
<li>远程仓库名可以是仓库的别名，也可以直接是仓库的 URL 地址。</li>
<li><code>git fetch origin master : temp</code> 拉取远程 origin 仓库中 master 分支的数据到本地新建的 temp 分支。</li>
</ul>
</li>
<li><code>git push &lt;远程主机名&gt; &lt; 本地分支名 &gt; : &lt; 远程分支名 &gt;</code><ul>
<li><code>git push origin main : main</code> 将本地 main 分支中的数据推送到远程 origin 仓库的 main 分支上。若后面不指定 <code>: &lt;远程分支名&gt;</code>，git 会默认将当前本地的分支提交到远程仓库的默认分支中。</li>
</ul>
</li>
</ul>
<h3 id="3-4-3-Remote-and-local-repository"><a href="#3-4-3-Remote-and-local-repository" class="headerlink" title="3.4.3. Remote and local repository"></a>3.4.3. Remote and local repository</h3><p><strong>远程仓库与本地的关联。</strong></p>
<ul>
<li><code>git remote add origin   git@github.com:michaelliao/learngit.git</code> 将本地仓库添加到远程 Git 仓库，默认别名为 <code>origin</code></li>
<li><code>git push origin master</code> 当前本地仓库内容推送到别名为 <code>origin</code>，分支为 <code>master</code> 的远程仓库。</li>
<li><code>git clone &lt;URL&gt; &lt;folder_name&gt;</code><ul>
<li>本地位置克隆一个远程仓库地址为 <code>URL</code> 的仓库，并将其写到 <code>folder_name</code> 文件中。这个 <code>&lt;folder_name&gt;</code> 是选择项，若不指定文件名，则克隆后的仓库名默认与远程仓库的名字一样。</li>
<li><code>git clone https://github.com/xxxxx/Guide.git</code> 远程 Guide 仓库克隆到一个同名的本地仓库</li>
<li><code>git clone https://github.com/xxxxx/Guide.git temp</code> 远程 Guide 仓库中内容克隆到名称为 <code>temp</code> 的本地仓库。</li>
</ul>
</li>
<li><code>git push -u origin master</code> 将当前分支的内容推送给远程仓库 <code>origin</code> 的 <code>master</code> 分支<ul>
<li>参数 <code>-u</code>，推送的同时将 <code>origin</code> 仓库的 <code>master</code> 分支设置为本地仓库当前分支的 <code>upstream（上游）</code>。</li>
<li>git 不但会把本地的 <code>master</code> 分支内容推送的远程新的 <code>master</code> 分支，还会把本地的 <code>master</code> 分支和远程的 <code>master</code> 分支关联起来，在以后的推送或者拉取时就可以简化命令。</li>
</ul>
</li>
</ul>
<h1 id="4-Git-Config"><a href="#4-Git-Config" class="headerlink" title="4. Git Config"></a>4. Git Config</h1><ul>
<li><p>配置项目或某个仓库的用户名和密码，该配置位于 <code>.git</code> 路径下的 <code>config</code> 文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> user.name xxxxx</span><br><span class="line">git config --<span class="built_in">local</span> user.email xxxx@gmail.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置系统用户级别的用户名和密码，该配置位于用户家目录下的 <code>.gitconfig</code> 文件中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name xxxxx</span><br><span class="line">git config --global user.email xxxx@gmail.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置当前操作系统下，所有用户使用 git 的用户名和密码，一般不建议这么做，不太安全。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --system user.name xxxxx</span><br><span class="line">git config --system user.email xxxx@gmail.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置了一个本地的凭证助手（credential helper）来处理凭证信息，以便在使用 Git 进行远程操作时，不需要每次都输入用户名和密码。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> credential.helper store</span><br></pre></td></tr></table></figure>

<p>当你运行这个命令时，Git 会将凭证信息存储在本地存储中，通常是在你的用户目录下的一个隐藏文件中（<code>.git-credentials</code>）。存储的凭证信息包括远程仓库的 URL、用户名和密码。</p>
<p>设置了 <code>credential.helper</code> 为 <code>store</code> 后，Git 会将凭证信息明文存储在本地文件中。这样，在后续的操作中，Git 将会自动从本地文件中读取凭证信息，而无需再次输入用户名和密码。这在简化日常的 Git 操作过程中非常有用，特别是当你需要频繁地与远程仓库进行交互时。</p>
<p>需要注意的是，存储凭证信息明文可能存在安全风险，因为其他人可以访问到这些凭证信息。因此，建议在安全的环境下使用 <code>store</code> 凭证助手，或者考虑使用其他更安全的凭证助手，如 <code>cache</code> 或 <code>osxkeychain</code>，它们可以更加安全地存储凭证信息。</p>
<p>如果你希望移除 <code>store</code> 凭证助手的配置，可以使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> --<span class="built_in">unset</span> credential.helper</span><br></pre></td></tr></table></figure>

<p>这会从 Git 配置中移除 <code>credential.helper</code> 的设置，并停止使用凭证助手来存储和管理凭证信息。</p>
<p>参考文献：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%87%AD%E8%AF%81%E5%AD%98%E5%82%A8">官网 Git 工具 - 凭证存储</a></li>
</ul>
</li>
</ul>
<h1 id="5-Git-Proxy"><a href="#5-Git-Proxy" class="headerlink" title="5. Git Proxy"></a>5. Git Proxy</h1><p>只对 github 进行代理，不影响国内的仓库</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https//github.com.proxy http://127.0.0.1:8001</span><br><span class="line">git config --global https.https//github.com.proxy https://127.0.0.1:8001</span><br></pre></td></tr></table></figure>

<p>设置全局代理，国内的仓库速度也会收到一定的影响。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line"></span><br><span class="line">// 取消全局代理</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<p>Windows 下修改 Host 文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.30.253.112 github.com</span><br><span class="line">192.30.253.113 github.com</span><br><span class="line">151.101.185.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure>


<h1 id="6-提交代码总结"><a href="#6-提交代码总结" class="headerlink" title="6. 提交代码总结"></a>6. 提交代码总结</h1><h2 id="6-1-第一次提交"><a href="#6-1-第一次提交" class="headerlink" title="6.1. 第一次提交"></a>6.1. 第一次提交</h2><ol>
<li><code>git init</code>  初始化</li>
<li><code>git add README.md</code>   提交到暂存库</li>
<li><code>git commit -m &quot;first commit&quot;</code>   为提交的文件添加注释说明</li>
<li><code>git remote add origin git@github.com:michaelliao/learngit.git</code>  本地 Git 库与远程的仓库关联</li>
<li><code>git push -u origin master</code>      本地库的所有内容推送到远程库上</li>
</ol>
<h2 id="6-2-不是第一次提交"><a href="#6-2-不是第一次提交" class="headerlink" title="6.2. 不是第一次提交"></a>6.2. 不是第一次提交</h2><ol>
<li><code>git add README.md</code>  提交到暂存库</li>
<li><code>git commit -m &quot;first commit&quot;</code>   为提交的文件添加注释说明</li>
<li><code>git push origin master</code> 本地库的所有内容推送到远程库上</li>
</ol>
<h1 id="7-Git-常用命令"><a href="#7-Git-常用命令" class="headerlink" title="7. Git 常用命令"></a>7. Git 常用命令</h1><ul>
<li><code>git init</code> 初始化一个 Git 仓库 。</li>
<li><code>git add &lt;file&gt;</code> 添加文件到暂存区。</li>
<li><code>git add -p(patch)</code> 依次存储每一个文件的改动，包括文件中做的哪些改动。</li>
<li><code>git commit -m &lt;message&gt;</code> 给添加到暂存区的文件增加注释，<code>-m</code> 代表是提交信息。</li>
<li><code>git status</code> 查看当前工作区的状态。</li>
<li><code>git diff</code> 比较工作区中当前文件和暂存区快照之间的差异。</li>
<li><code>git diff --stage</code> 查看已暂存的将要添加到下次提交里的内容。</li>
<li><code>git difftool</code> 使用图像化工具查看工作区与暂存区之间的差异。</li>
<li><code>git reflog</code> 查看引用日志。每次提交或改变分支都会改变引用日志 <code>reflog</code>。</li>
<li><code>git reset --hard HEAD^</code> 回退到 <code>HEAD^</code> 版本。</li>
<li><code>git config --list</code> 列出 Git 所有当的配置信息。</li>
<li><code>git help &lt;verb&gt;</code> 查看帮助，verb 为 Git 的关键字。</li>
</ul>
<h1 id="8-References"><a href="#8-References" class="headerlink" title="8. References"></a>8. References</h1><p>官方手册</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://git-scm.com/docs">git-scm.com</a>: Git 官方参考手册。</li>
<li><a target="_blank" rel="noopener" href="https://training.github.com/">GitHub Training Kit</a>: 来自 Github 官方专业服务团队的开源课程软件，非常好！！！</li>
</ul>
<hr>
<p>博客、文章</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/geeeeeeeeek/git-recipes"><strong>git-recipes</strong></a>：github 上开源的 git 中文食谱，收集了许多国外优秀的文章，质量很高。</li>
<li><a target="_blank" rel="noopener" href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解 Git</a>: 采用画图的方式来理解 Git。</li>
<li><a target="_blank" rel="noopener" href="https://learngitbranching.js.org/">Learn Git Branching</a>：通过玩游戏的方式来学习 Git。</li>
<li><a target="_blank" rel="noopener" href="https://missing.csail.mit.edu/2020/version-control/">Version Control (Git)</a>: MIT 2020 年开设的一门 missing-semester 课程，这是 Version Control (Git) 章节。</li>
<li>Git 头指针分离状态: <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32907195/article/details/109217034">https://blog.csdn.net/qq_32907195/article/details/109217034</a></li>
<li>GitHub 实用小技巧总结: <a target="_blank" rel="noopener" href="https://github.com/Snailclimb/JavaGuide/blob/main/docs/tools/git/github-tips.md">https://github.com/Snailclimb/JavaGuide/blob/main/docs/tools/git/github-tips.md</a></li>
<li>Git 多平台换行符问题(LF or CRLF): <a target="_blank" rel="noopener" href="https://kuanghy.github.io/2017/03/19/git-lf-or-crlf">https://kuanghy.github.io/2017/03/19/git-lf-or-crlf</a></li>
<li><a target="_blank" rel="noopener" href="https://wiki.imalan.cn/archives/Git%20%E4%BB%A3%E7%90%86%E9%85%8D%E7%BD%AE%E6%96%B9%E6%A1%88/">Git 代理配置方案</a></li>
</ul>
<hr>
<p>Git branch</p>
<ul>
<li>彻底搞懂 Git-Rebase: <a target="_blank" rel="noopener" href="http://jartto.wang/2018/12/11/git-rebase/">http://jartto.wang/2018/12/11/git-rebase/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/gavincoder/p/9071959.html">Git 冲突与解决方法</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shuimuzhushui/p/9022549.html">Git 分支合并冲突解决</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io">John Jeep</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://johnjeep.github.io/Git-SVN/Git-SVN/Git/">https://johnjeep.github.io/Git-SVN/Git-SVN/Git/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://johnjeep.github.io" target="_blank">Leaning Computer Science Journey</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/git-SVN/">git-SVN</a><a class="post-meta__tags" href="/tags/git/">git</a></div><div class="post-share"><div class="social-share" data-image="/img/butterfly-icon.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/Git-SVN/Git-SVN/Git-commit-convention/" title="Git-commit-convention"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Git-commit-convention</div></div><div class="info-2"><div class="info-item-1"> 1. Git Commit 规范约定1.1. 背景Git 每次提交代码都需要写 commit message，否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的，具体做了什么操作，但是在日常开发中，大家的 commit message 千奇百怪，中英文混合使用、fix bug 等各种笼统的 message 司空见怪，这就导致后续代码维护成本特别大，有时自己都不知道自己的 fix bug 修改的是什么问题。基于以上这些问题，我们希望通过某种方式来监控用户的 git commit message，让规范更好的服务于质量，提高大家的研发效率。 1.2. Commit message 结构提交信息应该遵循下面的结构： 12345&lt;type&gt;[optional scope]: &lt;description&gt;[optional body][optional footer(s)]  type: 是必选项，表示类型。用于说明 git commit 的类别，只允许使用下面的标识。  feat：新功能（a new...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/SVN/" title="SVN"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">SVN</div></div><div class="info-2"><div class="info-item-1">  1. 概念什么是Subversion?  Subversion的版本库是一种特别的文件版本库，它会记录每一次改变：每个文件的改变，甚至是目录树本身的改变。  文件共享  一般的文件共享采用的是 lock-modify-unlock 的方式 Subversion、VS和一些版本控制系统使用  copy-modify-merge模型。 在这种模型里，每一个客户联系项目版本库建立一个个人工作拷贝—版本库中文件和目录的本地映射。用户并行工作，修改各自的工作拷贝，最终，各个私有的拷贝合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。    工作副本   .svn 为名的文件夹，也被叫做工作副本的管理目录，这个目录里的文件能够帮助 Subversion...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/Git-SVN/Git-SVN/GIt-SVN/" title="GIt-SVN"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">GIt-SVN</div></div><div class="info-2"><div class="info-item-1">服务器使用的是 SVN，但是想本地使用 Git 的 local branch 或者离线编辑代码等，这时 Git-SVN 就是最好的。 下面是 Git-SVN 通用的操作 1234567891011121314151617181920#Download an SVN project and its entire code history and initialize it as a git code base$ git svn clone -s [repository]#View the current version Library$ git svn info#Retrieve changes from all branches of the remote warehouse$ git svn fetch#Retrieve the changes of the current branch of the remote warehouse and merge it with the local branch$ git svn rebase #Upload the local...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/Git-FAQ/" title="Git-FAQ"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Git-FAQ</div></div><div class="info-2"><div class="info-item-1">  1. FAQ1.1. git 远程仓库更换名称，本地如何修改？ 适用于本地和远程的代码没得任何问题，就是远程仓库改了个名称，直接在本地修改远程仓库地址即可： git remote set-url origin new_address 另外还可以先删除，然后添加地址：12git remote rm origingit remote add origin new_address    1.2. Git 中文乱码 解决 Git 在 windows 下中文乱码的问题  1.3. LF or CRLFGit 多平台换行符问题 (LF or CRLF)。文本文件所使用的换行符，在不同的系统平台上是不一样的。UNIX&#x2F;Linux 使用的是 0x0A（LF），早期的 Mac OS 使用的是 0x0D（CR），后来的 OS X 在更换内核后与 UNIX 保持一致了。但 DOS&#x2F;Windows 一直使用 0x0D0A（CRLF） 作为换行符。 跨平台协作开发是常有的，不统一的换行符确实对跨平台的文件交换带来了麻烦。最大的问题是，在不同平台上，换行符发生改变时，Git...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/Git-Install/" title="Git-Install"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Git-Install</div></div><div class="info-2"><div class="info-item-1">Git 安装Git 是一个开源跨平台的版本管理软件，可以运行在 Windows、Linux&#x2F;Unix、macOS 等不同的操作系统上。下面讲解在不同平台上的安装。 WindowsLinux电脑连接了网络，安装操作步骤很简单。比如在 Ubuntu 平台下，只需要执行 sudo apt install git 就可以；但在 Centos 系统中，使用 yum 源安装的 git 版本是1.7.1，太老了，Github 需要的 Git 版本最低都不能低于1.7.2 。 所以我们一般不用上面的方法。而是下载 git 源码，编译安装，或者因环境的保密性，工作电脑没有连接外网，需要采用源码的形式安装 Git。 源码的安装一般分为三部：配置(configure)、编译(make)、安装(make install)  卸载 CentOS 系统中老的 Git。 1yum remove git  首先下载 Git 相应的依赖环境，可以在一台有网的电脑中执行下面的命令，将下载好的依赖通过 ftp 工具上传到要安装的服务器中。 1yum install curl-devel...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/Git-Internals/" title="Git-Internals"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Git-Internals</div></div><div class="info-2"><div class="info-item-1">  1. Git协议Git 支持四种协议传输  本地(Local)协议 Git协议 HTTP协议 SSH(Secure Shell)协议  1.1. SSH(Secure Shell)协议SSH 协议支持口令与密钥两种安全验证模式，但无论那种模式，最终都需要使用密钥来加密数据以确保安全，而 SSH 密钥通常使用的算法为 RSA 和 DSA。 命令　  SSH1：只支持RSAS算法 SSH2：支持RSA和DSA算法   ssh -T git@github.com 查看SSHkey sssh-keygen -t rsa 使用RSA算法创建密钥 id_rsa 密钥 和 id_rsa.pub...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/Git-commit-convention/" title="Git-commit-convention"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">Git-commit-convention</div></div><div class="info-2"><div class="info-item-1"> 1. Git Commit 规范约定1.1. 背景Git 每次提交代码都需要写 commit message，否则就不允许提交。一般来说，commit message 应该清晰明了，说明本次提交的目的，具体做了什么操作，但是在日常开发中，大家的 commit message 千奇百怪，中英文混合使用、fix bug 等各种笼统的 message 司空见怪，这就导致后续代码维护成本特别大，有时自己都不知道自己的 fix bug 修改的是什么问题。基于以上这些问题，我们希望通过某种方式来监控用户的 git commit message，让规范更好的服务于质量，提高大家的研发效率。 1.2. Commit message 结构提交信息应该遵循下面的结构： 12345&lt;type&gt;[optional scope]: &lt;description&gt;[optional body][optional footer(s)]  type: 是必选项，表示类型。用于说明 git commit 的类别，只允许使用下面的标识。  feat：新功能（a new...</div></div></div></a><a class="pagination-related" href="/Git-SVN/Git-SVN/SVN/" title="SVN"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-04-04</div><div class="info-item-2">SVN</div></div><div class="info-2"><div class="info-item-1">  1. 概念什么是Subversion?  Subversion的版本库是一种特别的文件版本库，它会记录每一次改变：每个文件的改变，甚至是目录树本身的改变。  文件共享  一般的文件共享采用的是 lock-modify-unlock 的方式 Subversion、VS和一些版本控制系统使用  copy-modify-merge模型。 在这种模型里，每一个客户联系项目版本库建立一个个人工作拷贝—版本库中文件和目录的本地映射。用户并行工作，修改各自的工作拷贝，最终，各个私有的拷贝合并在一起，成为最终的版本，这种系统通常可以辅助合并操作，但是最终要靠人工去确定正误。    工作副本   .svn 为名的文件夹，也被叫做工作副本的管理目录，这个目录里的文件能够帮助 Subversion...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/butterfly-icon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">John Jeep</div><div class="author-info-description">lifestyle is lazy, faster, thinking</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">262</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">289</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/JohnJeep/Learning-CS-Journey"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/xxxxx" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="/xxxxx@gmail.com" target="_blank" title="Gmail"><i class="fa-solid fa-bell" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-Git-Command"><span class="toc-number">1.</span> <span class="toc-text">1. Git Command</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Git-init"><span class="toc-number">1.1.</span> <span class="toc-text">1.1. Git init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Git-add"><span class="toc-number">1.2.</span> <span class="toc-text">1.2. Git add</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-Git-log"><span class="toc-number">1.3.</span> <span class="toc-text">1.3. Git log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Git-tag"><span class="toc-number">1.4.</span> <span class="toc-text">1.4. Git tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-Git-alias"><span class="toc-number">1.5.</span> <span class="toc-text">1.5. Git alias</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-Git-checkout"><span class="toc-number">1.6.</span> <span class="toc-text">1.6. Git checkout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-Git-commit"><span class="toc-number">1.7.</span> <span class="toc-text">1.7. Git commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-8-Git-diff"><span class="toc-number">1.8.</span> <span class="toc-text">1.8. Git diff</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-9-Git-stash"><span class="toc-number">1.9.</span> <span class="toc-text">1.9. Git stash</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-10-Git-blame"><span class="toc-number">1.10.</span> <span class="toc-text">1.10. Git blame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-11-Git-bisect"><span class="toc-number">1.11.</span> <span class="toc-text">1.11. Git bisect</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-12-Git-rebase"><span class="toc-number">1.12.</span> <span class="toc-text">1.12. Git rebase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-13-Git-revert"><span class="toc-number">1.13.</span> <span class="toc-text">1.13. Git revert</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-14-Git-Reset"><span class="toc-number">1.14.</span> <span class="toc-text">1.14. Git Reset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-15-Remove-or-Restore"><span class="toc-number">1.15.</span> <span class="toc-text">1.15. Remove or Restore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-1-remove"><span class="toc-number">1.15.1.</span> <span class="toc-text">1.15.1. remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-15-2-restore"><span class="toc-number">1.15.2.</span> <span class="toc-text">1.15.2. restore</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-16-other-command"><span class="toc-number">1.16.</span> <span class="toc-text">1.16. other command</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Git-Branch"><span class="toc-number">2.</span> <span class="toc-text">2. Git Branch</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Local-repo-branch"><span class="toc-number">2.1.</span> <span class="toc-text">2.1. Local repo branch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Remote-repo-branch"><span class="toc-number">2.2.</span> <span class="toc-text">2.2. Remote repo branch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Branches-Principle"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. Branches Principle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Branches-conflict"><span class="toc-number">2.4.</span> <span class="toc-text">2.4. Branches conflict</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-Git-rebase"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1. Git rebase</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-Git-merge"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2. Git merge</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Git-Area"><span class="toc-number">3.</span> <span class="toc-text">3. Git Area</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Workspace"><span class="toc-number">3.1.</span> <span class="toc-text">3.1. Workspace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Index"><span class="toc-number">3.2.</span> <span class="toc-text">3.2. Index</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Local-repository"><span class="toc-number">3.3.</span> <span class="toc-text">3.3. Local repository</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Remote-repository"><span class="toc-number">3.4.</span> <span class="toc-text">3.4. Remote repository</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-Git-remote"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.4.1. Git remote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-Git-pull-Git-fetch"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.4.2. Git pull &amp;&amp; Git fetch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-Remote-and-local-repository"><span class="toc-number">3.4.3.</span> <span class="toc-text">3.4.3. Remote and local repository</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Git-Config"><span class="toc-number">4.</span> <span class="toc-text">4. Git Config</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-Git-Proxy"><span class="toc-number">5.</span> <span class="toc-text">5. Git Proxy</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">6. 提交代码总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">6.1.</span> <span class="toc-text">6.1. 第一次提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E4%B8%8D%E6%98%AF%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">6.2.</span> <span class="toc-text">6.2. 不是第一次提交</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Git-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">7.</span> <span class="toc-text">7. Git 常用命令</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-References"><span class="toc-number">8.</span> <span class="toc-text">8. References</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/CONVENTION/" title="CONVENTION">CONVENTION</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/README/" title="README">README</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/Learning-CS-Journey/STARCHARTS/" title="STARCHARTS">STARCHARTS</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/AIGC/" title="AIGC">AIGC</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/AI/AI/ollama/" title="ollama">ollama</a><time datetime="2025-04-04T12:24:00.000Z" title="发表于 2025-04-04 20:24:00">2025-04-04</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By John Jeep</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>